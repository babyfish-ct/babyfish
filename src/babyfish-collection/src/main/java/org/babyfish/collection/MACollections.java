/*
 * BabyFish, Object Model Framework for Java and JPA.
 * https://github.com/babyfish-ct/babyfish
 *
 * Copyright (c) 2008-2016, Tao Chen
 *
 * This copyrighted material is made available to anyone wishing to use, modify,
 * copy, or redistribute it subject to the terms and conditions of the GNU
 * Lesser General Public License, as published by the Free Software Foundation.
 *
 * Please visit "http://opensource.org/licenses/LGPL-3.0" to know more.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
 * for more details.
 */
package org.babyfish.collection;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectStreamException;
import java.io.Serializable;
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.NavigableMap;
import java.util.NavigableSet;
import java.util.NoSuchElementException;
import java.util.RandomAccess;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.function.Consumer;
import java.util.function.Function;

import org.babyfish.collection.BidiType;
import org.babyfish.collection.event.ElementListener;
import org.babyfish.collection.event.EntryElementListener;
import org.babyfish.collection.event.KeySetElementListener;
import org.babyfish.collection.event.ListElementListener;
import org.babyfish.collection.event.MapElementListener;
import org.babyfish.collection.event.ValuesElementListener;
import org.babyfish.collection.spi.base.BasicAlgorithms;
import org.babyfish.collection.viewinfo.ListViewInfos;
import org.babyfish.data.LockDescriptor;
import org.babyfish.data.ViewInfo;
import org.babyfish.lang.Arguments;
import org.babyfish.lang.I18N;
import org.babyfish.lang.IllegalThreadException;
import org.babyfish.validator.Validator;

/**
 * @author Tao Chen
 */
public class MACollections {
    
    @SuppressWarnings("rawtypes")
    private static final XList EMPTY_LIST =
            unmodifiable(new ArrayList<Object>());
    
    @SuppressWarnings("rawtypes")
    private static final XNavigableSet EMPTY_SET =
        unmodifiable(new TreeSet<Object>());
    
    @SuppressWarnings("rawtypes")
    private static final XOrderedSet EMPTY_ORDERED_SET =
        unmodifiable(new LinkedHashSet<Object>());
    
    @SuppressWarnings("rawtypes")
    private static final XNavigableSet EMPTY_NAVIGABLE_SET =
        unmodifiable(new TreeSet<Object>());
    
    @SuppressWarnings("rawtypes")
    private static final XMap EMPTY_MAP =
        unmodifiable(new HashMap<Object, Object>());

    @SuppressWarnings("rawtypes")
    private static final XOrderedMap EMPTY_ORDERED_MAP =
        unmodifiable(new LinkedHashMap<Object, Object>());

    @SuppressWarnings("rawtypes")
    private static final XNavigableMap EMPTY_NAVIGABLE_MAP =
        unmodifiable(new TreeMap<Object, Object>());
    
    private static final boolean[] EMPTY_BOOLEAN_ARR = new boolean[0];
    
    private static final char[] EMPTY_CHAR_ARR = new char[0];
    
    private static final byte[] EMPTY_BYTE_ARR = new byte[0];
    
    private static final short[] EMPTY_SHORT_ARR = new short[0];
    
    private static final int[] EMPTY_INT_ARR = new int[0];
    
    private static final long[] EMPTY_LONG_ARR = new long[0];
    
    private static final float[] EMPTY_FLOAT_ARR = new float[0];
    
    private static final double[] EMPTY_DOUBLE_ARR = new double[0];
    
    private static final Package JAVA_UTIL_PACKAGE = java.util.Collection.class.getPackage();

    protected MACollections() throws UnsupportedOperationException {
        throw new UnsupportedOperationException();
    }
    
    @SuppressWarnings("unchecked")
    public static <T> Comparator<T> reverseOrder() {
        return (Comparator<T>)ReversedEmptyComparator.INSTANCE;
    }
    
    @SuppressWarnings("unchecked")
    public static <T> Comparator<T> reverseOrder(Comparator<T> comparator) {
        if (comparator instanceof ReversedFrozenComparatorWithHashCalculator<?>) {
            return ((ReversedFrozenComparatorWithHashCalculator<T>)comparator).raw;
        }
        if (comparator instanceof ReversedFrozenComparator<?>) {
            return ((ReversedFrozenComparator<T>)comparator).raw;
        }
        if (comparator instanceof ReversedComparatorWithHashCalculator<?>) {
            return ((ReversedComparatorWithHashCalculator<T>)comparator).raw;
        }
        if (comparator instanceof ReversedComparator<?>) {
            return ((ReversedComparator<T>)comparator).raw;
        }
        if (comparator instanceof ReversedEmptyComparator) {
            return null;
        }
        if (comparator instanceof FrozenComparator<?>) {
            return comparator instanceof HashCalculator<?> ?
                new ReversedFrozenComparatorWithHashCalculator<>((FrozenComparator<T>)comparator) :
                new ReversedFrozenComparator<>((FrozenComparator<T>)comparator);
        }
        if (comparator != null) {
            return comparator instanceof HashCalculator<?> ?
                new ReversedComparatorWithHashCalculator<>(comparator) :
                new ReversedComparator<>(comparator);
        }
        return (Comparator<T>)ReversedEmptyComparator.INSTANCE;
    }
    
    public static <T> FrozenComparator<T> reverseOrder(FrozenComparator<T> frozenComparator) {
        Arguments.mustNotBeNull("frozenComparator", frozenComparator);
        if (frozenComparator instanceof ReversedFrozenComparatorWithHashCalculator<?>) {
            return ((ReversedFrozenComparatorWithHashCalculator<T>)frozenComparator).raw;
        }
        if (frozenComparator instanceof ReversedFrozenComparator<?>) {
            return ((ReversedFrozenComparator<T>)frozenComparator).raw;
        }
        return frozenComparator instanceof HashCalculator<?> ?
            new ReversedFrozenComparatorWithHashCalculator<>(frozenComparator) :
            new ReversedFrozenComparator<>(frozenComparator);
    }
    
    @SuppressWarnings("unchecked")
    public static <E> XList<E> emptyList() {
        return EMPTY_LIST;
    }

    @SuppressWarnings("unchecked")
    public static <E> XSet<E> emptySet() {
        return EMPTY_SET;
    }

    @SuppressWarnings("unchecked")
    public static <E> XOrderedSet<E> emptyOrderedSet() {
        return EMPTY_ORDERED_SET;
    }

    @SuppressWarnings("unchecked")
    public static <E> XNavigableSet<E> emptyNavigableSet() {
        return EMPTY_NAVIGABLE_SET;
    }

    @SuppressWarnings("unchecked")
    public static <K, V> XMap<K, V> emptyMap() {
        return EMPTY_MAP;
    }

    @SuppressWarnings("unchecked")
    public static <K, V> XOrderedMap<K, V> emptyOrderedMap() {
        return EMPTY_ORDERED_MAP;
    }

    @SuppressWarnings("unchecked")
    public static <K, V> XNavigableMap<K, V> emptyNavigableMap() {
        return EMPTY_NAVIGABLE_MAP;
    }
    
    @SuppressWarnings("unchecked")
    @SafeVarargs
    public static <E> XList<E> wrap(E ... elements) {
        if (elements == null || elements.length == 0) {
            return EMPTY_LIST;
        }
        return new WrappedObjectArrayList<E>(elements);
    }
    
    @SuppressWarnings("unchecked")
    public static XList<Boolean> wrapBoolean(boolean ... elements) {
        if (elements == null || elements.length == 0) {
            return EMPTY_LIST;
        }
        return new WrappedBooleanArrayList(elements);
    }
    
    @SuppressWarnings("unchecked")
    public static XList<Character> wrapChar(char ... elements) {
        if (elements == null || elements.length == 0) {
            return EMPTY_LIST;
        }
        return new WrappedCharArrayList(elements);
    }
    
    @SuppressWarnings("unchecked")
    public static XList<Byte> wrapByte(byte ... elements) {
        if (elements == null || elements.length == 0) {
            return EMPTY_LIST;
        }
        return new WrappedByteArrayList(elements);
    }
    
    @SuppressWarnings("unchecked")
    public static XList<Short> wrapShort(short ... elements) {
        if (elements == null || elements.length == 0) {
            return EMPTY_LIST;
        }
        return new WrappedShortArrayList(elements);
    }
    
    @SuppressWarnings("unchecked")
    public static XList<Integer> wrapInt(int ... elements) {
        if (elements == null || elements.length == 0) {
            return EMPTY_LIST;
        }
        return new WrappedIntArrayList(elements);
    }
    
    @SuppressWarnings("unchecked")
    public static XList<Long> wrapLong(long ... elements) {
        if (elements == null || elements.length == 0) {
            return EMPTY_LIST;
        }
        return new WrappedLongArrayList(elements);
    }
    
    @SuppressWarnings("unchecked")
    public static XList<Float> wrapFloat(float ... elements) {
        if (elements == null || elements.length == 0) {
            return EMPTY_LIST;
        }
        return new WrappedFloatArrayList(elements);
    }
    
    @SuppressWarnings("unchecked")
    public static XList<Double> wrapDouble(double ... elements) {
        if (elements == null || elements.length == 0) {
            return EMPTY_LIST;
        }
        return new WrappedDoubleArrayList(elements);
    }
    
    @SuppressWarnings("rawtypes")
    public static XList fromAnyArray(Object arr) {
        Arguments.mustBeArray("arr.getClass()", Arguments.mustNotBeNull("arr", arr).getClass());
        Class<?> componentType = arr.getClass().getComponentType();
        if (componentType == boolean.class) {
            return wrapBoolean((boolean[])arr);
        }
        if (componentType == char.class) {
            return wrapChar((char[])arr);
        }
        if (componentType == byte.class) {
            return wrapByte((byte[])arr);
        }
        if (componentType == short.class) {
            return wrapShort((short[])arr);
        }
        if (componentType == int.class) {
            return wrapInt((int[])arr);
        }
        if (componentType == long.class) {
            return wrapLong((long[])arr);
        }
        if (componentType == float.class) {
            return wrapFloat((float[])arr);
        }
        if (componentType == double.class) {
            return wrapDouble((double[])arr);
        }
        return wrap((Object[])arr);
    }
    
    public static boolean[] toBooleanArray(Collection<Boolean> c) {
        if (c == null || c.isEmpty()) {
            return EMPTY_BOOLEAN_ARR;
        }
        if (c instanceof WrappedArrayList.SubListImpl<?>) {
            WrappedArrayList.SubListImpl<Boolean> sc = (WrappedArrayList.SubListImpl<Boolean>)c;
            if (sc.rootList instanceof WrappedBooleanArrayList) {
                boolean[] rootArr = ((WrappedBooleanArrayList)sc.rootList).arr;
                Arrays.copyOfRange(rootArr, sc.headHide, rootArr.length - sc.tailHide);
            }
        } else if (c instanceof WrappedBooleanArrayList) {
            return ((WrappedBooleanArrayList)c).arr.clone();
        }
        boolean[] arr = new boolean[c.size()];
        int index = 0;
        for (Boolean e : c) {
            arr[index++] = e != null ? e.booleanValue() : false;
        }
        return arr;
    }
    
    public static char[] toCharArray(Collection<Character> c) {
        if (c == null || c.isEmpty()) {
            return EMPTY_CHAR_ARR;
        }
        if (c instanceof WrappedArrayList.SubListImpl<?>) {
            WrappedArrayList.SubListImpl<Character> sc = (WrappedArrayList.SubListImpl<Character>)c;
            if (sc.rootList instanceof WrappedCharArrayList) {
                char[] rootArr = ((WrappedCharArrayList)sc.rootList).arr;
                Arrays.copyOfRange(rootArr, sc.headHide, rootArr.length - sc.tailHide);
            }
        } else if (c instanceof WrappedCharArrayList) {
            return ((WrappedCharArrayList)c).arr.clone();
        }
        char[] arr = new char[c.size()];
        int index = 0;
        for (Character e : c) {
            arr[index++] = e != null ? e.charValue() : '\0';
        }
        return arr;
    }
    
    public static byte[] toByteArray(Collection<Byte> c) {
        if (c == null || c.isEmpty()) {
            return EMPTY_BYTE_ARR;
        }
        if (c instanceof WrappedArrayList.SubListImpl<?>) {
            WrappedArrayList.SubListImpl<Byte> sc = (WrappedArrayList.SubListImpl<Byte>)c;
            if (sc.rootList instanceof WrappedByteArrayList) {
                byte[] rootArr = ((WrappedByteArrayList)sc.rootList).arr;
                Arrays.copyOfRange(rootArr, sc.headHide, rootArr.length - sc.tailHide);
            }
        } else if (c instanceof WrappedByteArrayList) {
            return ((WrappedByteArrayList)c).arr.clone();
        }
        byte[] arr = new byte[c.size()];
        int index = 0;
        for (Byte e : c) {
            arr[index++] = e != null ? e.byteValue() : (byte)0;
        }
        return arr;
    }
    
    public static short[] toShortArray(Collection<Short> c) {
        if (c == null || c.isEmpty()) {
            return EMPTY_SHORT_ARR;
        }
        if (c instanceof WrappedArrayList.SubListImpl<?>) {
            WrappedArrayList.SubListImpl<Short> sc = (WrappedArrayList.SubListImpl<Short>)c;
            if (sc.rootList instanceof WrappedShortArrayList) {
                short[] rootArr = ((WrappedShortArrayList)sc.rootList).arr;
                Arrays.copyOfRange(rootArr, sc.headHide, rootArr.length - sc.tailHide);
            }
        } else if (c instanceof WrappedShortArrayList) {
            return ((WrappedShortArrayList)c).arr.clone();
        }
        short[] arr = new short[c.size()];
        int index = 0;
        for (Short e : c) {
            arr[index++] = e != null ? e.shortValue() : (short)0;
        }
        return arr;
    }
    
    public static int[] toIntArray(Collection<Integer> c) {
        if (c == null || c.isEmpty()) {
            return EMPTY_INT_ARR;
        }
        if (c instanceof WrappedArrayList.SubListImpl<?>) {
            WrappedArrayList.SubListImpl<Integer> sc = (WrappedArrayList.SubListImpl<Integer>)c;
            if (sc.rootList instanceof WrappedIntArrayList) {
                int[] rootArr = ((WrappedIntArrayList)sc.rootList).arr;
                Arrays.copyOfRange(rootArr, sc.headHide, rootArr.length - sc.tailHide);
            }
        } else if (c instanceof WrappedIntArrayList) {
            return ((WrappedIntArrayList)c).arr.clone();
        }
        int[] arr = new int[c.size()];
        int index = 0;
        for (Integer e : c) {
            arr[index++] = e != null ? e.intValue() : 0;
        }
        return arr;
    }
    
    public static long[] toLongArray(Collection<Long> c) {
        if (c == null || c.isEmpty()) {
            return EMPTY_LONG_ARR;
        }
        if (c instanceof WrappedArrayList.SubListImpl<?>) {
            WrappedArrayList.SubListImpl<Long> sc = (WrappedArrayList.SubListImpl<Long>)c;
            if (sc.rootList instanceof WrappedLongArrayList) {
                long[] rootArr = ((WrappedLongArrayList)sc.rootList).arr;
                Arrays.copyOfRange(rootArr, sc.headHide, rootArr.length - sc.tailHide);
            }
        } else if (c instanceof WrappedLongArrayList) {
            return ((WrappedLongArrayList)c).arr.clone();
        }
        long[] arr = new long[c.size()];
        int index = 0;
        for (Long e : c) {
            arr[index++] = e != null ? e.longValue() : 0L;
        }
        return arr;
    }
    
    public static float[] toFloatArray(Collection<Float> c) {
        if (c == null || c.isEmpty()) {
            return EMPTY_FLOAT_ARR;
        }
        if (c instanceof WrappedArrayList.SubListImpl<?>) {
            WrappedArrayList.SubListImpl<Float> sc = (WrappedArrayList.SubListImpl<Float>)c;
            if (sc.rootList instanceof WrappedFloatArrayList) {
                float[] rootArr = ((WrappedFloatArrayList)sc.rootList).arr;
                Arrays.copyOfRange(rootArr, sc.headHide, rootArr.length - sc.tailHide);
            }
        } else if (c instanceof WrappedFloatArrayList) {
            return ((WrappedFloatArrayList)c).arr.clone();
        }
        float[] arr = new float[c.size()];
        int index = 0;
        for (Float e : c) {
            arr[index++] = e != null ? e.floatValue() : 0F;
        }
        return arr;
    }
    
    public static double[] toDoubleArray(Collection<Double> c) {
        if (c == null || c.isEmpty()) {
            return EMPTY_DOUBLE_ARR;
        }
        if (c instanceof WrappedArrayList.SubListImpl<?>) {
            WrappedArrayList.SubListImpl<Double> sc = (WrappedArrayList.SubListImpl<Double>)c;
            if (sc.rootList instanceof WrappedDoubleArrayList) {
                double[] rootArr = ((WrappedDoubleArrayList)sc.rootList).arr;
                Arrays.copyOfRange(rootArr, sc.headHide, rootArr.length - sc.tailHide);
            }
        } else if (c instanceof WrappedDoubleArrayList) {
            return ((WrappedDoubleArrayList)c).arr.clone();
        }
        double[] arr = new double[c.size()];
        int index = 0;
        for (Double e : c) {
            arr[index++] = e != null ? e.doubleValue() : 0D;
        }
        return arr;
    }
    
    private static class ReversedEmptyComparator implements Comparator<Comparable<Object>>, Serializable {

        private static final long serialVersionUID = -5945419130875319732L;
        
        static final ReversedEmptyComparator INSTANCE = new ReversedEmptyComparator();
        
        private ReversedEmptyComparator() {
            
        }
    
        public int compare(Comparable<Object> c1, Comparable<Object> c2) {
            return c2.compareTo(c1);
        }
    
        //Guarantee Singleton
        private Object readResolve() throws ObjectStreamException { return INSTANCE; }
    }
    
    private static final class ReversedComparator<T> implements Comparator<T>, Serializable {
        
        private static final long serialVersionUID = 5100467521691035299L;
        
        Comparator<T> raw;
        
        ReversedComparator(Comparator<T> raw) {
            this.raw = raw;
        }

        @Override
        public int compare(T o1, T o2) {
            return this.raw.compare(o2, o1);
        }

        @Override
        public int hashCode() {
            return this.raw.hashCode() ^ Integer.MIN_VALUE;
        }

        @SuppressWarnings("unchecked")
        @Override
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (!(obj instanceof ReversedComparator<?>)) {
                return false;
            }
            ReversedComparator<T> other = (ReversedComparator<T>)obj;
            return this.raw.equals(other.raw);
        }
    }
    
    private static final class ReversedComparatorWithHashCalculator<T> implements Comparator<T>, HashCalculator<T>, Serializable {

        private static final long serialVersionUID = -546457404522842989L;
        
        Comparator<T> raw;
        
        ReversedComparatorWithHashCalculator(Comparator<T> raw) {
            this.raw = raw;
        }

        @Override
        public int compare(T o1, T o2) {
            return this.raw.compare(o2, o1);
        }
        
        @SuppressWarnings("unchecked")
        @Override
        public int hashCode(T obj) {
            return ((HashCalculator<T>)this.raw).hashCode(obj);
        }

        @Override
        public int hashCode() {
            return this.raw.hashCode() ^ Integer.MIN_VALUE;
        }

        @SuppressWarnings("unchecked")
        @Override
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (!(obj instanceof ReversedComparatorWithHashCalculator<?>)) {
                return false;
            }
            ReversedComparatorWithHashCalculator<T> other = (ReversedComparatorWithHashCalculator<T>)obj;
            return this.raw.equals(other.raw);
        }
    }
    
    private static final class ReversedFrozenComparator<T> implements FrozenComparator<T>, Serializable {
        
        private static final long serialVersionUID = 2661914708006774674L;
        
        FrozenComparator<T> raw;
        
        ReversedFrozenComparator(FrozenComparator<T> raw) {
            this.raw = raw;
        }

        @Override
        public int compare(T o1, T o2) {
            return this.raw.compare(o2, o1);
        }

        @Override
        public void freeze(T obj, FrozenContext<T> ctx) {
            this.raw.freeze(obj, ctx);
        }

        @Override
        public void unfreeze(T obj, FrozenContext<T> ctx) {
            this.raw.unfreeze(obj, ctx);
        }

        @Override
        public int hashCode() {
            return this.raw.hashCode() ^ Integer.MIN_VALUE;
        }

        @SuppressWarnings("unchecked")
        @Override
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (!(obj instanceof ReversedFrozenComparator<?>)) {
                return false;
            }
            ReversedFrozenComparator<T> other = (ReversedFrozenComparator<T>)obj;
            return this.raw.equals(other.raw);
        }
    }
    
    private static final class ReversedFrozenComparatorWithHashCalculator<T> implements FrozenComparator<T>, HashCalculator<T>, Serializable {
        
        private static final long serialVersionUID = -4172462951447714010L;
        
        FrozenComparator<T> raw;
        
        ReversedFrozenComparatorWithHashCalculator(FrozenComparator<T> raw) {
            this.raw = raw;
        }

        @Override
        public int compare(T o1, T o2) {
            return this.raw.compare(o2, o1);
        }

        @SuppressWarnings("unchecked")
        @Override
        public int hashCode(T obj) {
            return ((HashCalculator<T>)this.raw).hashCode(obj);
        }

        @Override
        public void freeze(T obj, FrozenContext<T> ctx) {
            this.raw.freeze(obj, ctx);
        }

        @Override
        public void unfreeze(T obj, FrozenContext<T> ctx) {
            this.raw.unfreeze(obj, ctx);
        }

        @Override
        public int hashCode() {
            return this.raw.hashCode() ^ Integer.MIN_VALUE;
        }

        @SuppressWarnings("unchecked")
        @Override
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (!(obj instanceof ReversedFrozenComparatorWithHashCalculator<?>)) {
                return false;
            }
            ReversedFrozenComparatorWithHashCalculator<T> other = (ReversedFrozenComparatorWithHashCalculator<T>)obj;
            return this.raw.equals(other.raw);
        }
    }
    
    private abstract static class WrappedArrayList<E> implements XList<E> {
        
        protected WrappedArrayList() {
            
        }
        
        protected abstract int indexOf(
                int headHide, int tailHide, Object o);

        protected abstract int lastIndexOf(
                int headHide, int tailHide, Object o);

        @Override
        public boolean isReadWriteLockSupported() {
            return true;
        }

        @Override
        public UnifiedComparator<? super E> unifiedComparator() {
            return UnifiedComparator.empty();
        }

        @Override
        public boolean contains(Object o) {
            return this.indexOf(o) != -1;
        }

        @Override
        public boolean containsAll(Collection<?> c) {
            for (Object o : c) {
                if (this.indexOf(o) == -1) {
                    return false;
                }
            }
            return true;
        }

        @Override
        public int indexOf(Object o) {
            return this.indexOf(0, 0, o);
        }

        @Override
        public int lastIndexOf(Object o) {
            return this.lastIndexOf(0, 0, o);
        }
        
        @Override
        public XListView<E> subList(int fromIndex, int toIndex) {
            return new SubListImpl<E>(this, fromIndex, toIndex);
        }

        @Override
        public XListIterator<E> iterator() {
            return this.new IteratorImpl(0);
        }

        @Override
        public XListIterator<E> listIterator() {
            return this.new IteratorImpl(0);
        }

        @Override
        public XListIterator<E> listIterator(int index) {
            return this.new IteratorImpl(index);
        }

        @Override
        public Object[] toArray() {
            return BasicAlgorithms.collectionToArray(this);
        }

        @Override
        public <T> T[] toArray(T[] a) {
            return BasicAlgorithms.collectionToArray(this, a);
        }
        
        @Override
        public int hashCode() {
            return BasicAlgorithms.listHashCode(this);
        }

        @Override
        public boolean equals(Object obj) {
            return BasicAlgorithms.listEquals(this, obj);
        }

        @Override
        public String toString() {
            return BasicAlgorithms.collectionToString(this);
        }

        @Deprecated
        @Override
        public final boolean add(E e) {
            throw new UnsupportedOperationException(
                    unmodifable("boolean java.util.List<E>.add(E)")
            );
        }

        @Deprecated
        @Override
        public final void add(int index, E element) {
            throw new UnsupportedOperationException(
                    unmodifable("boolean java.util.List<E>.add(int, E)")
            );
        }

        @Deprecated
        @Override
        public final boolean addAll(Collection<? extends E> c) {
            throw new UnsupportedOperationException(
                    unmodifable("boolean java.util.List<E>.addAll(java.util.Collection<? extends E>)")
            );
        }

        @Deprecated
        @Override
        public final boolean addAll(int index, Collection<? extends E> c) {
            throw new UnsupportedOperationException(
                    unmodifable("boolean java.util.List<E>.addAll(int, java.util.Collection<? extends E>)")
            );
        }

        @Deprecated
        @Override
        public final void clear() {
            throw new UnsupportedOperationException(
                    unmodifable("void java.util.List<E>.clear()")
            );
        }

        @Deprecated
        @Override
        public final boolean remove(Object o) {
            throw new UnsupportedOperationException(
                    unmodifable("boolean java.util.List<E>.remove(java.lang.Object)")
            );
        }

        @Deprecated
        @Override
        public final E remove(int index) {
            throw new UnsupportedOperationException(
                    unmodifable("E java.util.List<E>.remove(int)")
            );
        }

        @Deprecated
        @Override
        public final boolean removeAll(Collection<?> c) {
            throw new UnsupportedOperationException(
                    unmodifable("boolean java.util.List<E>.removeAll(int, java.util.Collection<? extends E>)")
            );
        }

        @Deprecated
        @Override
        public final boolean retainAll(Collection<?> c) {
            throw new UnsupportedOperationException(
                    unmodifable("boolean java.util.List<E>.retainAll(int, java.util.Collection<? extends E>)")
            );
        }

        @Deprecated
        @Override
        public final E set(int index, E element) {
            throw new UnsupportedOperationException(
                    unmodifable("E java.util.List<E>.set(int, E)")
            );
        }
        
        @Deprecated
        @Override
        public void addValidator(Validator<E> validator) {
            throw new UnsupportedOperationException(
                    unmodifable("void org.babyfish.collection.XList<E>.addValidator(org.babyfish.validator.Validator<E>)")
            );
        }

        @Deprecated
        @Override
        public void removeValidator(Validator<E> validator) {
            throw new UnsupportedOperationException(
                    unmodifable("void org.babyfish.collection.XList<E>.removeValidator(org.babyfish.validator.Validator<E>)")
            );
        }

        @Override
        public void validate(E e) {
        }

        @Override
        public BidiType bidiType() {
            return null;
        }

        private static class SubListImpl<E> extends WrappedArrayList<E> implements XListView<E> {

            WrappedArrayList<E> rootList;
            
            int headHide;
            
            int tailHide;
            
            ListViewInfos.SubList viewInfo;
            
            SubListImpl(WrappedArrayList<E> parentList, final int fromIndex, final int toIndex) {
                Arguments.indexMustBeGreaterThanOrEqualToValue("fromIndex", fromIndex, 0);
                Arguments.indexMustBeLessThanOrEqualToValue("toIndex", toIndex, parentList.size());
                Arguments.indexMustBeLessThanOrEqualToOther("fromIndex", fromIndex, "toIndex", toIndex);
                WrappedArrayList<E> rootList;
                int headHide;
                int tailHide;
                if (parentList instanceof SubListImpl<?>) {
                    SubListImpl<E> parentSL = (SubListImpl<E>)parentList;
                    rootList = parentSL.rootList;
                    headHide = parentSL.headHide + fromIndex;
                    tailHide = parentSL.tailHide + parentSL.size() - toIndex;
                } else {
                    rootList = parentList;
                    headHide = fromIndex;
                    tailHide = parentList.size() - toIndex;
                }
                this.rootList = rootList;
                this.headHide = headHide;
                this.tailHide = tailHide;
                this.viewInfo = ListViewInfos.subList(fromIndex, toIndex);
            }

            @Override
            public ListViewInfos.SubList viewInfo() {
                return this.viewInfo;
            }

            @Deprecated
            @Override
            protected final int indexOf(
                    int headHide, int tailHide, Object o) {
                throw new UnsupportedOperationException();
            }

            @Deprecated
            @Override
            protected final int lastIndexOf(int headHide, int tailHide, Object o) {
                throw new UnsupportedOperationException();
            }

            @Override
            public int size() {
                return this.rootList.size() - this.headHide - this.tailHide;
            }

            @Override
            public boolean isEmpty() {
                return this.rootList.size() == this.headHide + this.tailHide;
            }

            @Override
            public E get(int index) {
                return this.rootList.get(this.headHide + index);
            }
        }
        
        private class IteratorImpl implements XListIterator<E> {
            
            int index;
            
            ListViewInfos.ListIterator viewInfo;
            
            IteratorImpl(final int index) {
                if (index < 0 || index > WrappedArrayList.this.size()) {
                    throw new IndexOutOfBoundsException();
                }
                this.index = index;
                this.viewInfo = ListViewInfos.listIterator(index);
            }

            @Override
            public boolean hasNext() {
                return this.index < WrappedArrayList.this.size();
            }

            @Override
            public boolean hasPrevious() {
                return this.index > 0;
            }

            @Override
            public E next() {
                if (this.index >= WrappedArrayList.this.size()) {
                    throw new NoSuchElementException();
                }
                return WrappedArrayList.this.get(this.index++);
            }

            @Override
            public int nextIndex() {
                return this.index;
            }

            @Override
            public E previous() {
                if (this.index <= 0) {
                    throw new NoSuchElementException();
                }
                return WrappedArrayList.this.get(--this.index);
            }

            @Override
            public int previousIndex() {
                return this.index - 1;
            }

            @Override
            public boolean isReadWriteLockSupported() {
                return true;
            }

            @Override
            public UnifiedComparator<? super E> unifiedComparator() {
                return UnifiedComparator.empty();
            }

            @Override
            public ListViewInfos.ListIterator viewInfo() {
                return this.viewInfo;
            }

            @Deprecated
            @Override
            public void add(E e) {
                throw new UnsupportedOperationException();
            }

            @Deprecated
            @Override
            public void remove() {
                throw new UnsupportedOperationException();
            }

            @Deprecated
            @Override
            public void set(E e) {
                throw new UnsupportedOperationException();
            }
            
        }
    }
    
    private static class WrappedObjectArrayList<E> extends WrappedArrayList<E> {

        private E[] arr;
        
        public WrappedObjectArrayList(E[] arr) {
            this.arr = arr;
        }
        
        @Override
        protected int indexOf(
                int headHide, int tailHide, Object o) {
            E[] arr = this.arr;
            int fenceIndex = arr.length - tailHide;
            if (o == null) {
                for (int i = headHide; i < fenceIndex; i++) {
                    if (arr[i] == null) {
                        return i - headHide;
                    }
                }
            } else {
                for (int i = headHide; i < fenceIndex; i++) {
                    E e = arr[i];
                    if (o.equals(e)) {
                        return i - headHide;
                    }
                }
            }
            return -1;
        }

        @Override
        protected int lastIndexOf(
                int headHide, int tailHide, Object o) {
            E[] arr = this.arr;
            if (o == null) {
                for (int i = arr.length - tailHide - 1; i >= headHide; i--) {
                    if (arr[i] == null) {
                        return i - headHide;
                    }
                }
            } else {
                for (int i = arr.length - tailHide - 1; i >= headHide; i--) {
                    E e = arr[i];
                    if (o.equals(e)) {
                        return i - headHide;
                    }
                }
            }
            return -1;
        }

        @Override
        public int size() {
            return this.arr.length;
        }

        @Override
        public boolean isEmpty() {
            return this.arr.length == 0;
        }

        @Override
        public E get(int index) {
            Arguments.indexMustBetweenValue("index", index, 0, true, this.arr.length, false);
            return this.arr[index];
        }
        
    }
    
    private static class WrappedBooleanArrayList extends WrappedArrayList<Boolean> {

        boolean[] arr;
        
        public WrappedBooleanArrayList(boolean[] arr) {
            this.arr = arr;
        }
        
        @Override
        protected int indexOf(
                int headHide, int tailHide, Object o) {
            if (!(o instanceof Boolean)) {
                return -1;
            }
            boolean[] arr = this.arr;
            int fenceIndex = arr.length - tailHide;
            Boolean boxedO = (Boolean)o;
            boolean unboxedO = boxedO;
            for (int i = headHide; i < fenceIndex; i++) {
                boolean e = arr[i];
                if (unboxedO == e) {
                    return i - headHide;
                }
            }
            return -1;
        }

        @Override
        protected int lastIndexOf(
                int headHide, int tailHide, Object o) {
            if (!(o instanceof Boolean)) {
                return -1;
            }
            boolean[] arr = this.arr;
            Boolean boxedO = (Boolean)o;
            boolean unboxedO = boxedO;
            for (int i = arr.length - tailHide - 1; i >= headHide; i--) {
                boolean e = arr[i];
                if (unboxedO == e) {
                    return i - headHide;
                }
            }
            return -1;
        }

        @Override
        public int size() {
            return this.arr.length;
        }

        @Override
        public boolean isEmpty() {
            return this.arr.length == 0;
        }

        @Override
        public Boolean get(int index) {
            Arguments.indexMustBetweenValue("index", index, 0, true, this.arr.length, false);
            return this.arr[index];
        }
        
    }
    
    private static class WrappedCharArrayList extends WrappedArrayList<Character> {

        char[] arr;
        
        public WrappedCharArrayList(char[] arr) {
            this.arr = arr;
        }
        
        @Override
        protected int indexOf(
                int headHide, int tailHide, Object o) {
            if (!(o instanceof Character)) {
                return -1;
            }
            char[] arr = this.arr;
            int fenceIndex = arr.length - tailHide;
            Character boxedO = (Character)o;
            char unboxedO = boxedO;
            for (int i = headHide; i < fenceIndex; i++) {
                char e = arr[i];
                if (unboxedO == e) {
                    return i - headHide;
                }
            }
            return -1;
        }

        @Override
        protected int lastIndexOf(
                int headHide, int tailHide, Object o) {
            if (!(o instanceof Character)) {
                return -1;
            }
            char[] arr = this.arr;
            Character boxedO = (Character)o;
            char unboxedO = boxedO;
            for (int i = arr.length - tailHide - 1; i >= headHide; i--) {
                char e = arr[i];
                if (unboxedO == e) {
                    return i - headHide;
                }
            }
            return -1;
        }

        @Override
        public int size() {
            return this.arr.length;
        }

        @Override
        public boolean isEmpty() {
            return this.arr.length == 0;
        }

        @Override
        public Character get(int index) {
            Arguments.indexMustBetweenValue("index", index, 0, true, this.arr.length, false);
            return this.arr[index];
        }
    }
    
    private static class WrappedByteArrayList extends WrappedArrayList<Byte> {

        byte[] arr;
        
        public WrappedByteArrayList(byte[] arr) {
            this.arr = arr;
        }
        
        @Override
        protected int indexOf(
                int headHide, int tailHide, Object o) {
            if (!(o instanceof Byte)) {
                return -1;
            }
            byte[] arr = this.arr;
            int fenceIndex = arr.length - tailHide;
            Byte boxedO = (Byte)o;
            byte unboxedO = boxedO;
            for (int i = headHide; i < fenceIndex; i++) {
                byte e = arr[i];
                if (unboxedO == e) {
                    return i - headHide;
                }
            }
            return -1;
        }

        @Override
        protected int lastIndexOf(
                int headHide, int tailHide, Object o) {
            if (!(o instanceof Byte)) {
                return -1;
            }
            byte[] arr = this.arr;
            Byte boxedO = (Byte)o;
            byte unboxedO = boxedO;
            for (int i = arr.length - tailHide - 1; i >= headHide; i--) {
                byte e = arr[i];
                if (unboxedO == e) {
                    return i - headHide;
                }
            }
            return -1;
        }

        @Override
        public int size() {
            return this.arr.length;
        }

        @Override
        public boolean isEmpty() {
            return this.arr.length == 0;
        }

        @Override
        public Byte get(int index) {
            Arguments.indexMustBetweenValue("index", index, 0, true, this.arr.length, false);
            return this.arr[index];
        }
    }
    
    private static class WrappedShortArrayList extends WrappedArrayList<Short> {

        short[] arr;
        
        public WrappedShortArrayList(short[] arr) {
            this.arr = arr;
        }
        
        @Override
        protected int indexOf(
                int headHide, int tailHide, Object o) {
            if (!(o instanceof Short)) {
                return -1;
            }
            short[] arr = this.arr;
            int fenceIndex = arr.length - tailHide;
            Short boxedO = (Short)o;
            short unboxedO = boxedO;
            for (int i = headHide; i < fenceIndex; i++) {
                short e = arr[i];
                if (unboxedO == e) {
                    return i - headHide;
                }
            }
            return -1;
        }

        @Override
        protected int lastIndexOf(
                int headHide, int tailHide, Object o) {
            if (!(o instanceof Short)) {
                return -1;
            }
            short[] arr = this.arr;
            Short boxedO = (Short)o;
            short unboxedO = boxedO;
            for (int i = arr.length - tailHide - 1; i >= headHide; i--) {
                short e = arr[i];
                if (unboxedO == e) {
                    return i - headHide;
                }
            }
            return -1;
        }

        @Override
        public int size() {
            return this.arr.length;
        }

        @Override
        public boolean isEmpty() {
            return this.arr.length == 0;
        }

        @Override
        public Short get(int index) {
            Arguments.indexMustBetweenValue("index", index, 0, true, this.arr.length, false);
            return this.arr[index];
        }
    }
    
    private static class WrappedIntArrayList extends WrappedArrayList<Integer> {

        int[] arr;
        
        public WrappedIntArrayList(int[] arr) {
            this.arr = arr;
        }
        
        @Override
        protected int indexOf(
                int headHide, int tailHide, Object o) {
            if (!(o instanceof Integer)) {
                return -1;
            }
            int[] arr = this.arr;
            int fenceIndex = arr.length - tailHide;
            Integer boxedO = (Integer)o;
            int unboxedO = boxedO;
            for (int i = headHide; i < fenceIndex; i++) {
                int e = arr[i];
                if (unboxedO == e) {
                    return i - headHide;
                }
            }
            return -1;
        }

        @Override
        protected int lastIndexOf(
                int headHide, int tailHide, Object o) {
            if (!(o instanceof Integer)) {
                return -1;
            }
            int[] arr = this.arr;
            Integer boxedO = (Integer)o;
            int unboxedO = boxedO;
            for (int i = arr.length - tailHide - 1; i >= headHide; i--) {
                int e = arr[i];
                if (unboxedO == e) {
                    return i - headHide;
                }
            }
            return -1;
        }

        @Override
        public int size() {
            return this.arr.length;
        }

        @Override
        public boolean isEmpty() {
            return this.arr.length == 0;
        }

        @Override
        public Integer get(int index) {
            Arguments.indexMustBetweenValue("index", index, 0, true, this.arr.length, false);
            return this.arr[index];
        }
        
    }
    
    private static class WrappedLongArrayList extends WrappedArrayList<Long> {

        long[] arr;
        
        public WrappedLongArrayList(long[] arr) {
            this.arr = arr;
        }
        
        @Override
        protected int indexOf(
                int headHide, int tailHide, Object o) {
            if (!(o instanceof Long)) {
                return -1;
            }
            long[] arr = this.arr;
            int fenceIndex = arr.length - tailHide;
            Long boxedO = (Long)o;
            long unboxedO = boxedO;
            for (int i = headHide; i < fenceIndex; i++) {
                long e = arr[i];
                if (unboxedO == e) {
                    return i - headHide;
                }
            }
            return -1;
        }

        @Override
        protected int lastIndexOf(
                int headHide, int tailHide, Object o) {
            if (!(o instanceof Long)) {
                return -1;
            }
            long[] arr = this.arr;
            Long boxedO = (Long)o;
            long unboxedO = boxedO;
            for (int i = arr.length - tailHide - 1; i >= headHide; i--) {
                long e = arr[i];
                if (unboxedO == e) {
                    return i - headHide;
                }
            }
            return -1;
        }

        @Override
        public int size() {
            return this.arr.length;
        }

        @Override
        public boolean isEmpty() {
            return this.arr.length == 0;
        }

        @Override
        public Long get(int index) {
            Arguments.indexMustBetweenValue("index", index, 0, true, this.arr.length, false);
            return this.arr[index];
        }
        
    }
    
    private static class WrappedFloatArrayList extends WrappedArrayList<Float> {

        float[] arr;
        
        public WrappedFloatArrayList(float[] arr) {
            this.arr = arr;
        }
        
        @Override
        protected int indexOf(
                int headHide, int tailHide, Object o) {
            if (!(o instanceof Float)) {
                return -1;
            }
            float[] arr = this.arr;
            int fenceIndex = arr.length - tailHide;
            Float boxedO = (Float)o;
            float unboxedO = boxedO;
            for (int i = headHide; i < fenceIndex; i++) {
                float e = arr[i];
                if (unboxedO == e) {
                    return i - headHide;
                }
            }
            return -1;
        }

        @Override
        protected int lastIndexOf(
                int headHide, int tailHide, Object o) {
            if (!(o instanceof Float)) {
                return -1;
            }
            float[] arr = this.arr;
            Float boxedO = (Float)o;
            float unboxedO = boxedO;
            for (int i = arr.length - tailHide - 1; i >= headHide; i--) {
                float e = arr[i];
                if (unboxedO == e) {
                    return i - headHide;
                }
            }
            return -1;
        }

        @Override
        public int size() {
            return this.arr.length;
        }

        @Override
        public boolean isEmpty() {
            return this.arr.length == 0;
        }

        @Override
        public Float get(int index) {
            Arguments.indexMustBetweenValue("index", index, 0, true, this.arr.length, false);
            return this.arr[index];
        }
        
    }
    
    private static class WrappedDoubleArrayList extends WrappedArrayList<Double> {

        double[] arr;
        
        public WrappedDoubleArrayList(double[] arr) {
            this.arr = arr;
        }
        
        @Override
        protected int indexOf(
                int headHide, int tailHide, Object o) {
            if (!(o instanceof Double)) {
                return -1;
            }
            double[] arr = this.arr;
            int fenceIndex = arr.length - tailHide;
            Double boxedO = (Double)o;
            double unboxedO = boxedO;
            for (int i = headHide; i < fenceIndex; i++) {
                double e = arr[i];
                if (unboxedO == e) {
                    return i - headHide;
                }
            }
            return -1;
        }

        @Override
        protected int lastIndexOf(int headHide, int tailHide, Object o) {
            if (!(o instanceof Double)) {
                return -1;
            }
            double[] arr = this.arr;
            Double boxedO = (Double)o;
            double unboxedO = boxedO;
            for (int i = arr.length - tailHide - 1; i >= headHide; i--) {
                double e = arr[i];
                if (unboxedO == e) {
                    return i - headHide;
                }
            }
            return -1;
        }

        @Override
        public int size() {
            return this.arr.length;
        }

        @Override
        public boolean isEmpty() {
            return this.arr.length == 0;
        }

        @Override
        public Double get(int index) {
            Arguments.indexMustBetweenValue("index", index, 0, true, this.arr.length, false);
            return this.arr[index];
        }
        
    }
    
    /*
     * Standard
     */
    
    private static <K, V> Map<K, V> standard(Map<K, V> m) {
        if (m instanceof Serializable) {
            if (m instanceof SortedMap<?, ?>) {
                if (m instanceof NavigableMap<?, ?>) {
                    return new SerializableStandardNavigableMapImpl<K, V>((NavigableMap<K, V>)m);
                }
                return new SerializableStandardSortedMapImpl<K, V>((SortedMap<K, V>)m);
            }
            return new SerializableStandardMapImpl<K, V>(m);
        }
        if (m instanceof SortedMap<?, ?>) {
            if (m instanceof NavigableMap<?, ?>) {
                return new StandardNavigableMapImpl<K, V>((NavigableMap<K, V>)m);
            }
            return new StandardSortedMapImpl<K, V>((SortedMap<K, V>)m);
        }
        return new StandardMapImpl<K, V>(m);
    }
    
    private static <K, V> SortedMap<K, V> standard(SortedMap<K, V> m) {
        if (m instanceof Serializable) {
            if (m instanceof NavigableMap<?, ?>) {
                return new SerializableStandardNavigableMapImpl<K, V>((NavigableMap<K, V>)m);
            }
            return new SerializableStandardSortedMapImpl<K, V>(m);
        }
        if (m instanceof NavigableMap<?, ?>) {
            return new StandardNavigableMapImpl<K, V>((NavigableMap<K, V>)m);
        }
        return new StandardSortedMapImpl<K, V>(m);
    }
    
    private static <K, V> NavigableMap<K, V> standard(NavigableMap<K, V> m) {
        if (m instanceof Serializable) {
            return new SerializableStandardNavigableMapImpl<K, V>(m);
        }
        return new StandardNavigableMapImpl<K, V>(m);
    }

    private interface StandardMap<K, V> extends Map<K, V>, LockDescriptor {

        @Override
        EntrySet<K, V> entrySet();
        
        interface EntrySet<K, V> extends Set<Map.Entry<K, V>> {

            @Override
            EntryIterator<K, V> iterator();

            interface EntryIterator<K, V> extends Iterator<Map.Entry<K, V>> {
                
                @Override
                Map.Entry<K, V> next();

            }
        }
    }
    
    private interface StandardSortedMap<K, V> extends StandardMap<K, V>, SortedMap<K, V> {
        
        @Override
        StandardSortedMap<K, V> headMap(K toKey);
        
        @Override
        StandardSortedMap<K, V> tailMap(K fromKey);
        
        @Override
        StandardSortedMap<K, V> subMap(K fromKey, K toKey);
    }
    
    private interface StandardNavigableMap<K, V> extends StandardSortedMap<K, V>, NavigableMap<K, V> {
        
        @Override
        StandardNavigableMap<K, V> descendingMap();
        
        @Override
        StandardNavigableMap<K, V> headMap(K toKey);
        
        @Override
        StandardNavigableMap<K, V> tailMap(K fromKey);
        
        @Override
        StandardNavigableMap<K, V> subMap(K fromKey, K toKey);
        
        @Override
        StandardNavigableMap<K, V> headMap(K toKey, boolean inclusive);
        
        @Override
        StandardNavigableMap<K, V> tailMap(K fromKey, boolean inclusive);
        
        @Override
        StandardNavigableMap<K, V> subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive);
        
    }
    
    private static class StandardMapImpl<K, V> implements StandardMap<K, V> {
        
        Map<K, V> m;
        
        StandardMapImpl(Map<K, V> m) {
            this.m = Arguments.mustNotBeInstanceOfAnyOfValue("m", m, StandardMap.class, XMap.class);
        }

        @Override
        public EntrySet<K, V> entrySet() {
            return new EntrySetImpl<K, V>(this);
        }

        @Override
        public int size() {
            return this.m.size();
        }

        @Override
        public boolean isEmpty() {
            return this.m.isEmpty();
        }

        @Override
        public boolean containsKey(Object key) {
            return this.m.containsKey(key);
        }

        @Override
        public boolean containsValue(Object value) {
            return this.m.containsValue(value);
        }

        @Override
        public V get(Object key) {
            return this.m.get(key);
        }

        @Override
        public V put(K key, V value) {
            return this.m.put(key, value);
        }

        @Override
        public V remove(Object key) {
            return this.m.remove(key);
        }

        @Override
        public void putAll(Map<? extends K, ? extends V> m) {
            this.m.putAll(m);
        }

        @Override
        public void clear() {
            this.m.clear();
        }

        @Override
        public Set<K> keySet() {
            return this.m.keySet();
        }

        @Override
        public Collection<V> values() {
            return this.m.values();
        }

        @Override
        public boolean equals(Object o) {
            return this.m.equals(o);
        }

        @Override
        public int hashCode() {
            return this.m.hashCode();
        }
        
        @Override
        public String toString() {
            return this.m.toString();
        }
        
        @Override
        public boolean isReadWriteLockSupported() {
            return MACollections.isReadWriteLockSupported(this.m);
        }

        private static class EntrySetImpl<K, V> implements EntrySet<K, V> {
            
            private Set<Map.Entry<K, V>> set;
            
            EntrySetImpl(StandardMapImpl<K, V> owner) {
                this.set = owner.m.entrySet();
            }

            @Override
            public EntryIterator<K, V> iterator() {
                return new EntryIteratorImpl<K, V>(this);
            }
            
            @Deprecated
            @Override
            public boolean add(Map.Entry<K, V> e) {
                throw new UnsupportedOperationException();
            }

            @Deprecated
            @Override
            public final boolean addAll(Collection<? extends Map.Entry<K, V>> c) {
                throw new UnsupportedOperationException();
            }

            @Override
            public int size() {
                return this.set.size();
            }

            @Override
            public boolean isEmpty() {
                return this.set.isEmpty();
            }

            @Override
            public boolean contains(Object o) {
                return this.set.contains(o);
            }

            @Override
            public Object[] toArray() {
                return this.set.toArray();
            }

            @Override
            public <T> T[] toArray(T[] a) {
                return this.set.toArray(a);
            }

            @Override
            public boolean remove(Object o) {
                return this.set.remove(o);
            }

            @Override
            public boolean containsAll(Collection<?> c) {
                return this.set.containsAll(c);
            }

            @Override
            public boolean retainAll(Collection<?> c) {
                return this.set.retainAll(c);
            }

            @Override
            public boolean removeAll(Collection<?> c) {
                return this.set.removeAll(c);
            }

            @Override
            public void clear() {
                this.set.clear();
            }

            @Override
            public boolean equals(Object o) {
                return this.set.equals(o);
            }

            @Override
            public int hashCode() {
                return this.set.hashCode();
            }
            
            @Override
            public String toString() {
                return this.set.toString();
            }
            
            private static class EntryIteratorImpl<K, V> implements EntryIterator<K, V> {
                
                private Iterator<Map.Entry<K, V>> itr;
                
                EntryIteratorImpl(EntrySetImpl<K, V> owner) {
                    this.itr = owner.set.iterator();
                }
                
                @Override
                public Map.Entry<K, V> next() {
                    return this.itr.next();
                }

                @Override
                public boolean hasNext() {
                    return this.itr.hasNext();
                }

                @Override
                public void remove() {
                    this.itr.remove();
                }   
            }
        }
    }
    
    private static class StandardSortedMapImpl<K, V> extends StandardMapImpl<K, V> implements StandardSortedMap<K, V> {

        StandardSortedMapImpl(SortedMap<K, V> m) {
            super(m);
        }

        @Override
        public StandardSortedMap<K, V> headMap(K toKey) {
            return new StandardSortedMapImpl<K, V>(((SortedMap<K, V>)this.m).headMap(toKey));
        }

        @Override
        public StandardSortedMap<K, V> tailMap(K fromKey) {
            return new StandardSortedMapImpl<K, V>(((SortedMap<K, V>)this.m).tailMap(fromKey));
        }

        @Override
        public Comparator<? super K> comparator() {
            return ((SortedMap<K, V>)this.m).comparator();
        }

        @Override
        public StandardSortedMap<K, V> subMap(K fromKey, K toKey) {
            return new StandardSortedMapImpl<K, V>(((SortedMap<K, V>)this.m).subMap(fromKey, toKey));
        }

        @Override
        public K firstKey() {
            return ((SortedMap<K, V>)this.m).firstKey();
        }

        @Override
        public K lastKey() {
            return ((SortedMap<K, V>)this.m).lastKey();
        }
    }
    
    private static class StandardNavigableMapImpl<K, V> extends StandardSortedMapImpl<K, V> implements StandardNavigableMap<K, V> {

        StandardNavigableMapImpl(NavigableMap<K, V> m) {
            super(m);
        }

        @Override
        public StandardNavigableMap<K, V> descendingMap() {
            return new StandardNavigableMapImpl<K, V>(((NavigableMap<K, V>)this.m).descendingMap());
        }

        @Override
        public StandardNavigableMap<K, V> headMap(K toKey) {
            return new StandardNavigableMapImpl<K, V>(((NavigableMap<K, V>)this.m).headMap(toKey, false));
        }

        @Override
        public StandardNavigableMap<K, V> tailMap(K fromKey) {
            return new StandardNavigableMapImpl<K, V>(((NavigableMap<K, V>)this.m).tailMap(fromKey, true));
        }

        @Override
        public StandardNavigableMap<K, V> subMap(K fromKey, K toKey) {
            return new StandardNavigableMapImpl<K, V>(((NavigableMap<K, V>)this.m).subMap(fromKey, true, toKey, false));
        }
        
        @Override
        public StandardNavigableMap<K, V> headMap(K toKey, boolean inclusive) {
            return new StandardNavigableMapImpl<K, V>(((NavigableMap<K, V>)this.m).headMap(toKey, inclusive));
        }

        @Override
        public StandardNavigableMap<K, V> tailMap(K fromKey, boolean inclusive) {
            return new StandardNavigableMapImpl<K, V>(((NavigableMap<K, V>)this.m).tailMap(fromKey, inclusive));
        }

        @Override
        public StandardNavigableMap<K, V> subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) {
            return new StandardNavigableMapImpl<K, V>(((NavigableMap<K, V>)this.m).subMap(fromKey, fromInclusive, toKey, toInclusive));
        }

        @Override
        public NavigableSet<K> navigableKeySet() {
            return ((NavigableMap<K, V>)this.m).navigableKeySet();
        }

        @Override
        public NavigableSet<K> descendingKeySet() {
            return ((NavigableMap<K, V>)this.m).descendingKeySet();
        }

        @Override
        public Map.Entry<K, V> lowerEntry(K key) {
            return ((NavigableMap<K, V>)this.m).lowerEntry(key);
        }

        @Override
        public K lowerKey(K key) {
            return ((NavigableMap<K, V>)this.m).lowerKey(key);
        }

        @Override
        public Map.Entry<K, V> floorEntry(K key) {
            return ((NavigableMap<K, V>)this.m).floorEntry(key);
        }

        @Override
        public K floorKey(K key) {
            return ((NavigableMap<K, V>)this.m).floorKey(key);
        }

        @Override
        public Map.Entry<K, V> ceilingEntry(K key) {
            return ((NavigableMap<K, V>)this.m).ceilingEntry(key);
        }

        @Override
        public K ceilingKey(K key) {
            return ((NavigableMap<K, V>)this.m).ceilingKey(key);
        }

        @Override
        public Map.Entry<K, V> higherEntry(K key) {
            return ((NavigableMap<K, V>)this.m).higherEntry(key);
        }

        @Override
        public K higherKey(K key) {
            return ((NavigableMap<K, V>)this.m).higherKey(key);
        }

        @Override
        public Map.Entry<K, V> firstEntry() {
            return ((NavigableMap<K, V>)this.m).firstEntry();
        }

        @Override
        public Map.Entry<K, V> lastEntry() {
            return ((NavigableMap<K, V>)this.m).lastEntry();
        }

        @Override
        public Map.Entry<K, V> pollFirstEntry() {
            return ((NavigableMap<K, V>)this.m).pollFirstEntry();
        }

        @Override
        public Map.Entry<K, V> pollLastEntry() {
            return ((NavigableMap<K, V>)this.m).pollLastEntry();
        }
        
    }
    
    private static class SerializableStandardMapImpl<K, V> extends StandardMapImpl<K, V> implements Serializable {

        private static final long serialVersionUID = 5124433662847801309L;

        SerializableStandardMapImpl(Map<K, V> m) {
            super(m);
        }
        
    }
    
    private static class SerializableStandardSortedMapImpl<K, V> extends StandardSortedMapImpl<K, V> implements Serializable {

        private static final long serialVersionUID = -8839835619496839828L;

        SerializableStandardSortedMapImpl(SortedMap<K, V> m) {
            super(m);
        }
        
    }
    
    private static class SerializableStandardNavigableMapImpl<K, V> extends StandardNavigableMapImpl<K, V> implements Serializable {

        private static final long serialVersionUID = 6208652857269454996L;

        SerializableStandardNavigableMapImpl(NavigableMap<K, V> m) {
            super(m);
        }
    }
    
    /*
     * Validation
     */
    
    private static void validateLockSource(String cName, XCollection<?> c) {
        Arguments.mustNotBeNull(cName, c);
        UnifiedComparator<?> unifiedComparator = c.unifiedComparator();
        if (unifiedComparator.frozenComparator(false) != null ||
            unifiedComparator.frozenEqualityComparator(false) != null) {
            throw new IllegalArgumentException(
                canNotSupportUnstableElements(cName)
            );
        }
    }

    private static void validateLockSource(String cName, Collection<?> c) {
        Arguments.mustNotBeNull(cName, c);
        if (c instanceof XCollection<?>) {
            UnifiedComparator<?> unifiedComparator = 
                    ((XCollection<?>)c).unifiedComparator();
            if (unifiedComparator.frozenComparator(false) != null ||
                unifiedComparator.frozenEqualityComparator(false) != null) {
                throw new IllegalArgumentException(
                    canNotSupportUnstableElements(cName)
                );
            }
        }
    }

    private static void validateLockSource(String itrName, XCollection.XIterator<?> itr) {
        Arguments.mustNotBeNull(itrName, itr);
        UnifiedComparator<?> unifiedComparator = itr.unifiedComparator();
        if (unifiedComparator.frozenComparator(false) != null ||
            unifiedComparator.frozenEqualityComparator(false) != null) {
            throw new IllegalArgumentException(
                canNotSupportUnstableElements(itrName)
            );
        }
    }

    private static void validateLockSource(String itrName, Iterator<?> itr) {
        Arguments.mustNotBeNull(itrName, itr);
        if (itr instanceof XCollection.XIterator<?>) {
            UnifiedComparator<?> unifiedComparator = 
                    ((XCollection.XIterator<?>)itr).unifiedComparator();
            if (unifiedComparator.frozenComparator(false) != null ||
                unifiedComparator.frozenEqualityComparator(false) != null) {
                throw new IllegalArgumentException(
                    canNotSupportUnstableElements(itrName)
                );
            }
        }
    }

    private static void validateLockSource(String mName, XMap<?, ?> m) {
        Arguments.mustNotBeNull(mName, m);
        UnifiedComparator<?> keyUnifiedComparator = m.keyUnifiedComparator();
        if (keyUnifiedComparator.frozenComparator(false) != null ||
            keyUnifiedComparator.frozenEqualityComparator(false) != null) {
            throw new IllegalArgumentException(
                canNotSupportUnstableKeys(mName)
            );
        }
    }

    private static void validateLockSource(String mName, Map<?, ?> m) {
        Arguments.mustNotBeNull(mName, m);
        if (m instanceof XMap<?, ?>) {
            UnifiedComparator<?> keyUnifiedComparator = 
                ((XMap<?, ?>)m).keyUnifiedComparator();
            if (keyUnifiedComparator.frozenComparator(false) != null ||
                keyUnifiedComparator.frozenEqualityComparator(false) != null) {
                throw new IllegalArgumentException(
                    canNotSupportUnstableKeys(mName)
                );
            }
        }
    }

    private static void validateLockSource(String eName, XMap.XEntry<?, ?> e) {
        Arguments.mustNotBeNull(eName, e);
        UnifiedComparator<?> keyUnifiedComparator =  e.keyUnifiedComparator();
        if (keyUnifiedComparator.frozenComparator(false) != null ||
            keyUnifiedComparator.frozenEqualityComparator(false) != null) {
            throw new IllegalArgumentException(
                canNotSupportUnstableKeys(eName)
            );
        }
    }

    private static void validateLockSource(String eName, Map.Entry<?, ?> e) {
        Arguments.mustNotBeNull(eName, e);
        if (e instanceof XMap.XEntry<?, ?>) {
            UnifiedComparator<?> keyUnifiedComparator = 
                ((XMap.XEntry<?, ?>)e).keyUnifiedComparator();
            if (keyUnifiedComparator.frozenComparator(false) != null ||
                keyUnifiedComparator.frozenEqualityComparator(false) != null) {
                throw new IllegalArgumentException(
                    canNotSupportUnstableKeys(eName)
                );
            }
        }
    }
    
    /*
     * Proxy
     */
    
    public static boolean isUnmodifiable(Map<?, ?> m) {
        return m instanceof Proxy && ((Proxy)m).isUnmodifiable();
    }
    
    public static boolean isUnmodifiable(Collection<?> c) {
        return c instanceof WrappedArrayList<?> ||
                (c instanceof Proxy && ((Proxy)c).isUnmodifiable());
    }
    
    public static boolean isUnmodifiable(Iterator<?> itr) {
        return itr instanceof WrappedArrayList<?>.IteratorImpl ||
                (itr instanceof Proxy && ((Proxy)itr).isUnmodifiable());
    }
    
    public static boolean isUnmodifiable(Entry<?, ?> e) {
        return 
                e instanceof WrappedArrayList<?> ||
                (e instanceof Proxy && ((Proxy)e).isUnmodifiable());
    }
    
    public static boolean isLocked(Map<?, ?> m) {
        return m instanceof Proxy && ((Proxy)m).isLocked(null);
    }
    
    public static boolean isLocked(Collection<?> c) {
        return 
                c instanceof WrappedArrayList<?> ||
                (c instanceof Proxy && ((Proxy)c).isLocked(null));
    }
    
    public static boolean isLocked(Iterator<?> itr) {
        return itr instanceof WrappedArrayList<?>.IteratorImpl ||
                (itr instanceof Proxy && ((Proxy)itr).isLocked(null));
    }
    
    public static boolean isLocked(Entry<?, ?> e) {
        return e instanceof Proxy && ((Proxy)e).isLocked(null);
    }
    
    public static boolean isLocked(Map<?, ?> m, ReadWriteLock readWriteLock) {
        return m instanceof Proxy && ((Proxy)m).isLocked(readWriteLock);
    }
    
    public static boolean isLocked(Collection<?> c, ReadWriteLock readWriteLock) {
        return 
                (readWriteLock == null && c instanceof WrappedArrayList<?>) ||
                (c instanceof Proxy && ((Proxy)c).isLocked(readWriteLock));
    }
    
    public static boolean isLocked(Iterator<?> itr, ReadWriteLock readWriteLock) {
        return (readWriteLock == null && itr instanceof WrappedArrayList<?>.IteratorImpl) ||
                (itr instanceof Proxy && ((Proxy)itr).isLocked(readWriteLock));
    }
    
    public static boolean isLocked(Entry<?, ?> e, ReadWriteLock readWriteLock) {
        return e instanceof Proxy && ((Proxy)e).isLocked(readWriteLock);
    }
    
    private static boolean isReadWriteLockSupported(Object o) {
        if (o instanceof LockDescriptor && ((LockDescriptor)o).isReadWriteLockSupported()) {
            return true;
        }
        return o.getClass().getPackage() == JAVA_UTIL_PACKAGE;
    }

    private static abstract class Proxy implements LockDescriptor {
        
        abstract Object getInnerObject();
        
        abstract <T> T recreate(T obj);
        
        final Object getRealObject() {
            Object innerObject = this.getInnerObject();
            if (innerObject instanceof Proxy) {
                return ((Proxy)innerObject).getRealObject();
            }
            return innerObject;
        }
        
        boolean isUnmodifiable() {
            Object innerObject = this.getInnerObject();
            if (innerObject instanceof Proxy) {
                return ((Proxy)innerObject).isUnmodifiable();
            }
            return false;
        }
        
        boolean isLocked(ReadWriteLock readWriteLock) {
            Object innerObject = this.getInnerObject();
            if (innerObject instanceof Proxy) {
                return ((Proxy)innerObject).isLocked(readWriteLock);
            }
            return false;
        }
        
        <T> void locking(T obj, int lockingState, Consumer<T> lockingConsumer) {
            Object innerObject = this.getInnerObject();
            if (innerObject instanceof Proxy) {
                ((Proxy)innerObject).locking(obj, lockingState, lockingConsumer);
            } else {
                LockingProxy lockingProxy = (LockingProxy)obj;
                try {
                    lockingConsumer.accept(obj);
                } finally {
                    lockingProxy.dispose();
                }
            }
        }
        
        <R, T> R locking(T obj, int lockingState, Function<T, R> lockingFunction) {
            Object innerObject = this.getInnerObject();
            if (innerObject instanceof Proxy) {
                return ((Proxy)innerObject).locking(obj, lockingState, lockingFunction);
            }
            LockingProxy lockingProxy = (LockingProxy)obj;
            try {
                return lockingFunction.apply(obj);
            } finally {
                lockingProxy.dispose();
            }
        }
        
        final Proxy[] getProxies() {
            int len = this.proxyCount();
            Proxy[] proxies = new Proxy[len];
            addProxy(proxies, proxies.length - 1);
            return proxies;
        }
        
        private int proxyCount() {
            Object innerObject = this.getInnerObject();
            if (innerObject instanceof Proxy) {
                return ((Proxy)innerObject).proxyCount() + 1;
            }
            return 1;
        }
        
        private void addProxy(Proxy[] proxies, int index) {
            proxies[index] = this;
            Object innerObject = this.getInnerObject();
            if (innerObject instanceof Proxy) {
                ((Proxy)innerObject).addProxy(proxies, index - 1);
            }
        }
        
        @Override
        public boolean isReadWriteLockSupported() {
            return MACollections.isReadWriteLockSupported(this.getInnerObject());
        }
    }
    
    private static abstract class GatewayProxy extends Proxy {

    }
    
    private static abstract class UnmodifiableProxy extends GatewayProxy {

        @Override
        boolean isUnmodifiable() {
            return true;
        }
        
    }
    
    private static abstract class LockedProxy extends Proxy {
        
        ReadWriteLock readWriteLock;
        
        boolean usingInternalLock;
        
        LockedProxy(ReadWriteLock readWriteLock, boolean usingInternalLock) {
            if (readWriteLock == null) {
                this.readWriteLock = new ReentrantReadWriteLock();
                this.usingInternalLock = true;
            } else {
                this.readWriteLock = readWriteLock;
                this.usingInternalLock = usingInternalLock;
            }
        }
        
        @Deprecated //Only for deserialization
        LockedProxy() {
        }
        
        @Override
        boolean isLocked(ReadWriteLock readWriteLock) {
            if (readWriteLock == null) {
                return this.usingInternalLock;
            }
            if (this.readWriteLock == readWriteLock) {
                return true;
            }
            return super.isLocked(readWriteLock);
        }

        @Override
        <T> void locking(T obj, int lockingState, Consumer<T> lockedConsumer) {
            Lock lock = 
                    lockingState == LockingManager.READ && MACollections.isReadWriteLockSupported(obj) ?
                    this.readWriteLock.readLock() :
                    this.readWriteLock.writeLock();
            lock.lock();
            try {
                super.locking(obj, lockingState, lockedConsumer);
            } finally {
                lock.unlock();
            }
        }

        @Override
        <R, T> R locking(T obj, int lockingState, Function<T, R> lockingFunction) {
            Lock lock = 
                    lockingState == LockingManager.READ && MACollections.isReadWriteLockSupported(obj) ?
                    this.readWriteLock.readLock() :
                    this.readWriteLock.writeLock();
            lock.lock();
            try {
                return super.locking(obj, lockingState, lockingFunction);
            } finally {
                lock.unlock();
            }
        }
    }
    
    private static abstract class LockingProxy extends GatewayProxy {
        
        LockingManager lockingManager;
        
        Thread initThread;
        
        LockingProxy(LockingManager lockingManager) {
            this.lockingManager = lockingManager;
            this.initThread = Thread.currentThread();
        }
        
        @Deprecated //Only for deserialization
        LockingProxy() {
            this.initThread = Thread.currentThread();
        }
        
        void dispose() {
            this.lockingManager.state = LockingManager.DISPOSED;
        }
    }
    
    private static class LockingManager implements Serializable {
        
        private static final long serialVersionUID = -934213472198421736L;
        
        static final int DISPOSED = 0;
        
        static final int READ = 1;
        
        static final int WRITE = 2;
        
        volatile int state;
        
        LockingManager(LockMode lockMode) {
            this.state = lockMode == LockMode.WRITE ? WRITE : READ;
        }
        
    }
    
    @I18N
    private static native String notSupported(String methodSignature);

    @I18N
    private static native String unmodifable(String methodSignature);
        
    @I18N
    private static native String mandatoryLockingObject(String methodSignature);
    
    @I18N
    private static native String illegalLockingThread(String methodSignature);
    
    @I18N
    private static native String lockingObjectDisposed(String methodSignature);
    
    @I18N
    private static native String illegalLockMode(String methodSignature);
    
    @I18N
    private static native String canNotSupportUnstableElements(String parameterName);
    
    @I18N
    private static native String canNotSupportUnstableKeys(String parameterName);
    
    /*
     * Atuomatically generate by tool.
     */
    public static <K, V> Map<K, V> unmodifiable(Map<K, V> m) {
        if (MACollections.isUnmodifiable(m)) {
            return m;
        }
        Arguments.mustNotBeNull("m", m);
        if (m instanceof Serializable) {
            if (m instanceof XMap<?, ?>) {
                if (m instanceof MAMap<?, ?>) {
                    if (m instanceof MAOrderedMap<?, ?>) {
                        return new UnmodifiableMAOrderedMapWithSerializable<K, V>(
                            (MAOrderedMap<K, V>)m);
                    }
                    if (m instanceof MASortedMap<?, ?>) {
                        if (m instanceof MANavigableMap<?, ?>) {
                            return new UnmodifiableMANavigableMapWithSerializable<K, V>(
                                (MANavigableMap<K, V>)m);
                        }
                        return new UnmodifiableMASortedMapWithSerializable<K, V>(
                            (MASortedMap<K, V>)m);
                    }
                    return new UnmodifiableMAMapWithSerializable<K, V>(
                        (MAMap<K, V>)m);
                }
                if (m instanceof XOrderedMap<?, ?>) {
                    return new UnmodifiableXOrderedMapWithSerializable<K, V>(
                        (XOrderedMap<K, V>)m);
                }
                if (m instanceof XSortedMap<?, ?>) {
                    if (m instanceof XNavigableMap<?, ?>) {
                        return new UnmodifiableXNavigableMapWithSerializable<K, V>(
                            (XNavigableMap<K, V>)m);
                    }
                    return new UnmodifiableXSortedMapWithSerializable<K, V>(
                        (XSortedMap<K, V>)m);
                }
                return new UnmodifiableXMapWithSerializable<K, V>(
                    (XMap<K, V>)m);
            }
            if (m instanceof StandardMap<?, ?>) {
                if (m instanceof StandardSortedMap<?, ?>) {
                    if (m instanceof StandardNavigableMap<?, ?>) {
                        return new UnmodifiableStandardNavigableMapWithSerializable<K, V>(
                            (StandardNavigableMap<K, V>)m);
                    }
                    return new UnmodifiableStandardSortedMapWithSerializable<K, V>(
                        (StandardSortedMap<K, V>)m);
                }
                return new UnmodifiableStandardMapWithSerializable<K, V>(
                    (StandardMap<K, V>)m);
            }
            if (m instanceof SortedMap<?, ?>) {
                if (m instanceof NavigableMap<?, ?>) {
                    return unmodifiable(standard((NavigableMap<K, V>)m));
                }
                return unmodifiable(standard((SortedMap<K, V>)m));
            }
            return unmodifiable(standard(m));
        }
        if (m instanceof XMap<?, ?>) {
            if (m instanceof MAMap<?, ?>) {
                if (m instanceof MAOrderedMap<?, ?>) {
                    if (m instanceof MAOrderedMap.MAOrderedMapView<?, ?>) {
                        return new UnmodifiableMAOrderedMapMAOrderedMapView<K, V>(
                            (MAOrderedMap.MAOrderedMapView<K, V>)m);
                    }
                    return new UnmodifiableMAOrderedMap<K, V>(
                        (MAOrderedMap<K, V>)m);
                }
                if (m instanceof MASortedMap<?, ?>) {
                    if (m instanceof MANavigableMap<?, ?>) {
                        if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
                            return new UnmodifiableMANavigableMapMANavigableMapView<K, V>(
                                (MANavigableMap.MANavigableMapView<K, V>)m);
                        }
                        return new UnmodifiableMANavigableMap<K, V>(
                            (MANavigableMap<K, V>)m);
                    }
                    if (m instanceof MASortedMap.MASortedMapView<?, ?>) {
                        return new UnmodifiableMASortedMapMASortedMapView<K, V>(
                            (MASortedMap.MASortedMapView<K, V>)m);
                    }
                    return new UnmodifiableMASortedMap<K, V>(
                        (MASortedMap<K, V>)m);
                }
                return new UnmodifiableMAMap<K, V>(
                    (MAMap<K, V>)m);
            }
            if (m instanceof XOrderedMap<?, ?>) {
                if (m instanceof XOrderedMap.XOrderedMapView<?, ?>) {
                    return new UnmodifiableXOrderedMapXOrderedMapView<K, V>(
                        (XOrderedMap.XOrderedMapView<K, V>)m);
                }
                return new UnmodifiableXOrderedMap<K, V>(
                    (XOrderedMap<K, V>)m);
            }
            if (m instanceof XSortedMap<?, ?>) {
                if (m instanceof XNavigableMap<?, ?>) {
                    if (m instanceof XNavigableMap.XNavigableMapView<?, ?>) {
                        return new UnmodifiableXNavigableMapXNavigableMapView<K, V>(
                            (XNavigableMap.XNavigableMapView<K, V>)m);
                    }
                    return new UnmodifiableXNavigableMap<K, V>(
                        (XNavigableMap<K, V>)m);
                }
                if (m instanceof XSortedMap.XSortedMapView<?, ?>) {
                    return new UnmodifiableXSortedMapXSortedMapView<K, V>(
                        (XSortedMap.XSortedMapView<K, V>)m);
                }
                return new UnmodifiableXSortedMap<K, V>(
                    (XSortedMap<K, V>)m);
            }
            return new UnmodifiableXMap<K, V>(
                (XMap<K, V>)m);
        }
        if (m instanceof StandardMap<?, ?>) {
            if (m instanceof StandardSortedMap<?, ?>) {
                if (m instanceof StandardNavigableMap<?, ?>) {
                    return new UnmodifiableStandardNavigableMap<K, V>(
                        (StandardNavigableMap<K, V>)m);
                }
                return new UnmodifiableStandardSortedMap<K, V>(
                    (StandardSortedMap<K, V>)m);
            }
            return new UnmodifiableStandardMap<K, V>(
                (StandardMap<K, V>)m);
        }
        if (m instanceof SortedMap<?, ?>) {
            if (m instanceof NavigableMap<?, ?>) {
                return unmodifiable(standard((NavigableMap<K, V>)m));
            }
            return unmodifiable(standard((SortedMap<K, V>)m));
        }
        return unmodifiable(standard(m));
    }

    public static <K, V> SortedMap<K, V> unmodifiable(SortedMap<K, V> m) {
        if (MACollections.isUnmodifiable(m)) {
            return m;
        }
        Arguments.mustNotBeNull("m", m);
        if (m instanceof Serializable) {
            if (m instanceof MASortedMap<?, ?>) {
                if (m instanceof MANavigableMap<?, ?>) {
                    return new UnmodifiableMANavigableMapWithSerializable<K, V>(
                        (MANavigableMap<K, V>)m);
                }
                return new UnmodifiableMASortedMapWithSerializable<K, V>(
                    (MASortedMap<K, V>)m);
            }
            if (m instanceof XSortedMap<?, ?>) {
                if (m instanceof XNavigableMap<?, ?>) {
                    return new UnmodifiableXNavigableMapWithSerializable<K, V>(
                        (XNavigableMap<K, V>)m);
                }
                return new UnmodifiableXSortedMapWithSerializable<K, V>(
                    (XSortedMap<K, V>)m);
            }
            if (m instanceof StandardSortedMap<?, ?>) {
                if (m instanceof StandardNavigableMap<?, ?>) {
                    return new UnmodifiableStandardNavigableMapWithSerializable<K, V>(
                        (StandardNavigableMap<K, V>)m);
                }
                return new UnmodifiableStandardSortedMapWithSerializable<K, V>(
                    (StandardSortedMap<K, V>)m);
            }
            if (m instanceof NavigableMap<?, ?>) {
                return unmodifiable(standard((NavigableMap<K, V>)m));
            }
            return unmodifiable(standard(m));
        }
        if (m instanceof MASortedMap<?, ?>) {
            if (m instanceof MANavigableMap<?, ?>) {
                if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
                    return new UnmodifiableMANavigableMapMANavigableMapView<K, V>(
                        (MANavigableMap.MANavigableMapView<K, V>)m);
                }
                return new UnmodifiableMANavigableMap<K, V>(
                    (MANavigableMap<K, V>)m);
            }
            if (m instanceof MASortedMap.MASortedMapView<?, ?>) {
                return new UnmodifiableMASortedMapMASortedMapView<K, V>(
                    (MASortedMap.MASortedMapView<K, V>)m);
            }
            return new UnmodifiableMASortedMap<K, V>(
                (MASortedMap<K, V>)m);
        }
        if (m instanceof XSortedMap<?, ?>) {
            if (m instanceof XNavigableMap<?, ?>) {
                if (m instanceof XNavigableMap.XNavigableMapView<?, ?>) {
                    return new UnmodifiableXNavigableMapXNavigableMapView<K, V>(
                        (XNavigableMap.XNavigableMapView<K, V>)m);
                }
                return new UnmodifiableXNavigableMap<K, V>(
                    (XNavigableMap<K, V>)m);
            }
            if (m instanceof XSortedMap.XSortedMapView<?, ?>) {
                return new UnmodifiableXSortedMapXSortedMapView<K, V>(
                    (XSortedMap.XSortedMapView<K, V>)m);
            }
            return new UnmodifiableXSortedMap<K, V>(
                (XSortedMap<K, V>)m);
        }
        if (m instanceof StandardSortedMap<?, ?>) {
            if (m instanceof StandardNavigableMap<?, ?>) {
                return new UnmodifiableStandardNavigableMap<K, V>(
                    (StandardNavigableMap<K, V>)m);
            }
            return new UnmodifiableStandardSortedMap<K, V>(
                (StandardSortedMap<K, V>)m);
        }
        if (m instanceof NavigableMap<?, ?>) {
            return unmodifiable(standard((NavigableMap<K, V>)m));
        }
        return unmodifiable(standard(m));
    }

    public static <K, V> NavigableMap<K, V> unmodifiable(NavigableMap<K, V> m) {
        if (MACollections.isUnmodifiable(m)) {
            return m;
        }
        Arguments.mustNotBeNull("m", m);
        if (m instanceof Serializable) {
            if (m instanceof MANavigableMap<?, ?>) {
                return new UnmodifiableMANavigableMapWithSerializable<K, V>(
                    (MANavigableMap<K, V>)m);
            }
            if (m instanceof XNavigableMap<?, ?>) {
                return new UnmodifiableXNavigableMapWithSerializable<K, V>(
                    (XNavigableMap<K, V>)m);
            }
            if (m instanceof StandardNavigableMap<?, ?>) {
                return new UnmodifiableStandardNavigableMapWithSerializable<K, V>(
                    (StandardNavigableMap<K, V>)m);
            }
            return unmodifiable(standard(m));
        }
        if (m instanceof MANavigableMap<?, ?>) {
            if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
                return new UnmodifiableMANavigableMapMANavigableMapView<K, V>(
                    (MANavigableMap.MANavigableMapView<K, V>)m);
            }
            return new UnmodifiableMANavigableMap<K, V>(
                (MANavigableMap<K, V>)m);
        }
        if (m instanceof XNavigableMap<?, ?>) {
            if (m instanceof XNavigableMap.XNavigableMapView<?, ?>) {
                return new UnmodifiableXNavigableMapXNavigableMapView<K, V>(
                    (XNavigableMap.XNavigableMapView<K, V>)m);
            }
            return new UnmodifiableXNavigableMap<K, V>(
                (XNavigableMap<K, V>)m);
        }
        if (m instanceof StandardNavigableMap<?, ?>) {
            return new UnmodifiableStandardNavigableMap<K, V>(
                (StandardNavigableMap<K, V>)m);
        }
        return unmodifiable(standard(m));
    }

    private static <K, V> StandardSortedMap<K, V> unmodifiable(StandardSortedMap<K, V> m) {
        if (MACollections.isUnmodifiable(m)) {
            return m;
        }
        if (m instanceof Serializable) {
            if (m instanceof StandardNavigableMap<?, ?>) {
                return new UnmodifiableStandardNavigableMapWithSerializable<K, V>(
                    (StandardNavigableMap<K, V>)m);
            }
            return new UnmodifiableStandardSortedMapWithSerializable<K, V>(m);
        }
        if (m instanceof StandardNavigableMap<?, ?>) {
            return new UnmodifiableStandardNavigableMap<K, V>(
                (StandardNavigableMap<K, V>)m);
        }
        return new UnmodifiableStandardSortedMap<K, V>(m);
    }

    private static <K, V> StandardNavigableMap<K, V> unmodifiable(StandardNavigableMap<K, V> m) {
        if (MACollections.isUnmodifiable(m)) {
            return m;
        }
        if (m instanceof Serializable) {
            return new UnmodifiableStandardNavigableMapWithSerializable<K, V>(m);
        }
        return new UnmodifiableStandardNavigableMap<K, V>(m);
    }

    public static <K, V> XMap<K, V> unmodifiable(XMap<K, V> m) {
        if (MACollections.isUnmodifiable(m)) {
            return m;
        }
        Arguments.mustNotBeNull("m", m);
        if (m instanceof Serializable) {
            if (m instanceof MAMap<?, ?>) {
                if (m instanceof MAOrderedMap<?, ?>) {
                    return new UnmodifiableMAOrderedMapWithSerializable<K, V>(
                        (MAOrderedMap<K, V>)m);
                }
                if (m instanceof MASortedMap<?, ?>) {
                    if (m instanceof MANavigableMap<?, ?>) {
                        return new UnmodifiableMANavigableMapWithSerializable<K, V>(
                            (MANavigableMap<K, V>)m);
                    }
                    return new UnmodifiableMASortedMapWithSerializable<K, V>(
                        (MASortedMap<K, V>)m);
                }
                return new UnmodifiableMAMapWithSerializable<K, V>(
                    (MAMap<K, V>)m);
            }
            if (m instanceof XOrderedMap<?, ?>) {
                return new UnmodifiableXOrderedMapWithSerializable<K, V>(
                    (XOrderedMap<K, V>)m);
            }
            if (m instanceof XSortedMap<?, ?>) {
                if (m instanceof XNavigableMap<?, ?>) {
                    return new UnmodifiableXNavigableMapWithSerializable<K, V>(
                        (XNavigableMap<K, V>)m);
                }
                return new UnmodifiableXSortedMapWithSerializable<K, V>(
                    (XSortedMap<K, V>)m);
            }
            return new UnmodifiableXMapWithSerializable<K, V>(m);
        }
        if (m instanceof MAMap<?, ?>) {
            if (m instanceof MAOrderedMap<?, ?>) {
                if (m instanceof MAOrderedMap.MAOrderedMapView<?, ?>) {
                    return new UnmodifiableMAOrderedMapMAOrderedMapView<K, V>(
                        (MAOrderedMap.MAOrderedMapView<K, V>)m);
                }
                return new UnmodifiableMAOrderedMap<K, V>(
                    (MAOrderedMap<K, V>)m);
            }
            if (m instanceof MASortedMap<?, ?>) {
                if (m instanceof MANavigableMap<?, ?>) {
                    if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
                        return new UnmodifiableMANavigableMapMANavigableMapView<K, V>(
                            (MANavigableMap.MANavigableMapView<K, V>)m);
                    }
                    return new UnmodifiableMANavigableMap<K, V>(
                        (MANavigableMap<K, V>)m);
                }
                if (m instanceof MASortedMap.MASortedMapView<?, ?>) {
                    return new UnmodifiableMASortedMapMASortedMapView<K, V>(
                        (MASortedMap.MASortedMapView<K, V>)m);
                }
                return new UnmodifiableMASortedMap<K, V>(
                    (MASortedMap<K, V>)m);
            }
            return new UnmodifiableMAMap<K, V>(
                (MAMap<K, V>)m);
        }
        if (m instanceof XOrderedMap<?, ?>) {
            if (m instanceof XOrderedMap.XOrderedMapView<?, ?>) {
                return new UnmodifiableXOrderedMapXOrderedMapView<K, V>(
                    (XOrderedMap.XOrderedMapView<K, V>)m);
            }
            return new UnmodifiableXOrderedMap<K, V>(
                (XOrderedMap<K, V>)m);
        }
        if (m instanceof XSortedMap<?, ?>) {
            if (m instanceof XNavigableMap<?, ?>) {
                if (m instanceof XNavigableMap.XNavigableMapView<?, ?>) {
                    return new UnmodifiableXNavigableMapXNavigableMapView<K, V>(
                        (XNavigableMap.XNavigableMapView<K, V>)m);
                }
                return new UnmodifiableXNavigableMap<K, V>(
                    (XNavigableMap<K, V>)m);
            }
            if (m instanceof XSortedMap.XSortedMapView<?, ?>) {
                return new UnmodifiableXSortedMapXSortedMapView<K, V>(
                    (XSortedMap.XSortedMapView<K, V>)m);
            }
            return new UnmodifiableXSortedMap<K, V>(
                (XSortedMap<K, V>)m);
        }
        return new UnmodifiableXMap<K, V>(m);
    }

    public static <K, V> XSortedMap<K, V> unmodifiable(XSortedMap<K, V> m) {
        if (MACollections.isUnmodifiable(m)) {
            return m;
        }
        Arguments.mustNotBeNull("m", m);
        if (m instanceof Serializable) {
            if (m instanceof MASortedMap<?, ?>) {
                if (m instanceof MANavigableMap<?, ?>) {
                    return new UnmodifiableMANavigableMapWithSerializable<K, V>(
                        (MANavigableMap<K, V>)m);
                }
                return new UnmodifiableMASortedMapWithSerializable<K, V>(
                    (MASortedMap<K, V>)m);
            }
            if (m instanceof XNavigableMap<?, ?>) {
                return new UnmodifiableXNavigableMapWithSerializable<K, V>(
                    (XNavigableMap<K, V>)m);
            }
            return new UnmodifiableXSortedMapWithSerializable<K, V>(m);
        }
        if (m instanceof MASortedMap<?, ?>) {
            if (m instanceof MANavigableMap<?, ?>) {
                if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
                    return new UnmodifiableMANavigableMapMANavigableMapView<K, V>(
                        (MANavigableMap.MANavigableMapView<K, V>)m);
                }
                return new UnmodifiableMANavigableMap<K, V>(
                    (MANavigableMap<K, V>)m);
            }
            if (m instanceof MASortedMap.MASortedMapView<?, ?>) {
                return new UnmodifiableMASortedMapMASortedMapView<K, V>(
                    (MASortedMap.MASortedMapView<K, V>)m);
            }
            return new UnmodifiableMASortedMap<K, V>(
                (MASortedMap<K, V>)m);
        }
        if (m instanceof XNavigableMap<?, ?>) {
            if (m instanceof XNavigableMap.XNavigableMapView<?, ?>) {
                return new UnmodifiableXNavigableMapXNavigableMapView<K, V>(
                    (XNavigableMap.XNavigableMapView<K, V>)m);
            }
            return new UnmodifiableXNavigableMap<K, V>(
                (XNavigableMap<K, V>)m);
        }
        if (m instanceof XSortedMap.XSortedMapView<?, ?>) {
            return new UnmodifiableXSortedMapXSortedMapView<K, V>(
                (XSortedMap.XSortedMapView<K, V>)m);
        }
        return new UnmodifiableXSortedMap<K, V>(m);
    }

    public static <K, V> XSortedMap.XSortedMapView<K, V> unmodifiable(XSortedMap.XSortedMapView<K, V> m) {
        if (MACollections.isUnmodifiable(m)) {
            return m;
        }
        Arguments.mustNotBeNull("m", m);
        if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
            return new UnmodifiableMANavigableMapMANavigableMapView<K, V>(
                (MANavigableMap.MANavigableMapView<K, V>)m);
        }
        if (m instanceof MASortedMap.MASortedMapView<?, ?>) {
            return new UnmodifiableMASortedMapMASortedMapView<K, V>(
                (MASortedMap.MASortedMapView<K, V>)m);
        }
        if (m instanceof XNavigableMap.XNavigableMapView<?, ?>) {
            return new UnmodifiableXNavigableMapXNavigableMapView<K, V>(
                (XNavigableMap.XNavigableMapView<K, V>)m);
        }
        return new UnmodifiableXSortedMapXSortedMapView<K, V>(m);
    }

    public static <K, V> XNavigableMap<K, V> unmodifiable(XNavigableMap<K, V> m) {
        if (MACollections.isUnmodifiable(m)) {
            return m;
        }
        Arguments.mustNotBeNull("m", m);
        if (m instanceof Serializable) {
            if (m instanceof MANavigableMap<?, ?>) {
                return new UnmodifiableMANavigableMapWithSerializable<K, V>(
                    (MANavigableMap<K, V>)m);
            }
            return new UnmodifiableXNavigableMapWithSerializable<K, V>(m);
        }
        if (m instanceof MANavigableMap<?, ?>) {
            if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
                return new UnmodifiableMANavigableMapMANavigableMapView<K, V>(
                    (MANavigableMap.MANavigableMapView<K, V>)m);
            }
            return new UnmodifiableMANavigableMap<K, V>(
                (MANavigableMap<K, V>)m);
        }
        if (m instanceof XNavigableMap.XNavigableMapView<?, ?>) {
            return new UnmodifiableXNavigableMapXNavigableMapView<K, V>(
                (XNavigableMap.XNavigableMapView<K, V>)m);
        }
        return new UnmodifiableXNavigableMap<K, V>(m);
    }

    public static <K, V> XNavigableMap.XNavigableMapView<K, V> unmodifiable(XNavigableMap.XNavigableMapView<K, V> m) {
        if (MACollections.isUnmodifiable(m)) {
            return m;
        }
        Arguments.mustNotBeNull("m", m);
        if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
            return new UnmodifiableMANavigableMapMANavigableMapView<K, V>(
                (MANavigableMap.MANavigableMapView<K, V>)m);
        }
        return new UnmodifiableXNavigableMapXNavigableMapView<K, V>(m);
    }

    public static <K, V> XOrderedMap<K, V> unmodifiable(XOrderedMap<K, V> m) {
        if (MACollections.isUnmodifiable(m)) {
            return m;
        }
        Arguments.mustNotBeNull("m", m);
        if (m instanceof Serializable) {
            if (m instanceof MAOrderedMap<?, ?>) {
                return new UnmodifiableMAOrderedMapWithSerializable<K, V>(
                    (MAOrderedMap<K, V>)m);
            }
            return new UnmodifiableXOrderedMapWithSerializable<K, V>(m);
        }
        if (m instanceof MAOrderedMap<?, ?>) {
            if (m instanceof MAOrderedMap.MAOrderedMapView<?, ?>) {
                return new UnmodifiableMAOrderedMapMAOrderedMapView<K, V>(
                    (MAOrderedMap.MAOrderedMapView<K, V>)m);
            }
            return new UnmodifiableMAOrderedMap<K, V>(
                (MAOrderedMap<K, V>)m);
        }
        if (m instanceof XOrderedMap.XOrderedMapView<?, ?>) {
            return new UnmodifiableXOrderedMapXOrderedMapView<K, V>(
                (XOrderedMap.XOrderedMapView<K, V>)m);
        }
        return new UnmodifiableXOrderedMap<K, V>(m);
    }

    public static <K, V> XOrderedMap.XOrderedMapView<K, V> unmodifiable(XOrderedMap.XOrderedMapView<K, V> m) {
        if (MACollections.isUnmodifiable(m)) {
            return m;
        }
        Arguments.mustNotBeNull("m", m);
        if (m instanceof MAOrderedMap.MAOrderedMapView<?, ?>) {
            return new UnmodifiableMAOrderedMapMAOrderedMapView<K, V>(
                (MAOrderedMap.MAOrderedMapView<K, V>)m);
        }
        return new UnmodifiableXOrderedMapXOrderedMapView<K, V>(m);
    }

    private static <K, V> MASortedMap.MASortedMapView<K, V> unmodifiable(MASortedMap.MASortedMapView<K, V> m) {
        if (MACollections.isUnmodifiable(m)) {
            return m;
        }
        if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
            return new UnmodifiableMANavigableMapMANavigableMapView<K, V>(
                (MANavigableMap.MANavigableMapView<K, V>)m);
        }
        return new UnmodifiableMASortedMapMASortedMapView<K, V>(m);
    }

    private static <K, V> MANavigableMap.MANavigableMapView<K, V> unmodifiable(MANavigableMap.MANavigableMapView<K, V> m) {
        if (MACollections.isUnmodifiable(m)) {
            return m;
        }
        return new UnmodifiableMANavigableMapMANavigableMapView<K, V>(m);
    }

    private static <K, V> MAOrderedMap.MAOrderedMapView<K, V> unmodifiable(MAOrderedMap.MAOrderedMapView<K, V> m) {
        if (MACollections.isUnmodifiable(m)) {
            return m;
        }
        return new UnmodifiableMAOrderedMapMAOrderedMapView<K, V>(m);
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    public static <E> Collection<E> unmodifiable(Collection<E> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        Arguments.mustNotBeNull("c", c);
        if (c instanceof Serializable) {
            if (c instanceof RandomAccess) {
                if (c instanceof MAList<?>) {
                    return new UnmodifiableMAListWithSerializableRandomAccess<E>(
                        (MAList<E>)c);
                }
                if (c instanceof XList<?>) {
                    return new UnmodifiableXListWithSerializableRandomAccess<E>(
                        (XList<E>)c);
                }
                if (c instanceof List<?>) {
                    return new UnmodifiableListWithSerializableRandomAccess<E>(
                        (List<E>)c);
                }
            }
            if (c instanceof XCollection<?>) {
                if (c instanceof MACollection<?>) {
                    if (c instanceof MAList<?>) {
                        return new UnmodifiableMAListWithSerializable<E>(
                            (MAList<E>)c);
                    }
                    if (c instanceof MASet<?>) {
                        if (c instanceof MAOrderedSet<?>) {
                            return new UnmodifiableMAOrderedSetWithSerializable<E>(
                                (MAOrderedSet<E>)c);
                        }
                        if (c instanceof MASortedSet<?>) {
                            if (c instanceof MANavigableSet<?>) {
                                return new UnmodifiableMANavigableSetWithSerializable<E>(
                                    (MANavigableSet<E>)c);
                            }
                            return new UnmodifiableMASortedSetWithSerializable<E>(
                                (MASortedSet<E>)c);
                        }
                        return new UnmodifiableMASetWithSerializable<E>(
                            (MASet<E>)c);
                    }
                    return new UnmodifiableMACollectionWithSerializable<E>(
                        (MACollection<E>)c);
                }
                if (c instanceof XList<?>) {
                    return new UnmodifiableXListWithSerializable<E>(
                        (XList<E>)c);
                }
                if (c instanceof XSet<?>) {
                    if (c instanceof XOrderedSet<?>) {
                        return new UnmodifiableXOrderedSetWithSerializable<E>(
                            (XOrderedSet<E>)c);
                    }
                    if (c instanceof XSortedSet<?>) {
                        if (c instanceof XNavigableSet<?>) {
                            return new UnmodifiableXNavigableSetWithSerializable<E>(
                                (XNavigableSet<E>)c);
                        }
                        return new UnmodifiableXSortedSetWithSerializable<E>(
                            (XSortedSet<E>)c);
                    }
                    return new UnmodifiableXSetWithSerializable<E>(
                        (XSet<E>)c);
                }
                return new UnmodifiableXCollectionWithSerializable<E>(
                    (XCollection<E>)c);
            }
            if (c instanceof Set<?>) {
                if (c instanceof StandardMap.EntrySet<?, ?>) {
                    return new UnmodifiableStandardMapEntrySetWithSerializable(
                        (StandardMap.EntrySet)c);
                }
                if (c instanceof SortedSet<?>) {
                    if (c instanceof NavigableSet<?>) {
                        return new UnmodifiableNavigableSetWithSerializable<E>(
                            (NavigableSet<E>)c);
                    }
                    return new UnmodifiableSortedSetWithSerializable<E>(
                        (SortedSet<E>)c);
                }
                return new UnmodifiableSetWithSerializable<E>(
                    (Set<E>)c);
            }
            if (c instanceof List<?>) {
                return new UnmodifiableListWithSerializable<E>(
                    (List<E>)c);
            }
            return new UnmodifiableCollectionWithSerializable<E>(c);
        }
        if (c instanceof RandomAccess) {
            if (c instanceof MAList<?>) {
                if (c instanceof MAList.MAListView<?>) {
                    return new UnmodifiableMAListMAListViewWithRandomAccess<E>(
                        (MAList.MAListView<E>)c);
                }
                return new UnmodifiableMAListWithRandomAccess<E>(
                    (MAList<E>)c);
            }
            if (c instanceof XList<?>) {
                if (c instanceof XList.XListView<?>) {
                    return new UnmodifiableXListXListViewWithRandomAccess<E>(
                        (XList.XListView<E>)c);
                }
                return new UnmodifiableXListWithRandomAccess<E>(
                    (XList<E>)c);
            }
            if (c instanceof List<?>) {
                return new UnmodifiableListWithRandomAccess<E>(
                    (List<E>)c);
            }
        }
        if (c instanceof XCollection<?>) {
            if (c instanceof MACollection<?>) {
                if (c instanceof MAList<?>) {
                    if (c instanceof MAList.MAListView<?>) {
                        return new UnmodifiableMAListMAListView<E>(
                            (MAList.MAListView<E>)c);
                    }
                    return new UnmodifiableMAList<E>(
                        (MAList<E>)c);
                }
                if (c instanceof MASet<?>) {
                    if (c instanceof MAOrderedSet<?>) {
                        if (c instanceof MAOrderedSet.MAOrderedSetView<?>) {
                            if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
                                return new UnmodifiableMAOrderedMapMAOrderedKeySetView<E, Object>(
                                    (MAOrderedMap.MAOrderedKeySetView<E, Object>)c);
                            }
                            return new UnmodifiableMAOrderedSetMAOrderedSetView<E>(
                                (MAOrderedSet.MAOrderedSetView<E>)c);
                        }
                        return new UnmodifiableMAOrderedSet<E>(
                            (MAOrderedSet<E>)c);
                    }
                    if (c instanceof MASortedSet<?>) {
                        if (c instanceof MANavigableSet<?>) {
                            if (c instanceof MANavigableSet.MANavigableSetView<?>) {
                                if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                                    return new UnmodifiableMANavigableMapMANavigableKeySetView<E, Object>(
                                        (MANavigableMap.MANavigableKeySetView<E, Object>)c);
                                }
                                return new UnmodifiableMANavigableSetMANavigableSetView<E>(
                                    (MANavigableSet.MANavigableSetView<E>)c);
                            }
                            return new UnmodifiableMANavigableSet<E>(
                                (MANavigableSet<E>)c);
                        }
                        if (c instanceof MASortedSet.MASortedSetView<?>) {
                            if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
                                return new UnmodifiableMASortedMapMASortedKeySetView<E, Object>(
                                    (MASortedMap.MASortedKeySetView<E, Object>)c);
                            }
                            return new UnmodifiableMASortedSetMASortedSetView<E>(
                                (MASortedSet.MASortedSetView<E>)c);
                        }
                        return new UnmodifiableMASortedSet<E>(
                            (MASortedSet<E>)c);
                    }
                    if (c instanceof MAMap.MAEntrySetView<?, ?>) {
                        return new UnmodifiableMAMapMAEntrySetView(
                            (MAMap.MAEntrySetView)c);
                    }
                    if (c instanceof MAMap.MAKeySetView<?, ?>) {
                        return new UnmodifiableMAMapMAKeySetView<E, Object>(
                            (MAMap.MAKeySetView<E, Object>)c);
                    }
                    return new UnmodifiableMASet<E>(
                        (MASet<E>)c);
                }
                if (c instanceof MAMap.MAValuesView<?, ?>) {
                    return new UnmodifiableMAMapMAValuesView<Object, E>(
                        (MAMap.MAValuesView<Object, E>)c);
                }
                return new UnmodifiableMACollection<E>(
                    (MACollection<E>)c);
            }
            if (c instanceof XList<?>) {
                if (c instanceof XList.XListView<?>) {
                    return new UnmodifiableXListXListView<E>(
                        (XList.XListView<E>)c);
                }
                return new UnmodifiableXList<E>(
                    (XList<E>)c);
            }
            if (c instanceof XSet<?>) {
                if (c instanceof XOrderedSet<?>) {
                    if (c instanceof XOrderedSet.XOrderedSetView<?>) {
                        if (c instanceof XOrderedMap.XOrderedKeySetView<?>) {
                            return new UnmodifiableXOrderedMapXOrderedKeySetView<E>(
                                (XOrderedMap.XOrderedKeySetView<E>)c);
                        }
                        return new UnmodifiableXOrderedSetXOrderedSetView<E>(
                            (XOrderedSet.XOrderedSetView<E>)c);
                    }
                    return new UnmodifiableXOrderedSet<E>(
                        (XOrderedSet<E>)c);
                }
                if (c instanceof XSortedSet<?>) {
                    if (c instanceof XNavigableSet<?>) {
                        if (c instanceof XNavigableSet.XNavigableSetView<?>) {
                            if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
                                return new UnmodifiableXNavigableMapXNavigableKeySetView<E>(
                                    (XNavigableMap.XNavigableKeySetView<E>)c);
                            }
                            return new UnmodifiableXNavigableSetXNavigableSetView<E>(
                                (XNavigableSet.XNavigableSetView<E>)c);
                        }
                        return new UnmodifiableXNavigableSet<E>(
                            (XNavigableSet<E>)c);
                    }
                    if (c instanceof XSortedSet.XSortedSetView<?>) {
                        if (c instanceof XSortedMap.XSortedKeySetView<?>) {
                            return new UnmodifiableXSortedMapXSortedKeySetView<E>(
                                (XSortedMap.XSortedKeySetView<E>)c);
                        }
                        return new UnmodifiableXSortedSetXSortedSetView<E>(
                            (XSortedSet.XSortedSetView<E>)c);
                    }
                    return new UnmodifiableXSortedSet<E>(
                        (XSortedSet<E>)c);
                }
                if (c instanceof XMap.XKeySetView<?>) {
                    return new UnmodifiableXMapXKeySetView<E>(
                        (XMap.XKeySetView<E>)c);
                }
                if (c instanceof XMap.XEntrySetView<?, ?>) {
                    return new UnmodifiableXMapXEntrySetView(
                        (XMap.XEntrySetView)c);
                }
                return new UnmodifiableXSet<E>(
                    (XSet<E>)c);
            }
            if (c instanceof XMap.XValuesView<?>) {
                return new UnmodifiableXMapXValuesView<E>(
                    (XMap.XValuesView<E>)c);
            }
            return new UnmodifiableXCollection<E>(
                (XCollection<E>)c);
        }
        if (c instanceof Set<?>) {
            if (c instanceof StandardMap.EntrySet<?, ?>) {
                return new UnmodifiableStandardMapEntrySet(
                    (StandardMap.EntrySet)c);
            }
            if (c instanceof SortedSet<?>) {
                if (c instanceof NavigableSet<?>) {
                    return new UnmodifiableNavigableSet<E>(
                        (NavigableSet<E>)c);
                }
                return new UnmodifiableSortedSet<E>(
                    (SortedSet<E>)c);
            }
            return new UnmodifiableSet<E>(
                (Set<E>)c);
        }
        if (c instanceof List<?>) {
            return new UnmodifiableList<E>(
                (List<E>)c);
        }
        return new UnmodifiableCollection<E>(c);
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    public static <E> Set<E> unmodifiable(Set<E> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        Arguments.mustNotBeNull("c", c);
        if (c instanceof Serializable) {
            if (c instanceof MAOrderedSet<?>) {
                return new UnmodifiableMAOrderedSetWithSerializable<E>(
                    (MAOrderedSet<E>)c);
            }
            if (c instanceof MASortedSet<?>) {
                if (c instanceof MANavigableSet<?>) {
                    return new UnmodifiableMANavigableSetWithSerializable<E>(
                        (MANavigableSet<E>)c);
                }
                return new UnmodifiableMASortedSetWithSerializable<E>(
                    (MASortedSet<E>)c);
            }
            if (c instanceof MASet<?>) {
                return new UnmodifiableMASetWithSerializable<E>(
                    (MASet<E>)c);
            }
            if (c instanceof XSet<?>) {
                if (c instanceof XOrderedSet<?>) {
                    return new UnmodifiableXOrderedSetWithSerializable<E>(
                        (XOrderedSet<E>)c);
                }
                if (c instanceof XSortedSet<?>) {
                    if (c instanceof XNavigableSet<?>) {
                        return new UnmodifiableXNavigableSetWithSerializable<E>(
                            (XNavigableSet<E>)c);
                    }
                    return new UnmodifiableXSortedSetWithSerializable<E>(
                        (XSortedSet<E>)c);
                }
                return new UnmodifiableXSetWithSerializable<E>(
                    (XSet<E>)c);
            }
            if (c instanceof StandardMap.EntrySet<?, ?>) {
                return new UnmodifiableStandardMapEntrySetWithSerializable(
                    (StandardMap.EntrySet)c);
            }
            if (c instanceof SortedSet<?>) {
                if (c instanceof NavigableSet<?>) {
                    return new UnmodifiableNavigableSetWithSerializable<E>(
                        (NavigableSet<E>)c);
                }
                return new UnmodifiableSortedSetWithSerializable<E>(
                    (SortedSet<E>)c);
            }
            return new UnmodifiableSetWithSerializable<E>(c);
        }
        if (c instanceof MAOrderedSet<?>) {
            if (c instanceof MAOrderedSet.MAOrderedSetView<?>) {
                if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
                    return new UnmodifiableMAOrderedMapMAOrderedKeySetView<E, Object>(
                        (MAOrderedMap.MAOrderedKeySetView<E, Object>)c);
                }
                return new UnmodifiableMAOrderedSetMAOrderedSetView<E>(
                    (MAOrderedSet.MAOrderedSetView<E>)c);
            }
            return new UnmodifiableMAOrderedSet<E>(
                (MAOrderedSet<E>)c);
        }
        if (c instanceof MASortedSet<?>) {
            if (c instanceof MANavigableSet<?>) {
                if (c instanceof MANavigableSet.MANavigableSetView<?>) {
                    if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                        return new UnmodifiableMANavigableMapMANavigableKeySetView<E, Object>(
                            (MANavigableMap.MANavigableKeySetView<E, Object>)c);
                    }
                    return new UnmodifiableMANavigableSetMANavigableSetView<E>(
                        (MANavigableSet.MANavigableSetView<E>)c);
                }
                return new UnmodifiableMANavigableSet<E>(
                    (MANavigableSet<E>)c);
            }
            if (c instanceof MASortedSet.MASortedSetView<?>) {
                if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
                    return new UnmodifiableMASortedMapMASortedKeySetView<E, Object>(
                        (MASortedMap.MASortedKeySetView<E, Object>)c);
                }
                return new UnmodifiableMASortedSetMASortedSetView<E>(
                    (MASortedSet.MASortedSetView<E>)c);
            }
            return new UnmodifiableMASortedSet<E>(
                (MASortedSet<E>)c);
        }
        if (c instanceof MAMap.MAEntrySetView<?, ?>) {
            return new UnmodifiableMAMapMAEntrySetView(
                (MAMap.MAEntrySetView)c);
        }
        if (c instanceof MASet<?>) {
            if (c instanceof MAMap.MAKeySetView<?, ?>) {
                return new UnmodifiableMAMapMAKeySetView<E, Object>(
                    (MAMap.MAKeySetView<E, Object>)c);
            }
            return new UnmodifiableMASet<E>(
                (MASet<E>)c);
        }
        if (c instanceof XSet<?>) {
            if (c instanceof XOrderedSet<?>) {
                if (c instanceof XOrderedSet.XOrderedSetView<?>) {
                    if (c instanceof XOrderedMap.XOrderedKeySetView<?>) {
                        return new UnmodifiableXOrderedMapXOrderedKeySetView<E>(
                            (XOrderedMap.XOrderedKeySetView<E>)c);
                    }
                    return new UnmodifiableXOrderedSetXOrderedSetView<E>(
                        (XOrderedSet.XOrderedSetView<E>)c);
                }
                return new UnmodifiableXOrderedSet<E>(
                    (XOrderedSet<E>)c);
            }
            if (c instanceof XSortedSet<?>) {
                if (c instanceof XNavigableSet<?>) {
                    if (c instanceof XNavigableSet.XNavigableSetView<?>) {
                        if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
                            return new UnmodifiableXNavigableMapXNavigableKeySetView<E>(
                                (XNavigableMap.XNavigableKeySetView<E>)c);
                        }
                        return new UnmodifiableXNavigableSetXNavigableSetView<E>(
                            (XNavigableSet.XNavigableSetView<E>)c);
                    }
                    return new UnmodifiableXNavigableSet<E>(
                        (XNavigableSet<E>)c);
                }
                if (c instanceof XSortedSet.XSortedSetView<?>) {
                    if (c instanceof XSortedMap.XSortedKeySetView<?>) {
                        return new UnmodifiableXSortedMapXSortedKeySetView<E>(
                            (XSortedMap.XSortedKeySetView<E>)c);
                    }
                    return new UnmodifiableXSortedSetXSortedSetView<E>(
                        (XSortedSet.XSortedSetView<E>)c);
                }
                return new UnmodifiableXSortedSet<E>(
                    (XSortedSet<E>)c);
            }
            if (c instanceof XMap.XKeySetView<?>) {
                return new UnmodifiableXMapXKeySetView<E>(
                    (XMap.XKeySetView<E>)c);
            }
            if (c instanceof XMap.XEntrySetView<?, ?>) {
                return new UnmodifiableXMapXEntrySetView(
                    (XMap.XEntrySetView)c);
            }
            return new UnmodifiableXSet<E>(
                (XSet<E>)c);
        }
        if (c instanceof StandardMap.EntrySet<?, ?>) {
            return new UnmodifiableStandardMapEntrySet(
                (StandardMap.EntrySet)c);
        }
        if (c instanceof SortedSet<?>) {
            if (c instanceof NavigableSet<?>) {
                return new UnmodifiableNavigableSet<E>(
                    (NavigableSet<E>)c);
            }
            return new UnmodifiableSortedSet<E>(
                (SortedSet<E>)c);
        }
        return new UnmodifiableSet<E>(c);
    }

    @SuppressWarnings("unchecked")
    public static <E> SortedSet<E> unmodifiable(SortedSet<E> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        Arguments.mustNotBeNull("c", c);
        if (c instanceof Serializable) {
            if (c instanceof MASortedSet<?>) {
                if (c instanceof MANavigableSet<?>) {
                    return new UnmodifiableMANavigableSetWithSerializable<E>(
                        (MANavigableSet<E>)c);
                }
                return new UnmodifiableMASortedSetWithSerializable<E>(
                    (MASortedSet<E>)c);
            }
            if (c instanceof XSortedSet<?>) {
                if (c instanceof XNavigableSet<?>) {
                    return new UnmodifiableXNavigableSetWithSerializable<E>(
                        (XNavigableSet<E>)c);
                }
                return new UnmodifiableXSortedSetWithSerializable<E>(
                    (XSortedSet<E>)c);
            }
            if (c instanceof NavigableSet<?>) {
                return new UnmodifiableNavigableSetWithSerializable<E>(
                    (NavigableSet<E>)c);
            }
            return new UnmodifiableSortedSetWithSerializable<E>(c);
        }
        if (c instanceof MASortedSet<?>) {
            if (c instanceof MANavigableSet<?>) {
                if (c instanceof MANavigableSet.MANavigableSetView<?>) {
                    if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                        return new UnmodifiableMANavigableMapMANavigableKeySetView<E, Object>(
                            (MANavigableMap.MANavigableKeySetView<E, Object>)c);
                    }
                    return new UnmodifiableMANavigableSetMANavigableSetView<E>(
                        (MANavigableSet.MANavigableSetView<E>)c);
                }
                return new UnmodifiableMANavigableSet<E>(
                    (MANavigableSet<E>)c);
            }
            if (c instanceof MASortedSet.MASortedSetView<?>) {
                if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
                    return new UnmodifiableMASortedMapMASortedKeySetView<E, Object>(
                        (MASortedMap.MASortedKeySetView<E, Object>)c);
                }
                return new UnmodifiableMASortedSetMASortedSetView<E>(
                    (MASortedSet.MASortedSetView<E>)c);
            }
            return new UnmodifiableMASortedSet<E>(
                (MASortedSet<E>)c);
        }
        if (c instanceof XSortedSet<?>) {
            if (c instanceof XNavigableSet<?>) {
                if (c instanceof XNavigableSet.XNavigableSetView<?>) {
                    if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
                        return new UnmodifiableXNavigableMapXNavigableKeySetView<E>(
                            (XNavigableMap.XNavigableKeySetView<E>)c);
                    }
                    return new UnmodifiableXNavigableSetXNavigableSetView<E>(
                        (XNavigableSet.XNavigableSetView<E>)c);
                }
                return new UnmodifiableXNavigableSet<E>(
                    (XNavigableSet<E>)c);
            }
            if (c instanceof XSortedSet.XSortedSetView<?>) {
                if (c instanceof XSortedMap.XSortedKeySetView<?>) {
                    return new UnmodifiableXSortedMapXSortedKeySetView<E>(
                        (XSortedMap.XSortedKeySetView<E>)c);
                }
                return new UnmodifiableXSortedSetXSortedSetView<E>(
                    (XSortedSet.XSortedSetView<E>)c);
            }
            return new UnmodifiableXSortedSet<E>(
                (XSortedSet<E>)c);
        }
        if (c instanceof NavigableSet<?>) {
            return new UnmodifiableNavigableSet<E>(
                (NavigableSet<E>)c);
        }
        return new UnmodifiableSortedSet<E>(c);
    }

    @SuppressWarnings("unchecked")
    public static <E> NavigableSet<E> unmodifiable(NavigableSet<E> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        Arguments.mustNotBeNull("c", c);
        if (c instanceof Serializable) {
            if (c instanceof MANavigableSet<?>) {
                return new UnmodifiableMANavigableSetWithSerializable<E>(
                    (MANavigableSet<E>)c);
            }
            if (c instanceof XNavigableSet<?>) {
                return new UnmodifiableXNavigableSetWithSerializable<E>(
                    (XNavigableSet<E>)c);
            }
            return new UnmodifiableNavigableSetWithSerializable<E>(c);
        }
        if (c instanceof MANavigableSet<?>) {
            if (c instanceof MANavigableSet.MANavigableSetView<?>) {
                if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                    return new UnmodifiableMANavigableMapMANavigableKeySetView<E, Object>(
                        (MANavigableMap.MANavigableKeySetView<E, Object>)c);
                }
                return new UnmodifiableMANavigableSetMANavigableSetView<E>(
                    (MANavigableSet.MANavigableSetView<E>)c);
            }
            return new UnmodifiableMANavigableSet<E>(
                (MANavigableSet<E>)c);
        }
        if (c instanceof XNavigableSet<?>) {
            if (c instanceof XNavigableSet.XNavigableSetView<?>) {
                if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
                    return new UnmodifiableXNavigableMapXNavigableKeySetView<E>(
                        (XNavigableMap.XNavigableKeySetView<E>)c);
                }
                return new UnmodifiableXNavigableSetXNavigableSetView<E>(
                    (XNavigableSet.XNavigableSetView<E>)c);
            }
            return new UnmodifiableXNavigableSet<E>(
                (XNavigableSet<E>)c);
        }
        return new UnmodifiableNavigableSet<E>(c);
    }

    public static <E> List<E> unmodifiable(List<E> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        Arguments.mustNotBeNull("c", c);
        if (c instanceof Serializable) {
            if (c instanceof RandomAccess) {
                if (c instanceof MAList<?>) {
                    return new UnmodifiableMAListWithSerializableRandomAccess<E>(
                        (MAList<E>)c);
                }
                if (c instanceof XList<?>) {
                    return new UnmodifiableXListWithSerializableRandomAccess<E>(
                        (XList<E>)c);
                }
                return new UnmodifiableListWithSerializableRandomAccess<E>(c);
            }
            if (c instanceof MAList<?>) {
                return new UnmodifiableMAListWithSerializable<E>(
                    (MAList<E>)c);
            }
            if (c instanceof XList<?>) {
                return new UnmodifiableXListWithSerializable<E>(
                    (XList<E>)c);
            }
            return new UnmodifiableListWithSerializable<E>(c);
        }
        if (c instanceof RandomAccess) {
            if (c instanceof MAList<?>) {
                if (c instanceof MAList.MAListView<?>) {
                    return new UnmodifiableMAListMAListViewWithRandomAccess<E>(
                        (MAList.MAListView<E>)c);
                }
                return new UnmodifiableMAListWithRandomAccess<E>(
                    (MAList<E>)c);
            }
            if (c instanceof XList<?>) {
                if (c instanceof XList.XListView<?>) {
                    return new UnmodifiableXListXListViewWithRandomAccess<E>(
                        (XList.XListView<E>)c);
                }
                return new UnmodifiableXListWithRandomAccess<E>(
                    (XList<E>)c);
            }
            return new UnmodifiableListWithRandomAccess<E>(c);
        }
        if (c instanceof MAList<?>) {
            if (c instanceof MAList.MAListView<?>) {
                return new UnmodifiableMAListMAListView<E>(
                    (MAList.MAListView<E>)c);
            }
            return new UnmodifiableMAList<E>(
                (MAList<E>)c);
        }
        if (c instanceof XList<?>) {
            if (c instanceof XList.XListView<?>) {
                return new UnmodifiableXListXListView<E>(
                    (XList.XListView<E>)c);
            }
            return new UnmodifiableXList<E>(
                (XList<E>)c);
        }
        return new UnmodifiableList<E>(c);
    }

    private static <K, V> StandardMap.EntrySet<K, V> unmodifiable(StandardMap.EntrySet<K, V> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        if (c instanceof Serializable) {
            return new UnmodifiableStandardMapEntrySetWithSerializable<K, V>(c);
        }
        return new UnmodifiableStandardMapEntrySet<K, V>(c);
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    public static <E> XCollection<E> unmodifiable(XCollection<E> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        Arguments.mustNotBeNull("c", c);
        if (c instanceof Serializable) {
            if (c instanceof MACollection<?>) {
                if (c instanceof MAList<?>) {
                    return new UnmodifiableMAListWithSerializable<E>(
                        (MAList<E>)c);
                }
                if (c instanceof MASet<?>) {
                    if (c instanceof MAOrderedSet<?>) {
                        return new UnmodifiableMAOrderedSetWithSerializable<E>(
                            (MAOrderedSet<E>)c);
                    }
                    if (c instanceof MASortedSet<?>) {
                        if (c instanceof MANavigableSet<?>) {
                            return new UnmodifiableMANavigableSetWithSerializable<E>(
                                (MANavigableSet<E>)c);
                        }
                        return new UnmodifiableMASortedSetWithSerializable<E>(
                            (MASortedSet<E>)c);
                    }
                    return new UnmodifiableMASetWithSerializable<E>(
                        (MASet<E>)c);
                }
                return new UnmodifiableMACollectionWithSerializable<E>(
                    (MACollection<E>)c);
            }
            if (c instanceof XList<?>) {
                return new UnmodifiableXListWithSerializable<E>(
                    (XList<E>)c);
            }
            if (c instanceof XSet<?>) {
                if (c instanceof XOrderedSet<?>) {
                    return new UnmodifiableXOrderedSetWithSerializable<E>(
                        (XOrderedSet<E>)c);
                }
                if (c instanceof XSortedSet<?>) {
                    if (c instanceof XNavigableSet<?>) {
                        return new UnmodifiableXNavigableSetWithSerializable<E>(
                            (XNavigableSet<E>)c);
                    }
                    return new UnmodifiableXSortedSetWithSerializable<E>(
                        (XSortedSet<E>)c);
                }
                return new UnmodifiableXSetWithSerializable<E>(
                    (XSet<E>)c);
            }
            return new UnmodifiableXCollectionWithSerializable<E>(c);
        }
        if (c instanceof MACollection<?>) {
            if (c instanceof MAList<?>) {
                if (c instanceof MAList.MAListView<?>) {
                    return new UnmodifiableMAListMAListView<E>(
                        (MAList.MAListView<E>)c);
                }
                return new UnmodifiableMAList<E>(
                    (MAList<E>)c);
            }
            if (c instanceof MASet<?>) {
                if (c instanceof MAOrderedSet<?>) {
                    if (c instanceof MAOrderedSet.MAOrderedSetView<?>) {
                        if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
                            return new UnmodifiableMAOrderedMapMAOrderedKeySetView<E, Object>(
                                (MAOrderedMap.MAOrderedKeySetView<E, Object>)c);
                        }
                        return new UnmodifiableMAOrderedSetMAOrderedSetView<E>(
                            (MAOrderedSet.MAOrderedSetView<E>)c);
                    }
                    return new UnmodifiableMAOrderedSet<E>(
                        (MAOrderedSet<E>)c);
                }
                if (c instanceof MASortedSet<?>) {
                    if (c instanceof MANavigableSet<?>) {
                        if (c instanceof MANavigableSet.MANavigableSetView<?>) {
                            if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                                return new UnmodifiableMANavigableMapMANavigableKeySetView<E, Object>(
                                    (MANavigableMap.MANavigableKeySetView<E, Object>)c);
                            }
                            return new UnmodifiableMANavigableSetMANavigableSetView<E>(
                                (MANavigableSet.MANavigableSetView<E>)c);
                        }
                        return new UnmodifiableMANavigableSet<E>(
                            (MANavigableSet<E>)c);
                    }
                    if (c instanceof MASortedSet.MASortedSetView<?>) {
                        if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
                            return new UnmodifiableMASortedMapMASortedKeySetView<E, Object>(
                                (MASortedMap.MASortedKeySetView<E, Object>)c);
                        }
                        return new UnmodifiableMASortedSetMASortedSetView<E>(
                            (MASortedSet.MASortedSetView<E>)c);
                    }
                    return new UnmodifiableMASortedSet<E>(
                        (MASortedSet<E>)c);
                }
                if (c instanceof MAMap.MAEntrySetView<?, ?>) {
                    return new UnmodifiableMAMapMAEntrySetView(
                        (MAMap.MAEntrySetView)c);
                }
                if (c instanceof MAMap.MAKeySetView<?, ?>) {
                    return new UnmodifiableMAMapMAKeySetView<E, Object>(
                        (MAMap.MAKeySetView<E, Object>)c);
                }
                return new UnmodifiableMASet<E>(
                    (MASet<E>)c);
            }
            if (c instanceof MAMap.MAValuesView<?, ?>) {
                return new UnmodifiableMAMapMAValuesView<Object, E>(
                    (MAMap.MAValuesView<Object, E>)c);
            }
            return new UnmodifiableMACollection<E>(
                (MACollection<E>)c);
        }
        if (c instanceof XList<?>) {
            if (c instanceof XList.XListView<?>) {
                return new UnmodifiableXListXListView<E>(
                    (XList.XListView<E>)c);
            }
            return new UnmodifiableXList<E>(
                (XList<E>)c);
        }
        if (c instanceof XSet<?>) {
            if (c instanceof XOrderedSet<?>) {
                if (c instanceof XOrderedSet.XOrderedSetView<?>) {
                    if (c instanceof XOrderedMap.XOrderedKeySetView<?>) {
                        return new UnmodifiableXOrderedMapXOrderedKeySetView<E>(
                            (XOrderedMap.XOrderedKeySetView<E>)c);
                    }
                    return new UnmodifiableXOrderedSetXOrderedSetView<E>(
                        (XOrderedSet.XOrderedSetView<E>)c);
                }
                return new UnmodifiableXOrderedSet<E>(
                    (XOrderedSet<E>)c);
            }
            if (c instanceof XSortedSet<?>) {
                if (c instanceof XNavigableSet<?>) {
                    if (c instanceof XNavigableSet.XNavigableSetView<?>) {
                        if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
                            return new UnmodifiableXNavigableMapXNavigableKeySetView<E>(
                                (XNavigableMap.XNavigableKeySetView<E>)c);
                        }
                        return new UnmodifiableXNavigableSetXNavigableSetView<E>(
                            (XNavigableSet.XNavigableSetView<E>)c);
                    }
                    return new UnmodifiableXNavigableSet<E>(
                        (XNavigableSet<E>)c);
                }
                if (c instanceof XSortedSet.XSortedSetView<?>) {
                    if (c instanceof XSortedMap.XSortedKeySetView<?>) {
                        return new UnmodifiableXSortedMapXSortedKeySetView<E>(
                            (XSortedMap.XSortedKeySetView<E>)c);
                    }
                    return new UnmodifiableXSortedSetXSortedSetView<E>(
                        (XSortedSet.XSortedSetView<E>)c);
                }
                return new UnmodifiableXSortedSet<E>(
                    (XSortedSet<E>)c);
            }
            if (c instanceof XMap.XKeySetView<?>) {
                return new UnmodifiableXMapXKeySetView<E>(
                    (XMap.XKeySetView<E>)c);
            }
            if (c instanceof XMap.XEntrySetView<?, ?>) {
                return new UnmodifiableXMapXEntrySetView(
                    (XMap.XEntrySetView)c);
            }
            return new UnmodifiableXSet<E>(
                (XSet<E>)c);
        }
        if (c instanceof XMap.XValuesView<?>) {
            return new UnmodifiableXMapXValuesView<E>(
                (XMap.XValuesView<E>)c);
        }
        return new UnmodifiableXCollection<E>(c);
    }

    @SuppressWarnings("unchecked")
    public static <V> XMap.XValuesView<V> unmodifiable(XMap.XValuesView<V> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        Arguments.mustNotBeNull("c", c);
        if (c instanceof MAMap.MAValuesView<?, ?>) {
            return new UnmodifiableMAMapMAValuesView<Object, V>(
                (MAMap.MAValuesView<Object, V>)c);
        }
        return new UnmodifiableXMapXValuesView<V>(c);
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    public static <E> XSet<E> unmodifiable(XSet<E> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        Arguments.mustNotBeNull("c", c);
        if (c instanceof Serializable) {
            if (c instanceof MAOrderedSet<?>) {
                return new UnmodifiableMAOrderedSetWithSerializable<E>(
                    (MAOrderedSet<E>)c);
            }
            if (c instanceof MASortedSet<?>) {
                if (c instanceof MANavigableSet<?>) {
                    return new UnmodifiableMANavigableSetWithSerializable<E>(
                        (MANavigableSet<E>)c);
                }
                return new UnmodifiableMASortedSetWithSerializable<E>(
                    (MASortedSet<E>)c);
            }
            if (c instanceof MASet<?>) {
                return new UnmodifiableMASetWithSerializable<E>(
                    (MASet<E>)c);
            }
            if (c instanceof XOrderedSet<?>) {
                return new UnmodifiableXOrderedSetWithSerializable<E>(
                    (XOrderedSet<E>)c);
            }
            if (c instanceof XSortedSet<?>) {
                if (c instanceof XNavigableSet<?>) {
                    return new UnmodifiableXNavigableSetWithSerializable<E>(
                        (XNavigableSet<E>)c);
                }
                return new UnmodifiableXSortedSetWithSerializable<E>(
                    (XSortedSet<E>)c);
            }
            return new UnmodifiableXSetWithSerializable<E>(c);
        }
        if (c instanceof MAOrderedSet<?>) {
            if (c instanceof MAOrderedSet.MAOrderedSetView<?>) {
                if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
                    return new UnmodifiableMAOrderedMapMAOrderedKeySetView<E, Object>(
                        (MAOrderedMap.MAOrderedKeySetView<E, Object>)c);
                }
                return new UnmodifiableMAOrderedSetMAOrderedSetView<E>(
                    (MAOrderedSet.MAOrderedSetView<E>)c);
            }
            return new UnmodifiableMAOrderedSet<E>(
                (MAOrderedSet<E>)c);
        }
        if (c instanceof MASortedSet<?>) {
            if (c instanceof MANavigableSet<?>) {
                if (c instanceof MANavigableSet.MANavigableSetView<?>) {
                    if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                        return new UnmodifiableMANavigableMapMANavigableKeySetView<E, Object>(
                            (MANavigableMap.MANavigableKeySetView<E, Object>)c);
                    }
                    return new UnmodifiableMANavigableSetMANavigableSetView<E>(
                        (MANavigableSet.MANavigableSetView<E>)c);
                }
                return new UnmodifiableMANavigableSet<E>(
                    (MANavigableSet<E>)c);
            }
            if (c instanceof MASortedSet.MASortedSetView<?>) {
                if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
                    return new UnmodifiableMASortedMapMASortedKeySetView<E, Object>(
                        (MASortedMap.MASortedKeySetView<E, Object>)c);
                }
                return new UnmodifiableMASortedSetMASortedSetView<E>(
                    (MASortedSet.MASortedSetView<E>)c);
            }
            return new UnmodifiableMASortedSet<E>(
                (MASortedSet<E>)c);
        }
        if (c instanceof MAMap.MAEntrySetView<?, ?>) {
            return new UnmodifiableMAMapMAEntrySetView(
                (MAMap.MAEntrySetView)c);
        }
        if (c instanceof MASet<?>) {
            if (c instanceof MAMap.MAKeySetView<?, ?>) {
                return new UnmodifiableMAMapMAKeySetView<E, Object>(
                    (MAMap.MAKeySetView<E, Object>)c);
            }
            return new UnmodifiableMASet<E>(
                (MASet<E>)c);
        }
        if (c instanceof XOrderedSet<?>) {
            if (c instanceof XOrderedSet.XOrderedSetView<?>) {
                if (c instanceof XOrderedMap.XOrderedKeySetView<?>) {
                    return new UnmodifiableXOrderedMapXOrderedKeySetView<E>(
                        (XOrderedMap.XOrderedKeySetView<E>)c);
                }
                return new UnmodifiableXOrderedSetXOrderedSetView<E>(
                    (XOrderedSet.XOrderedSetView<E>)c);
            }
            return new UnmodifiableXOrderedSet<E>(
                (XOrderedSet<E>)c);
        }
        if (c instanceof XSortedSet<?>) {
            if (c instanceof XNavigableSet<?>) {
                if (c instanceof XNavigableSet.XNavigableSetView<?>) {
                    if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
                        return new UnmodifiableXNavigableMapXNavigableKeySetView<E>(
                            (XNavigableMap.XNavigableKeySetView<E>)c);
                    }
                    return new UnmodifiableXNavigableSetXNavigableSetView<E>(
                        (XNavigableSet.XNavigableSetView<E>)c);
                }
                return new UnmodifiableXNavigableSet<E>(
                    (XNavigableSet<E>)c);
            }
            if (c instanceof XSortedSet.XSortedSetView<?>) {
                if (c instanceof XSortedMap.XSortedKeySetView<?>) {
                    return new UnmodifiableXSortedMapXSortedKeySetView<E>(
                        (XSortedMap.XSortedKeySetView<E>)c);
                }
                return new UnmodifiableXSortedSetXSortedSetView<E>(
                    (XSortedSet.XSortedSetView<E>)c);
            }
            return new UnmodifiableXSortedSet<E>(
                (XSortedSet<E>)c);
        }
        if (c instanceof XMap.XKeySetView<?>) {
            return new UnmodifiableXMapXKeySetView<E>(
                (XMap.XKeySetView<E>)c);
        }
        if (c instanceof XMap.XEntrySetView<?, ?>) {
            return new UnmodifiableXMapXEntrySetView(
                (XMap.XEntrySetView)c);
        }
        return new UnmodifiableXSet<E>(c);
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    public static <K, V> XMap.XEntrySetView<K, V> unmodifiable(XMap.XEntrySetView<K, V> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        Arguments.mustNotBeNull("c", c);
        if (c instanceof MAMap.MAEntrySetView<?, ?>) {
            return new UnmodifiableMAMapMAEntrySetView(
                (MAMap.MAEntrySetView)c);
        }
        return new UnmodifiableXMapXEntrySetView<K, V>(c);
    }

    @SuppressWarnings("unchecked")
    public static <K> XMap.XKeySetView<K> unmodifiable(XMap.XKeySetView<K> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        Arguments.mustNotBeNull("c", c);
        if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
            return new UnmodifiableMAOrderedMapMAOrderedKeySetView<K, Object>(
                (MAOrderedMap.MAOrderedKeySetView<K, Object>)c);
        }
        if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
            return new UnmodifiableMANavigableMapMANavigableKeySetView<K, Object>(
                (MANavigableMap.MANavigableKeySetView<K, Object>)c);
        }
        if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
            return new UnmodifiableMASortedMapMASortedKeySetView<K, Object>(
                (MASortedMap.MASortedKeySetView<K, Object>)c);
        }
        if (c instanceof MAMap.MAKeySetView<?, ?>) {
            return new UnmodifiableMAMapMAKeySetView<K, Object>(
                (MAMap.MAKeySetView<K, Object>)c);
        }
        if (c instanceof XOrderedMap.XOrderedKeySetView<?>) {
            return new UnmodifiableXOrderedMapXOrderedKeySetView<K>(
                (XOrderedMap.XOrderedKeySetView<K>)c);
        }
        if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
            return new UnmodifiableXNavigableMapXNavigableKeySetView<K>(
                (XNavigableMap.XNavigableKeySetView<K>)c);
        }
        if (c instanceof XSortedMap.XSortedKeySetView<?>) {
            return new UnmodifiableXSortedMapXSortedKeySetView<K>(
                (XSortedMap.XSortedKeySetView<K>)c);
        }
        return new UnmodifiableXMapXKeySetView<K>(c);
    }

    @SuppressWarnings("unchecked")
    public static <E> XSortedSet<E> unmodifiable(XSortedSet<E> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        Arguments.mustNotBeNull("c", c);
        if (c instanceof Serializable) {
            if (c instanceof MASortedSet<?>) {
                if (c instanceof MANavigableSet<?>) {
                    return new UnmodifiableMANavigableSetWithSerializable<E>(
                        (MANavigableSet<E>)c);
                }
                return new UnmodifiableMASortedSetWithSerializable<E>(
                    (MASortedSet<E>)c);
            }
            if (c instanceof XNavigableSet<?>) {
                return new UnmodifiableXNavigableSetWithSerializable<E>(
                    (XNavigableSet<E>)c);
            }
            return new UnmodifiableXSortedSetWithSerializable<E>(c);
        }
        if (c instanceof MASortedSet<?>) {
            if (c instanceof MANavigableSet<?>) {
                if (c instanceof MANavigableSet.MANavigableSetView<?>) {
                    if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                        return new UnmodifiableMANavigableMapMANavigableKeySetView<E, Object>(
                            (MANavigableMap.MANavigableKeySetView<E, Object>)c);
                    }
                    return new UnmodifiableMANavigableSetMANavigableSetView<E>(
                        (MANavigableSet.MANavigableSetView<E>)c);
                }
                return new UnmodifiableMANavigableSet<E>(
                    (MANavigableSet<E>)c);
            }
            if (c instanceof MASortedSet.MASortedSetView<?>) {
                if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
                    return new UnmodifiableMASortedMapMASortedKeySetView<E, Object>(
                        (MASortedMap.MASortedKeySetView<E, Object>)c);
                }
                return new UnmodifiableMASortedSetMASortedSetView<E>(
                    (MASortedSet.MASortedSetView<E>)c);
            }
            return new UnmodifiableMASortedSet<E>(
                (MASortedSet<E>)c);
        }
        if (c instanceof XNavigableSet<?>) {
            if (c instanceof XNavigableSet.XNavigableSetView<?>) {
                if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
                    return new UnmodifiableXNavigableMapXNavigableKeySetView<E>(
                        (XNavigableMap.XNavigableKeySetView<E>)c);
                }
                return new UnmodifiableXNavigableSetXNavigableSetView<E>(
                    (XNavigableSet.XNavigableSetView<E>)c);
            }
            return new UnmodifiableXNavigableSet<E>(
                (XNavigableSet<E>)c);
        }
        if (c instanceof XSortedSet.XSortedSetView<?>) {
            if (c instanceof XSortedMap.XSortedKeySetView<?>) {
                return new UnmodifiableXSortedMapXSortedKeySetView<E>(
                    (XSortedMap.XSortedKeySetView<E>)c);
            }
            return new UnmodifiableXSortedSetXSortedSetView<E>(
                (XSortedSet.XSortedSetView<E>)c);
        }
        return new UnmodifiableXSortedSet<E>(c);
    }

    @SuppressWarnings("unchecked")
    public static <E> XSortedSet.XSortedSetView<E> unmodifiable(XSortedSet.XSortedSetView<E> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        Arguments.mustNotBeNull("c", c);
        if (c instanceof MANavigableSet.MANavigableSetView<?>) {
            if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                return new UnmodifiableMANavigableMapMANavigableKeySetView<E, Object>(
                    (MANavigableMap.MANavigableKeySetView<E, Object>)c);
            }
            return new UnmodifiableMANavigableSetMANavigableSetView<E>(
                (MANavigableSet.MANavigableSetView<E>)c);
        }
        if (c instanceof MASortedSet.MASortedSetView<?>) {
            if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
                return new UnmodifiableMASortedMapMASortedKeySetView<E, Object>(
                    (MASortedMap.MASortedKeySetView<E, Object>)c);
            }
            return new UnmodifiableMASortedSetMASortedSetView<E>(
                (MASortedSet.MASortedSetView<E>)c);
        }
        if (c instanceof XNavigableSet.XNavigableSetView<?>) {
            if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
                return new UnmodifiableXNavigableMapXNavigableKeySetView<E>(
                    (XNavigableMap.XNavigableKeySetView<E>)c);
            }
            return new UnmodifiableXNavigableSetXNavigableSetView<E>(
                (XNavigableSet.XNavigableSetView<E>)c);
        }
        if (c instanceof XSortedMap.XSortedKeySetView<?>) {
            return new UnmodifiableXSortedMapXSortedKeySetView<E>(
                (XSortedMap.XSortedKeySetView<E>)c);
        }
        return new UnmodifiableXSortedSetXSortedSetView<E>(c);
    }

    @SuppressWarnings("unchecked")
    public static <K> XSortedMap.XSortedKeySetView<K> unmodifiable(XSortedMap.XSortedKeySetView<K> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        Arguments.mustNotBeNull("c", c);
        if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
            return new UnmodifiableMANavigableMapMANavigableKeySetView<K, Object>(
                (MANavigableMap.MANavigableKeySetView<K, Object>)c);
        }
        if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
            return new UnmodifiableMASortedMapMASortedKeySetView<K, Object>(
                (MASortedMap.MASortedKeySetView<K, Object>)c);
        }
        if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
            return new UnmodifiableXNavigableMapXNavigableKeySetView<K>(
                (XNavigableMap.XNavigableKeySetView<K>)c);
        }
        return new UnmodifiableXSortedMapXSortedKeySetView<K>(c);
    }

    @SuppressWarnings("unchecked")
    public static <E> XNavigableSet<E> unmodifiable(XNavigableSet<E> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        Arguments.mustNotBeNull("c", c);
        if (c instanceof Serializable) {
            if (c instanceof MANavigableSet<?>) {
                return new UnmodifiableMANavigableSetWithSerializable<E>(
                    (MANavigableSet<E>)c);
            }
            return new UnmodifiableXNavigableSetWithSerializable<E>(c);
        }
        if (c instanceof MANavigableSet<?>) {
            if (c instanceof MANavigableSet.MANavigableSetView<?>) {
                if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                    return new UnmodifiableMANavigableMapMANavigableKeySetView<E, Object>(
                        (MANavigableMap.MANavigableKeySetView<E, Object>)c);
                }
                return new UnmodifiableMANavigableSetMANavigableSetView<E>(
                    (MANavigableSet.MANavigableSetView<E>)c);
            }
            return new UnmodifiableMANavigableSet<E>(
                (MANavigableSet<E>)c);
        }
        if (c instanceof XNavigableSet.XNavigableSetView<?>) {
            if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
                return new UnmodifiableXNavigableMapXNavigableKeySetView<E>(
                    (XNavigableMap.XNavigableKeySetView<E>)c);
            }
            return new UnmodifiableXNavigableSetXNavigableSetView<E>(
                (XNavigableSet.XNavigableSetView<E>)c);
        }
        return new UnmodifiableXNavigableSet<E>(c);
    }

    @SuppressWarnings("unchecked")
    public static <E> XNavigableSet.XNavigableSetView<E> unmodifiable(XNavigableSet.XNavigableSetView<E> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        Arguments.mustNotBeNull("c", c);
        if (c instanceof MANavigableSet.MANavigableSetView<?>) {
            if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                return new UnmodifiableMANavigableMapMANavigableKeySetView<E, Object>(
                    (MANavigableMap.MANavigableKeySetView<E, Object>)c);
            }
            return new UnmodifiableMANavigableSetMANavigableSetView<E>(
                (MANavigableSet.MANavigableSetView<E>)c);
        }
        if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
            return new UnmodifiableXNavigableMapXNavigableKeySetView<E>(
                (XNavigableMap.XNavigableKeySetView<E>)c);
        }
        return new UnmodifiableXNavigableSetXNavigableSetView<E>(c);
    }

    @SuppressWarnings("unchecked")
    public static <K> XNavigableMap.XNavigableKeySetView<K> unmodifiable(XNavigableMap.XNavigableKeySetView<K> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        Arguments.mustNotBeNull("c", c);
        if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
            return new UnmodifiableMANavigableMapMANavigableKeySetView<K, Object>(
                (MANavigableMap.MANavigableKeySetView<K, Object>)c);
        }
        return new UnmodifiableXNavigableMapXNavigableKeySetView<K>(c);
    }

    @SuppressWarnings("unchecked")
    public static <E> XOrderedSet<E> unmodifiable(XOrderedSet<E> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        Arguments.mustNotBeNull("c", c);
        if (c instanceof Serializable) {
            if (c instanceof MAOrderedSet<?>) {
                return new UnmodifiableMAOrderedSetWithSerializable<E>(
                    (MAOrderedSet<E>)c);
            }
            return new UnmodifiableXOrderedSetWithSerializable<E>(c);
        }
        if (c instanceof MAOrderedSet<?>) {
            if (c instanceof MAOrderedSet.MAOrderedSetView<?>) {
                if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
                    return new UnmodifiableMAOrderedMapMAOrderedKeySetView<E, Object>(
                        (MAOrderedMap.MAOrderedKeySetView<E, Object>)c);
                }
                return new UnmodifiableMAOrderedSetMAOrderedSetView<E>(
                    (MAOrderedSet.MAOrderedSetView<E>)c);
            }
            return new UnmodifiableMAOrderedSet<E>(
                (MAOrderedSet<E>)c);
        }
        if (c instanceof XOrderedSet.XOrderedSetView<?>) {
            if (c instanceof XOrderedMap.XOrderedKeySetView<?>) {
                return new UnmodifiableXOrderedMapXOrderedKeySetView<E>(
                    (XOrderedMap.XOrderedKeySetView<E>)c);
            }
            return new UnmodifiableXOrderedSetXOrderedSetView<E>(
                (XOrderedSet.XOrderedSetView<E>)c);
        }
        return new UnmodifiableXOrderedSet<E>(c);
    }

    @SuppressWarnings("unchecked")
    public static <E> XOrderedSet.XOrderedSetView<E> unmodifiable(XOrderedSet.XOrderedSetView<E> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        Arguments.mustNotBeNull("c", c);
        if (c instanceof MAOrderedSet.MAOrderedSetView<?>) {
            if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
                return new UnmodifiableMAOrderedMapMAOrderedKeySetView<E, Object>(
                    (MAOrderedMap.MAOrderedKeySetView<E, Object>)c);
            }
            return new UnmodifiableMAOrderedSetMAOrderedSetView<E>(
                (MAOrderedSet.MAOrderedSetView<E>)c);
        }
        if (c instanceof XOrderedMap.XOrderedKeySetView<?>) {
            return new UnmodifiableXOrderedMapXOrderedKeySetView<E>(
                (XOrderedMap.XOrderedKeySetView<E>)c);
        }
        return new UnmodifiableXOrderedSetXOrderedSetView<E>(c);
    }

    @SuppressWarnings("unchecked")
    public static <K> XOrderedMap.XOrderedKeySetView<K> unmodifiable(XOrderedMap.XOrderedKeySetView<K> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        Arguments.mustNotBeNull("c", c);
        if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
            return new UnmodifiableMAOrderedMapMAOrderedKeySetView<K, Object>(
                (MAOrderedMap.MAOrderedKeySetView<K, Object>)c);
        }
        return new UnmodifiableXOrderedMapXOrderedKeySetView<K>(c);
    }

    public static <E> XList<E> unmodifiable(XList<E> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        Arguments.mustNotBeNull("c", c);
        if (c instanceof Serializable) {
            if (c instanceof RandomAccess) {
                if (c instanceof MAList<?>) {
                    return new UnmodifiableMAListWithSerializableRandomAccess<E>(
                        (MAList<E>)c);
                }
                return new UnmodifiableXListWithSerializableRandomAccess<E>(c);
            }
            if (c instanceof MAList<?>) {
                return new UnmodifiableMAListWithSerializable<E>(
                    (MAList<E>)c);
            }
            return new UnmodifiableXListWithSerializable<E>(c);
        }
        if (c instanceof RandomAccess) {
            if (c instanceof MAList<?>) {
                if (c instanceof MAList.MAListView<?>) {
                    return new UnmodifiableMAListMAListViewWithRandomAccess<E>(
                        (MAList.MAListView<E>)c);
                }
                return new UnmodifiableMAListWithRandomAccess<E>(
                    (MAList<E>)c);
            }
            if (c instanceof XList.XListView<?>) {
                return new UnmodifiableXListXListViewWithRandomAccess<E>(
                    (XList.XListView<E>)c);
            }
            return new UnmodifiableXListWithRandomAccess<E>(c);
        }
        if (c instanceof MAList<?>) {
            if (c instanceof MAList.MAListView<?>) {
                return new UnmodifiableMAListMAListView<E>(
                    (MAList.MAListView<E>)c);
            }
            return new UnmodifiableMAList<E>(
                (MAList<E>)c);
        }
        if (c instanceof XList.XListView<?>) {
            return new UnmodifiableXListXListView<E>(
                (XList.XListView<E>)c);
        }
        return new UnmodifiableXList<E>(c);
    }

    public static <E> XList.XListView<E> unmodifiable(XList.XListView<E> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        Arguments.mustNotBeNull("c", c);
        if (c instanceof RandomAccess) {
            if (c instanceof MAList.MAListView<?>) {
                return new UnmodifiableMAListMAListViewWithRandomAccess<E>(
                    (MAList.MAListView<E>)c);
            }
            return new UnmodifiableXListXListViewWithRandomAccess<E>(c);
        }
        if (c instanceof MAList.MAListView<?>) {
            return new UnmodifiableMAListMAListView<E>(
                (MAList.MAListView<E>)c);
        }
        return new UnmodifiableXListXListView<E>(c);
    }

    private static <K, V> MAMap.MAKeySetView<K, V> unmodifiable(MAMap.MAKeySetView<K, V> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
            return new UnmodifiableMAOrderedMapMAOrderedKeySetView<K, V>(
                (MAOrderedMap.MAOrderedKeySetView<K, V>)c);
        }
        if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
            return new UnmodifiableMANavigableMapMANavigableKeySetView<K, V>(
                (MANavigableMap.MANavigableKeySetView<K, V>)c);
        }
        if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
            return new UnmodifiableMASortedMapMASortedKeySetView<K, V>(
                (MASortedMap.MASortedKeySetView<K, V>)c);
        }
        return new UnmodifiableMAMapMAKeySetView<K, V>(c);
    }

    private static <K, V> MAMap.MAValuesView<K, V> unmodifiable(MAMap.MAValuesView<K, V> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        return new UnmodifiableMAMapMAValuesView<K, V>(c);
    }

    private static <K, V> MAMap.MAEntrySetView<K, V> unmodifiable(MAMap.MAEntrySetView<K, V> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        return new UnmodifiableMAMapMAEntrySetView<K, V>(c);
    }

    @SuppressWarnings("unchecked")
    private static <E> MASortedSet.MASortedSetView<E> unmodifiable(MASortedSet.MASortedSetView<E> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        if (c instanceof MANavigableSet.MANavigableSetView<?>) {
            if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                return new UnmodifiableMANavigableMapMANavigableKeySetView<E, Object>(
                    (MANavigableMap.MANavigableKeySetView<E, Object>)c);
            }
            return new UnmodifiableMANavigableSetMANavigableSetView<E>(
                (MANavigableSet.MANavigableSetView<E>)c);
        }
        if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
            return new UnmodifiableMASortedMapMASortedKeySetView<E, Object>(
                (MASortedMap.MASortedKeySetView<E, Object>)c);
        }
        return new UnmodifiableMASortedSetMASortedSetView<E>(c);
    }

    private static <K, V> MASortedMap.MASortedKeySetView<K, V> unmodifiable(MASortedMap.MASortedKeySetView<K, V> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
            return new UnmodifiableMANavigableMapMANavigableKeySetView<K, V>(
                (MANavigableMap.MANavigableKeySetView<K, V>)c);
        }
        return new UnmodifiableMASortedMapMASortedKeySetView<K, V>(c);
    }

    @SuppressWarnings("unchecked")
    private static <E> MANavigableSet.MANavigableSetView<E> unmodifiable(MANavigableSet.MANavigableSetView<E> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
            return new UnmodifiableMANavigableMapMANavigableKeySetView<E, Object>(
                (MANavigableMap.MANavigableKeySetView<E, Object>)c);
        }
        return new UnmodifiableMANavigableSetMANavigableSetView<E>(c);
    }

    private static <K, V> MANavigableMap.MANavigableKeySetView<K, V> unmodifiable(MANavigableMap.MANavigableKeySetView<K, V> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        return new UnmodifiableMANavigableMapMANavigableKeySetView<K, V>(c);
    }

    @SuppressWarnings("unchecked")
    private static <E> MAOrderedSet.MAOrderedSetView<E> unmodifiable(MAOrderedSet.MAOrderedSetView<E> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
            return new UnmodifiableMAOrderedMapMAOrderedKeySetView<E, Object>(
                (MAOrderedMap.MAOrderedKeySetView<E, Object>)c);
        }
        return new UnmodifiableMAOrderedSetMAOrderedSetView<E>(c);
    }

    private static <K, V> MAOrderedMap.MAOrderedKeySetView<K, V> unmodifiable(MAOrderedMap.MAOrderedKeySetView<K, V> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        return new UnmodifiableMAOrderedMapMAOrderedKeySetView<K, V>(c);
    }

    private static <E> MAList.MAListView<E> unmodifiable(MAList.MAListView<E> c) {
        if (MACollections.isUnmodifiable(c)) {
            return c;
        }
        if (c instanceof RandomAccess) {
            return new UnmodifiableMAListMAListViewWithRandomAccess<E>(c);
        }
        return new UnmodifiableMAListMAListView<E>(c);
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    public static <E> Iterator<E> unmodifiable(Iterator<E> itr) {
        if (MACollections.isUnmodifiable(itr)) {
            return itr;
        }
        Arguments.mustNotBeNull("itr", itr);
        if (itr instanceof Serializable) {
            if (itr instanceof StandardMap.EntrySet.EntryIterator<?, ?>) {
                return new UnmodifiableStandardMapEntrySetEntryIteratorWithSerializable(
                    (StandardMap.EntrySet.EntryIterator)itr);
            }
            if (itr instanceof ListIterator<?>) {
                return new UnmodifiableListIteratorWithSerializable<E>(
                    (ListIterator<E>)itr);
            }
            return new UnmodifiableIteratorWithSerializable<E>(itr);
        }
        if (itr instanceof XCollection.XIterator<?>) {
            if (itr instanceof MACollection.MAIterator<?>) {
                if (itr instanceof MAMap.MAValuesView.MAValuesIterator<?, ?>) {
                    return new UnmodifiableMAMapMAValuesViewMAValuesIterator<Object, E>(
                        (MAMap.MAValuesView.MAValuesIterator<Object, E>)itr);
                }
                if (itr instanceof MAMap.MAEntrySetView.MAEntrySetIterator<?, ?>) {
                    return new UnmodifiableMAMapMAEntrySetViewMAEntrySetIterator(
                        (MAMap.MAEntrySetView.MAEntrySetIterator)itr);
                }
                if (itr instanceof MAList.MAListIterator<?>) {
                    return new UnmodifiableMAListMAListIterator<E>(
                        (MAList.MAListIterator<E>)itr);
                }
                if (itr instanceof MAMap.MAKeySetView.MAKeySetIterator<?, ?>) {
                    return new UnmodifiableMAMapMAKeySetViewMAKeySetIterator<E, Object>(
                        (MAMap.MAKeySetView.MAKeySetIterator<E, Object>)itr);
                }
                return new UnmodifiableMACollectionMAIterator<E>(
                    (MACollection.MAIterator<E>)itr);
            }
            if (itr instanceof XList.XListIterator<?>) {
                return new UnmodifiableXListXListIterator<E>(
                    (XList.XListIterator<E>)itr);
            }
            if (itr instanceof XMap.XEntrySetView.XEntrySetIterator<?, ?>) {
                return new UnmodifiableXMapXEntrySetViewXEntrySetIterator(
                    (XMap.XEntrySetView.XEntrySetIterator)itr);
            }
            return new UnmodifiableXCollectionXIterator<E>(
                (XCollection.XIterator<E>)itr);
        }
        if (itr instanceof StandardMap.EntrySet.EntryIterator<?, ?>) {
            return new UnmodifiableStandardMapEntrySetEntryIterator(
                (StandardMap.EntrySet.EntryIterator)itr);
        }
        if (itr instanceof ListIterator<?>) {
            return new UnmodifiableListIterator<E>(
                (ListIterator<E>)itr);
        }
        return new UnmodifiableIterator<E>(itr);
    }

    public static <E> ListIterator<E> unmodifiable(ListIterator<E> itr) {
        if (MACollections.isUnmodifiable(itr)) {
            return itr;
        }
        Arguments.mustNotBeNull("itr", itr);
        if (itr instanceof Serializable) {
            return new UnmodifiableListIteratorWithSerializable<E>(itr);
        }
        if (itr instanceof MAList.MAListIterator<?>) {
            return new UnmodifiableMAListMAListIterator<E>(
                (MAList.MAListIterator<E>)itr);
        }
        if (itr instanceof XList.XListIterator<?>) {
            return new UnmodifiableXListXListIterator<E>(
                (XList.XListIterator<E>)itr);
        }
        return new UnmodifiableListIterator<E>(itr);
    }

    private static <K, V> StandardMap.EntrySet.EntryIterator<K, V> unmodifiable(StandardMap.EntrySet.EntryIterator<K, V> itr) {
        if (MACollections.isUnmodifiable(itr)) {
            return itr;
        }
        if (itr instanceof Serializable) {
            return new UnmodifiableStandardMapEntrySetEntryIteratorWithSerializable<K, V>(itr);
        }
        return new UnmodifiableStandardMapEntrySetEntryIterator<K, V>(itr);
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    public static <E> XCollection.XIterator<E> unmodifiable(XCollection.XIterator<E> itr) {
        if (MACollections.isUnmodifiable(itr)) {
            return itr;
        }
        Arguments.mustNotBeNull("itr", itr);
        if (itr instanceof MACollection.MAIterator<?>) {
            if (itr instanceof MAMap.MAValuesView.MAValuesIterator<?, ?>) {
                return new UnmodifiableMAMapMAValuesViewMAValuesIterator<Object, E>(
                    (MAMap.MAValuesView.MAValuesIterator<Object, E>)itr);
            }
            if (itr instanceof MAMap.MAEntrySetView.MAEntrySetIterator<?, ?>) {
                return new UnmodifiableMAMapMAEntrySetViewMAEntrySetIterator(
                    (MAMap.MAEntrySetView.MAEntrySetIterator)itr);
            }
            if (itr instanceof MAList.MAListIterator<?>) {
                return new UnmodifiableMAListMAListIterator<E>(
                    (MAList.MAListIterator<E>)itr);
            }
            if (itr instanceof MAMap.MAKeySetView.MAKeySetIterator<?, ?>) {
                return new UnmodifiableMAMapMAKeySetViewMAKeySetIterator<E, Object>(
                    (MAMap.MAKeySetView.MAKeySetIterator<E, Object>)itr);
            }
            return new UnmodifiableMACollectionMAIterator<E>(
                (MACollection.MAIterator<E>)itr);
        }
        if (itr instanceof XList.XListIterator<?>) {
            return new UnmodifiableXListXListIterator<E>(
                (XList.XListIterator<E>)itr);
        }
        if (itr instanceof XMap.XEntrySetView.XEntrySetIterator<?, ?>) {
            return new UnmodifiableXMapXEntrySetViewXEntrySetIterator(
                (XMap.XEntrySetView.XEntrySetIterator)itr);
        }
        return new UnmodifiableXCollectionXIterator<E>(itr);
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    public static <K, V> XMap.XEntrySetView.XEntrySetIterator<K, V> unmodifiable(XMap.XEntrySetView.XEntrySetIterator<K, V> itr) {
        if (MACollections.isUnmodifiable(itr)) {
            return itr;
        }
        Arguments.mustNotBeNull("itr", itr);
        if (itr instanceof MAMap.MAEntrySetView.MAEntrySetIterator<?, ?>) {
            return new UnmodifiableMAMapMAEntrySetViewMAEntrySetIterator(
                (MAMap.MAEntrySetView.MAEntrySetIterator)itr);
        }
        return new UnmodifiableXMapXEntrySetViewXEntrySetIterator<K, V>(itr);
    }

    public static <E> XList.XListIterator<E> unmodifiable(XList.XListIterator<E> itr) {
        if (MACollections.isUnmodifiable(itr)) {
            return itr;
        }
        Arguments.mustNotBeNull("itr", itr);
        if (itr instanceof MAList.MAListIterator<?>) {
            return new UnmodifiableMAListMAListIterator<E>(
                (MAList.MAListIterator<E>)itr);
        }
        return new UnmodifiableXListXListIterator<E>(itr);
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    private static <E> MACollection.MAIterator<E> unmodifiable(MACollection.MAIterator<E> itr) {
        if (MACollections.isUnmodifiable(itr)) {
            return itr;
        }
        if (itr instanceof MAMap.MAValuesView.MAValuesIterator<?, ?>) {
            return new UnmodifiableMAMapMAValuesViewMAValuesIterator<Object, E>(
                (MAMap.MAValuesView.MAValuesIterator<Object, E>)itr);
        }
        if (itr instanceof MAMap.MAEntrySetView.MAEntrySetIterator<?, ?>) {
            return new UnmodifiableMAMapMAEntrySetViewMAEntrySetIterator(
                (MAMap.MAEntrySetView.MAEntrySetIterator)itr);
        }
        if (itr instanceof MAList.MAListIterator<?>) {
            return new UnmodifiableMAListMAListIterator<E>(
                (MAList.MAListIterator<E>)itr);
        }
        if (itr instanceof MAMap.MAKeySetView.MAKeySetIterator<?, ?>) {
            return new UnmodifiableMAMapMAKeySetViewMAKeySetIterator<E, Object>(
                (MAMap.MAKeySetView.MAKeySetIterator<E, Object>)itr);
        }
        return new UnmodifiableMACollectionMAIterator<E>(itr);
    }

    private static <K, V> MAMap.MAKeySetView.MAKeySetIterator<K, V> unmodifiable(MAMap.MAKeySetView.MAKeySetIterator<K, V> itr) {
        if (MACollections.isUnmodifiable(itr)) {
            return itr;
        }
        return new UnmodifiableMAMapMAKeySetViewMAKeySetIterator<K, V>(itr);
    }

    private static <E> MAList.MAListIterator<E> unmodifiable(MAList.MAListIterator<E> itr) {
        if (MACollections.isUnmodifiable(itr)) {
            return itr;
        }
        return new UnmodifiableMAListMAListIterator<E>(itr);
    }

    private static <K, V> MAMap.MAEntrySetView.MAEntrySetIterator<K, V> unmodifiable(MAMap.MAEntrySetView.MAEntrySetIterator<K, V> itr) {
        if (MACollections.isUnmodifiable(itr)) {
            return itr;
        }
        return new UnmodifiableMAMapMAEntrySetViewMAEntrySetIterator<K, V>(itr);
    }

    private static <K, V> MAMap.MAValuesView.MAValuesIterator<K, V> unmodifiable(MAMap.MAValuesView.MAValuesIterator<K, V> itr) {
        if (MACollections.isUnmodifiable(itr)) {
            return itr;
        }
        return new UnmodifiableMAMapMAValuesViewMAValuesIterator<K, V>(itr);
    }

    public static <K, V> Map.Entry<K, V> unmodifiable(Map.Entry<K, V> e) {
        if (MACollections.isUnmodifiable(e)) {
            return e;
        }
        Arguments.mustNotBeNull("e", e);
        if (e instanceof Serializable) {
            return new UnmodifiableMapEntryWithSerializable<K, V>(e);
        }
        if (e instanceof XMap.XEntry<?, ?>) {
            if (e instanceof MAMap.MAEntry<?, ?>) {
                return new UnmodifiableMAMapMAEntry<K, V>(
                    (MAMap.MAEntry<K, V>)e);
            }
            return new UnmodifiableXMapXEntry<K, V>(
                (XMap.XEntry<K, V>)e);
        }
        return new UnmodifiableMapEntry<K, V>(e);
    }

    public static <K, V> XMap.XEntry<K, V> unmodifiable(XMap.XEntry<K, V> e) {
        if (MACollections.isUnmodifiable(e)) {
            return e;
        }
        Arguments.mustNotBeNull("e", e);
        if (e instanceof MAMap.MAEntry<?, ?>) {
            return new UnmodifiableMAMapMAEntry<K, V>(
                (MAMap.MAEntry<K, V>)e);
        }
        return new UnmodifiableXMapXEntry<K, V>(e);
    }

    private static <K, V> MAMap.MAEntry<K, V> unmodifiable(MAMap.MAEntry<K, V> e) {
        if (MACollections.isUnmodifiable(e)) {
            return e;
        }
        return new UnmodifiableMAMapMAEntry<K, V>(e);
    }

    public static <K, V> Map<K, V> locked(Map<K, V> m) {
        return locked(m, null, true);
    }

    public static <K, V> Map<K, V> locked(Map<K, V> m, ReadWriteLock readWriteLock) {
        return locked(m, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> Map<K, V> locked(Map<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(m, readWriteLock)) {
            return m;
        }
        MACollections.validateLockSource("m", m);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (m instanceof Proxy) {
            Proxy proxy = (Proxy)m;
            proxies = proxy.getProxies();
            m = (Map<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    m = locked0(m, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                m = proxy.recreate(m);
            }
        }
        if (!isApplied) {
            m = locked0(m, readWriteLock, usingInternalLock);
        }
        return m;
    }

    private static <K, V> Map<K, V> locked0(Map<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (m instanceof Serializable) {
            if (m instanceof XMap<?, ?>) {
                if (m instanceof MAMap<?, ?>) {
                    if (m instanceof MAOrderedMap<?, ?>) {
                        return new LockedMAOrderedMapWithSerializable<K, V>(
                            (MAOrderedMap<K, V>)m, readWriteLock, usingInternalLock);
                    }
                    if (m instanceof MASortedMap<?, ?>) {
                        if (m instanceof MANavigableMap<?, ?>) {
                            return new LockedMANavigableMapWithSerializable<K, V>(
                                (MANavigableMap<K, V>)m, readWriteLock, usingInternalLock);
                        }
                        return new LockedMASortedMapWithSerializable<K, V>(
                            (MASortedMap<K, V>)m, readWriteLock, usingInternalLock);
                    }
                    return new LockedMAMapWithSerializable<K, V>(
                        (MAMap<K, V>)m, readWriteLock, usingInternalLock);
                }
                if (m instanceof XOrderedMap<?, ?>) {
                    return new LockedXOrderedMapWithSerializable<K, V>(
                        (XOrderedMap<K, V>)m, readWriteLock, usingInternalLock);
                }
                if (m instanceof XSortedMap<?, ?>) {
                    if (m instanceof XNavigableMap<?, ?>) {
                        return new LockedXNavigableMapWithSerializable<K, V>(
                            (XNavigableMap<K, V>)m, readWriteLock, usingInternalLock);
                    }
                    return new LockedXSortedMapWithSerializable<K, V>(
                        (XSortedMap<K, V>)m, readWriteLock, usingInternalLock);
                }
                return new LockedXMapWithSerializable<K, V>(
                    (XMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            if (m instanceof StandardMap<?, ?>) {
                if (m instanceof StandardSortedMap<?, ?>) {
                    if (m instanceof StandardNavigableMap<?, ?>) {
                        return new LockedStandardNavigableMapWithSerializable<K, V>(
                            (StandardNavigableMap<K, V>)m, readWriteLock, usingInternalLock);
                    }
                    return new LockedStandardSortedMapWithSerializable<K, V>(
                        (StandardSortedMap<K, V>)m, readWriteLock, usingInternalLock);
                }
                return new LockedStandardMapWithSerializable<K, V>(
                    (StandardMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            if (m instanceof SortedMap<?, ?>) {
                if (m instanceof NavigableMap<?, ?>) {
                    return locked0(standard((NavigableMap<K, V>)m), readWriteLock, usingInternalLock);
                }
                return locked0(standard((SortedMap<K, V>)m), readWriteLock, usingInternalLock);
            }
            return locked0(standard(m), readWriteLock, usingInternalLock);
        }
        if (m instanceof XMap<?, ?>) {
            if (m instanceof MAMap<?, ?>) {
                if (m instanceof MAOrderedMap<?, ?>) {
                    if (m instanceof MAOrderedMap.MAOrderedMapView<?, ?>) {
                        return new LockedMAOrderedMapMAOrderedMapView<K, V>(
                            (MAOrderedMap.MAOrderedMapView<K, V>)m, readWriteLock, usingInternalLock);
                    }
                    return new LockedMAOrderedMap<K, V>(
                        (MAOrderedMap<K, V>)m, readWriteLock, usingInternalLock);
                }
                if (m instanceof MASortedMap<?, ?>) {
                    if (m instanceof MANavigableMap<?, ?>) {
                        if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
                            return new LockedMANavigableMapMANavigableMapView<K, V>(
                                (MANavigableMap.MANavigableMapView<K, V>)m, readWriteLock, usingInternalLock);
                        }
                        return new LockedMANavigableMap<K, V>(
                            (MANavigableMap<K, V>)m, readWriteLock, usingInternalLock);
                    }
                    if (m instanceof MASortedMap.MASortedMapView<?, ?>) {
                        return new LockedMASortedMapMASortedMapView<K, V>(
                            (MASortedMap.MASortedMapView<K, V>)m, readWriteLock, usingInternalLock);
                    }
                    return new LockedMASortedMap<K, V>(
                        (MASortedMap<K, V>)m, readWriteLock, usingInternalLock);
                }
                return new LockedMAMap<K, V>(
                    (MAMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            if (m instanceof XOrderedMap<?, ?>) {
                if (m instanceof XOrderedMap.XOrderedMapView<?, ?>) {
                    return new LockedXOrderedMapXOrderedMapView<K, V>(
                        (XOrderedMap.XOrderedMapView<K, V>)m, readWriteLock, usingInternalLock);
                }
                return new LockedXOrderedMap<K, V>(
                    (XOrderedMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            if (m instanceof XSortedMap<?, ?>) {
                if (m instanceof XNavigableMap<?, ?>) {
                    if (m instanceof XNavigableMap.XNavigableMapView<?, ?>) {
                        return new LockedXNavigableMapXNavigableMapView<K, V>(
                            (XNavigableMap.XNavigableMapView<K, V>)m, readWriteLock, usingInternalLock);
                    }
                    return new LockedXNavigableMap<K, V>(
                        (XNavigableMap<K, V>)m, readWriteLock, usingInternalLock);
                }
                if (m instanceof XSortedMap.XSortedMapView<?, ?>) {
                    return new LockedXSortedMapXSortedMapView<K, V>(
                        (XSortedMap.XSortedMapView<K, V>)m, readWriteLock, usingInternalLock);
                }
                return new LockedXSortedMap<K, V>(
                    (XSortedMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            return new LockedXMap<K, V>(
                (XMap<K, V>)m, readWriteLock, usingInternalLock);
        }
        if (m instanceof StandardMap<?, ?>) {
            if (m instanceof StandardSortedMap<?, ?>) {
                if (m instanceof StandardNavigableMap<?, ?>) {
                    return new LockedStandardNavigableMap<K, V>(
                        (StandardNavigableMap<K, V>)m, readWriteLock, usingInternalLock);
                }
                return new LockedStandardSortedMap<K, V>(
                    (StandardSortedMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            return new LockedStandardMap<K, V>(
                (StandardMap<K, V>)m, readWriteLock, usingInternalLock);
        }
        if (m instanceof SortedMap<?, ?>) {
            if (m instanceof NavigableMap<?, ?>) {
                return locked0(standard((NavigableMap<K, V>)m), readWriteLock, usingInternalLock);
            }
            return locked0(standard((SortedMap<K, V>)m), readWriteLock, usingInternalLock);
        }
        return locked0(standard(m), readWriteLock, usingInternalLock);
    }

    public static <K, V> SortedMap<K, V> locked(SortedMap<K, V> m) {
        return locked(m, null, true);
    }

    public static <K, V> SortedMap<K, V> locked(SortedMap<K, V> m, ReadWriteLock readWriteLock) {
        return locked(m, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> SortedMap<K, V> locked(SortedMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(m, readWriteLock)) {
            return m;
        }
        MACollections.validateLockSource("m", m);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (m instanceof Proxy) {
            Proxy proxy = (Proxy)m;
            proxies = proxy.getProxies();
            m = (SortedMap<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    m = locked0(m, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                m = proxy.recreate(m);
            }
        }
        if (!isApplied) {
            m = locked0(m, readWriteLock, usingInternalLock);
        }
        return m;
    }

    private static <K, V> SortedMap<K, V> locked0(SortedMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (m instanceof Serializable) {
            if (m instanceof MASortedMap<?, ?>) {
                if (m instanceof MANavigableMap<?, ?>) {
                    return new LockedMANavigableMapWithSerializable<K, V>(
                        (MANavigableMap<K, V>)m, readWriteLock, usingInternalLock);
                }
                return new LockedMASortedMapWithSerializable<K, V>(
                    (MASortedMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            if (m instanceof XSortedMap<?, ?>) {
                if (m instanceof XNavigableMap<?, ?>) {
                    return new LockedXNavigableMapWithSerializable<K, V>(
                        (XNavigableMap<K, V>)m, readWriteLock, usingInternalLock);
                }
                return new LockedXSortedMapWithSerializable<K, V>(
                    (XSortedMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            if (m instanceof StandardSortedMap<?, ?>) {
                if (m instanceof StandardNavigableMap<?, ?>) {
                    return new LockedStandardNavigableMapWithSerializable<K, V>(
                        (StandardNavigableMap<K, V>)m, readWriteLock, usingInternalLock);
                }
                return new LockedStandardSortedMapWithSerializable<K, V>(
                    (StandardSortedMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            if (m instanceof NavigableMap<?, ?>) {
                return locked0(standard((NavigableMap<K, V>)m), readWriteLock, usingInternalLock);
            }
            return locked0(standard(m), readWriteLock, usingInternalLock);
        }
        if (m instanceof MASortedMap<?, ?>) {
            if (m instanceof MANavigableMap<?, ?>) {
                if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
                    return new LockedMANavigableMapMANavigableMapView<K, V>(
                        (MANavigableMap.MANavigableMapView<K, V>)m, readWriteLock, usingInternalLock);
                }
                return new LockedMANavigableMap<K, V>(
                    (MANavigableMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            if (m instanceof MASortedMap.MASortedMapView<?, ?>) {
                return new LockedMASortedMapMASortedMapView<K, V>(
                    (MASortedMap.MASortedMapView<K, V>)m, readWriteLock, usingInternalLock);
            }
            return new LockedMASortedMap<K, V>(
                (MASortedMap<K, V>)m, readWriteLock, usingInternalLock);
        }
        if (m instanceof XSortedMap<?, ?>) {
            if (m instanceof XNavigableMap<?, ?>) {
                if (m instanceof XNavigableMap.XNavigableMapView<?, ?>) {
                    return new LockedXNavigableMapXNavigableMapView<K, V>(
                        (XNavigableMap.XNavigableMapView<K, V>)m, readWriteLock, usingInternalLock);
                }
                return new LockedXNavigableMap<K, V>(
                    (XNavigableMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            if (m instanceof XSortedMap.XSortedMapView<?, ?>) {
                return new LockedXSortedMapXSortedMapView<K, V>(
                    (XSortedMap.XSortedMapView<K, V>)m, readWriteLock, usingInternalLock);
            }
            return new LockedXSortedMap<K, V>(
                (XSortedMap<K, V>)m, readWriteLock, usingInternalLock);
        }
        if (m instanceof StandardSortedMap<?, ?>) {
            if (m instanceof StandardNavigableMap<?, ?>) {
                return new LockedStandardNavigableMap<K, V>(
                    (StandardNavigableMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            return new LockedStandardSortedMap<K, V>(
                (StandardSortedMap<K, V>)m, readWriteLock, usingInternalLock);
        }
        if (m instanceof NavigableMap<?, ?>) {
            return locked0(standard((NavigableMap<K, V>)m), readWriteLock, usingInternalLock);
        }
        return locked0(standard(m), readWriteLock, usingInternalLock);
    }

    public static <K, V> NavigableMap<K, V> locked(NavigableMap<K, V> m) {
        return locked(m, null, true);
    }

    public static <K, V> NavigableMap<K, V> locked(NavigableMap<K, V> m, ReadWriteLock readWriteLock) {
        return locked(m, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> NavigableMap<K, V> locked(NavigableMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(m, readWriteLock)) {
            return m;
        }
        MACollections.validateLockSource("m", m);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (m instanceof Proxy) {
            Proxy proxy = (Proxy)m;
            proxies = proxy.getProxies();
            m = (NavigableMap<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    m = locked0(m, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                m = proxy.recreate(m);
            }
        }
        if (!isApplied) {
            m = locked0(m, readWriteLock, usingInternalLock);
        }
        return m;
    }

    private static <K, V> NavigableMap<K, V> locked0(NavigableMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (m instanceof Serializable) {
            if (m instanceof MANavigableMap<?, ?>) {
                return new LockedMANavigableMapWithSerializable<K, V>(
                    (MANavigableMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            if (m instanceof XNavigableMap<?, ?>) {
                return new LockedXNavigableMapWithSerializable<K, V>(
                    (XNavigableMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            if (m instanceof StandardNavigableMap<?, ?>) {
                return new LockedStandardNavigableMapWithSerializable<K, V>(
                    (StandardNavigableMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            return locked0(standard(m), readWriteLock, usingInternalLock);
        }
        if (m instanceof MANavigableMap<?, ?>) {
            if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
                return new LockedMANavigableMapMANavigableMapView<K, V>(
                    (MANavigableMap.MANavigableMapView<K, V>)m, readWriteLock, usingInternalLock);
            }
            return new LockedMANavigableMap<K, V>(
                (MANavigableMap<K, V>)m, readWriteLock, usingInternalLock);
        }
        if (m instanceof XNavigableMap<?, ?>) {
            if (m instanceof XNavigableMap.XNavigableMapView<?, ?>) {
                return new LockedXNavigableMapXNavigableMapView<K, V>(
                    (XNavigableMap.XNavigableMapView<K, V>)m, readWriteLock, usingInternalLock);
            }
            return new LockedXNavigableMap<K, V>(
                (XNavigableMap<K, V>)m, readWriteLock, usingInternalLock);
        }
        if (m instanceof StandardNavigableMap<?, ?>) {
            return new LockedStandardNavigableMap<K, V>(
                (StandardNavigableMap<K, V>)m, readWriteLock, usingInternalLock);
        }
        return locked0(standard(m), readWriteLock, usingInternalLock);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> StandardSortedMap<K, V> locked(StandardSortedMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(m, readWriteLock)) {
            return m;
        }
        MACollections.validateLockSource("m", m);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (m instanceof Proxy) {
            Proxy proxy = (Proxy)m;
            proxies = proxy.getProxies();
            m = (StandardSortedMap<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    m = locked0(m, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                m = proxy.recreate(m);
            }
        }
        if (!isApplied) {
            m = locked0(m, readWriteLock, usingInternalLock);
        }
        return m;
    }

    private static <K, V> StandardSortedMap<K, V> locked0(StandardSortedMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (m instanceof Serializable) {
            if (m instanceof StandardNavigableMap<?, ?>) {
                return new LockedStandardNavigableMapWithSerializable<K, V>(
                    (StandardNavigableMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            return new LockedStandardSortedMapWithSerializable<K, V>(m, readWriteLock, usingInternalLock);
        }
        if (m instanceof StandardNavigableMap<?, ?>) {
            return new LockedStandardNavigableMap<K, V>(
                (StandardNavigableMap<K, V>)m, readWriteLock, usingInternalLock);
        }
        return new LockedStandardSortedMap<K, V>(m, readWriteLock, usingInternalLock);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> StandardNavigableMap<K, V> locked(StandardNavigableMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(m, readWriteLock)) {
            return m;
        }
        MACollections.validateLockSource("m", m);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (m instanceof Proxy) {
            Proxy proxy = (Proxy)m;
            proxies = proxy.getProxies();
            m = (StandardNavigableMap<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    m = locked0(m, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                m = proxy.recreate(m);
            }
        }
        if (!isApplied) {
            m = locked0(m, readWriteLock, usingInternalLock);
        }
        return m;
    }

    private static <K, V> StandardNavigableMap<K, V> locked0(StandardNavigableMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (m instanceof Serializable) {
            return new LockedStandardNavigableMapWithSerializable<K, V>(m, readWriteLock, usingInternalLock);
        }
        return new LockedStandardNavigableMap<K, V>(m, readWriteLock, usingInternalLock);
    }

    public static <K, V> XMap<K, V> locked(XMap<K, V> m) {
        return locked(m, null, true);
    }

    public static <K, V> XMap<K, V> locked(XMap<K, V> m, ReadWriteLock readWriteLock) {
        return locked(m, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> XMap<K, V> locked(XMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(m, readWriteLock)) {
            return m;
        }
        MACollections.validateLockSource("m", m);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (m instanceof Proxy) {
            Proxy proxy = (Proxy)m;
            proxies = proxy.getProxies();
            m = (XMap<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    m = locked0(m, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                m = proxy.recreate(m);
            }
        }
        if (!isApplied) {
            m = locked0(m, readWriteLock, usingInternalLock);
        }
        return m;
    }

    private static <K, V> XMap<K, V> locked0(XMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (m instanceof Serializable) {
            if (m instanceof MAMap<?, ?>) {
                if (m instanceof MAOrderedMap<?, ?>) {
                    return new LockedMAOrderedMapWithSerializable<K, V>(
                        (MAOrderedMap<K, V>)m, readWriteLock, usingInternalLock);
                }
                if (m instanceof MASortedMap<?, ?>) {
                    if (m instanceof MANavigableMap<?, ?>) {
                        return new LockedMANavigableMapWithSerializable<K, V>(
                            (MANavigableMap<K, V>)m, readWriteLock, usingInternalLock);
                    }
                    return new LockedMASortedMapWithSerializable<K, V>(
                        (MASortedMap<K, V>)m, readWriteLock, usingInternalLock);
                }
                return new LockedMAMapWithSerializable<K, V>(
                    (MAMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            if (m instanceof XOrderedMap<?, ?>) {
                return new LockedXOrderedMapWithSerializable<K, V>(
                    (XOrderedMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            if (m instanceof XSortedMap<?, ?>) {
                if (m instanceof XNavigableMap<?, ?>) {
                    return new LockedXNavigableMapWithSerializable<K, V>(
                        (XNavigableMap<K, V>)m, readWriteLock, usingInternalLock);
                }
                return new LockedXSortedMapWithSerializable<K, V>(
                    (XSortedMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            return new LockedXMapWithSerializable<K, V>(m, readWriteLock, usingInternalLock);
        }
        if (m instanceof MAMap<?, ?>) {
            if (m instanceof MAOrderedMap<?, ?>) {
                if (m instanceof MAOrderedMap.MAOrderedMapView<?, ?>) {
                    return new LockedMAOrderedMapMAOrderedMapView<K, V>(
                        (MAOrderedMap.MAOrderedMapView<K, V>)m, readWriteLock, usingInternalLock);
                }
                return new LockedMAOrderedMap<K, V>(
                    (MAOrderedMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            if (m instanceof MASortedMap<?, ?>) {
                if (m instanceof MANavigableMap<?, ?>) {
                    if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
                        return new LockedMANavigableMapMANavigableMapView<K, V>(
                            (MANavigableMap.MANavigableMapView<K, V>)m, readWriteLock, usingInternalLock);
                    }
                    return new LockedMANavigableMap<K, V>(
                        (MANavigableMap<K, V>)m, readWriteLock, usingInternalLock);
                }
                if (m instanceof MASortedMap.MASortedMapView<?, ?>) {
                    return new LockedMASortedMapMASortedMapView<K, V>(
                        (MASortedMap.MASortedMapView<K, V>)m, readWriteLock, usingInternalLock);
                }
                return new LockedMASortedMap<K, V>(
                    (MASortedMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            return new LockedMAMap<K, V>(
                (MAMap<K, V>)m, readWriteLock, usingInternalLock);
        }
        if (m instanceof XOrderedMap<?, ?>) {
            if (m instanceof XOrderedMap.XOrderedMapView<?, ?>) {
                return new LockedXOrderedMapXOrderedMapView<K, V>(
                    (XOrderedMap.XOrderedMapView<K, V>)m, readWriteLock, usingInternalLock);
            }
            return new LockedXOrderedMap<K, V>(
                (XOrderedMap<K, V>)m, readWriteLock, usingInternalLock);
        }
        if (m instanceof XSortedMap<?, ?>) {
            if (m instanceof XNavigableMap<?, ?>) {
                if (m instanceof XNavigableMap.XNavigableMapView<?, ?>) {
                    return new LockedXNavigableMapXNavigableMapView<K, V>(
                        (XNavigableMap.XNavigableMapView<K, V>)m, readWriteLock, usingInternalLock);
                }
                return new LockedXNavigableMap<K, V>(
                    (XNavigableMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            if (m instanceof XSortedMap.XSortedMapView<?, ?>) {
                return new LockedXSortedMapXSortedMapView<K, V>(
                    (XSortedMap.XSortedMapView<K, V>)m, readWriteLock, usingInternalLock);
            }
            return new LockedXSortedMap<K, V>(
                (XSortedMap<K, V>)m, readWriteLock, usingInternalLock);
        }
        return new LockedXMap<K, V>(m, readWriteLock, usingInternalLock);
    }

    public static <K, V> XSortedMap<K, V> locked(XSortedMap<K, V> m) {
        return locked(m, null, true);
    }

    public static <K, V> XSortedMap<K, V> locked(XSortedMap<K, V> m, ReadWriteLock readWriteLock) {
        return locked(m, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> XSortedMap<K, V> locked(XSortedMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(m, readWriteLock)) {
            return m;
        }
        MACollections.validateLockSource("m", m);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (m instanceof Proxy) {
            Proxy proxy = (Proxy)m;
            proxies = proxy.getProxies();
            m = (XSortedMap<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    m = locked0(m, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                m = proxy.recreate(m);
            }
        }
        if (!isApplied) {
            m = locked0(m, readWriteLock, usingInternalLock);
        }
        return m;
    }

    private static <K, V> XSortedMap<K, V> locked0(XSortedMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (m instanceof Serializable) {
            if (m instanceof MASortedMap<?, ?>) {
                if (m instanceof MANavigableMap<?, ?>) {
                    return new LockedMANavigableMapWithSerializable<K, V>(
                        (MANavigableMap<K, V>)m, readWriteLock, usingInternalLock);
                }
                return new LockedMASortedMapWithSerializable<K, V>(
                    (MASortedMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            if (m instanceof XNavigableMap<?, ?>) {
                return new LockedXNavigableMapWithSerializable<K, V>(
                    (XNavigableMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            return new LockedXSortedMapWithSerializable<K, V>(m, readWriteLock, usingInternalLock);
        }
        if (m instanceof MASortedMap<?, ?>) {
            if (m instanceof MANavigableMap<?, ?>) {
                if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
                    return new LockedMANavigableMapMANavigableMapView<K, V>(
                        (MANavigableMap.MANavigableMapView<K, V>)m, readWriteLock, usingInternalLock);
                }
                return new LockedMANavigableMap<K, V>(
                    (MANavigableMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            if (m instanceof MASortedMap.MASortedMapView<?, ?>) {
                return new LockedMASortedMapMASortedMapView<K, V>(
                    (MASortedMap.MASortedMapView<K, V>)m, readWriteLock, usingInternalLock);
            }
            return new LockedMASortedMap<K, V>(
                (MASortedMap<K, V>)m, readWriteLock, usingInternalLock);
        }
        if (m instanceof XNavigableMap<?, ?>) {
            if (m instanceof XNavigableMap.XNavigableMapView<?, ?>) {
                return new LockedXNavigableMapXNavigableMapView<K, V>(
                    (XNavigableMap.XNavigableMapView<K, V>)m, readWriteLock, usingInternalLock);
            }
            return new LockedXNavigableMap<K, V>(
                (XNavigableMap<K, V>)m, readWriteLock, usingInternalLock);
        }
        if (m instanceof XSortedMap.XSortedMapView<?, ?>) {
            return new LockedXSortedMapXSortedMapView<K, V>(
                (XSortedMap.XSortedMapView<K, V>)m, readWriteLock, usingInternalLock);
        }
        return new LockedXSortedMap<K, V>(m, readWriteLock, usingInternalLock);
    }

    public static <K, V> XSortedMap.XSortedMapView<K, V> locked(XSortedMap.XSortedMapView<K, V> m) {
        return locked(m, null, true);
    }

    public static <K, V> XSortedMap.XSortedMapView<K, V> locked(XSortedMap.XSortedMapView<K, V> m, ReadWriteLock readWriteLock) {
        return locked(m, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> XSortedMap.XSortedMapView<K, V> locked(XSortedMap.XSortedMapView<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(m, readWriteLock)) {
            return m;
        }
        MACollections.validateLockSource("m", m);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (m instanceof Proxy) {
            Proxy proxy = (Proxy)m;
            proxies = proxy.getProxies();
            m = (XSortedMap.XSortedMapView<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    m = locked0(m, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                m = proxy.recreate(m);
            }
        }
        if (!isApplied) {
            m = locked0(m, readWriteLock, usingInternalLock);
        }
        return m;
    }

    private static <K, V> XSortedMap.XSortedMapView<K, V> locked0(XSortedMap.XSortedMapView<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
            return new LockedMANavigableMapMANavigableMapView<K, V>(
                (MANavigableMap.MANavigableMapView<K, V>)m, readWriteLock, usingInternalLock);
        }
        if (m instanceof MASortedMap.MASortedMapView<?, ?>) {
            return new LockedMASortedMapMASortedMapView<K, V>(
                (MASortedMap.MASortedMapView<K, V>)m, readWriteLock, usingInternalLock);
        }
        if (m instanceof XNavigableMap.XNavigableMapView<?, ?>) {
            return new LockedXNavigableMapXNavigableMapView<K, V>(
                (XNavigableMap.XNavigableMapView<K, V>)m, readWriteLock, usingInternalLock);
        }
        return new LockedXSortedMapXSortedMapView<K, V>(m, readWriteLock, usingInternalLock);
    }

    public static <K, V> XNavigableMap<K, V> locked(XNavigableMap<K, V> m) {
        return locked(m, null, true);
    }

    public static <K, V> XNavigableMap<K, V> locked(XNavigableMap<K, V> m, ReadWriteLock readWriteLock) {
        return locked(m, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> XNavigableMap<K, V> locked(XNavigableMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(m, readWriteLock)) {
            return m;
        }
        MACollections.validateLockSource("m", m);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (m instanceof Proxy) {
            Proxy proxy = (Proxy)m;
            proxies = proxy.getProxies();
            m = (XNavigableMap<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    m = locked0(m, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                m = proxy.recreate(m);
            }
        }
        if (!isApplied) {
            m = locked0(m, readWriteLock, usingInternalLock);
        }
        return m;
    }

    private static <K, V> XNavigableMap<K, V> locked0(XNavigableMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (m instanceof Serializable) {
            if (m instanceof MANavigableMap<?, ?>) {
                return new LockedMANavigableMapWithSerializable<K, V>(
                    (MANavigableMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            return new LockedXNavigableMapWithSerializable<K, V>(m, readWriteLock, usingInternalLock);
        }
        if (m instanceof MANavigableMap<?, ?>) {
            if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
                return new LockedMANavigableMapMANavigableMapView<K, V>(
                    (MANavigableMap.MANavigableMapView<K, V>)m, readWriteLock, usingInternalLock);
            }
            return new LockedMANavigableMap<K, V>(
                (MANavigableMap<K, V>)m, readWriteLock, usingInternalLock);
        }
        if (m instanceof XNavigableMap.XNavigableMapView<?, ?>) {
            return new LockedXNavigableMapXNavigableMapView<K, V>(
                (XNavigableMap.XNavigableMapView<K, V>)m, readWriteLock, usingInternalLock);
        }
        return new LockedXNavigableMap<K, V>(m, readWriteLock, usingInternalLock);
    }

    public static <K, V> XNavigableMap.XNavigableMapView<K, V> locked(XNavigableMap.XNavigableMapView<K, V> m) {
        return locked(m, null, true);
    }

    public static <K, V> XNavigableMap.XNavigableMapView<K, V> locked(XNavigableMap.XNavigableMapView<K, V> m, ReadWriteLock readWriteLock) {
        return locked(m, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> XNavigableMap.XNavigableMapView<K, V> locked(XNavigableMap.XNavigableMapView<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(m, readWriteLock)) {
            return m;
        }
        MACollections.validateLockSource("m", m);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (m instanceof Proxy) {
            Proxy proxy = (Proxy)m;
            proxies = proxy.getProxies();
            m = (XNavigableMap.XNavigableMapView<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    m = locked0(m, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                m = proxy.recreate(m);
            }
        }
        if (!isApplied) {
            m = locked0(m, readWriteLock, usingInternalLock);
        }
        return m;
    }

    private static <K, V> XNavigableMap.XNavigableMapView<K, V> locked0(XNavigableMap.XNavigableMapView<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
            return new LockedMANavigableMapMANavigableMapView<K, V>(
                (MANavigableMap.MANavigableMapView<K, V>)m, readWriteLock, usingInternalLock);
        }
        return new LockedXNavigableMapXNavigableMapView<K, V>(m, readWriteLock, usingInternalLock);
    }

    public static <K, V> XOrderedMap<K, V> locked(XOrderedMap<K, V> m) {
        return locked(m, null, true);
    }

    public static <K, V> XOrderedMap<K, V> locked(XOrderedMap<K, V> m, ReadWriteLock readWriteLock) {
        return locked(m, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> XOrderedMap<K, V> locked(XOrderedMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(m, readWriteLock)) {
            return m;
        }
        MACollections.validateLockSource("m", m);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (m instanceof Proxy) {
            Proxy proxy = (Proxy)m;
            proxies = proxy.getProxies();
            m = (XOrderedMap<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    m = locked0(m, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                m = proxy.recreate(m);
            }
        }
        if (!isApplied) {
            m = locked0(m, readWriteLock, usingInternalLock);
        }
        return m;
    }

    private static <K, V> XOrderedMap<K, V> locked0(XOrderedMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (m instanceof Serializable) {
            if (m instanceof MAOrderedMap<?, ?>) {
                return new LockedMAOrderedMapWithSerializable<K, V>(
                    (MAOrderedMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            return new LockedXOrderedMapWithSerializable<K, V>(m, readWriteLock, usingInternalLock);
        }
        if (m instanceof MAOrderedMap<?, ?>) {
            if (m instanceof MAOrderedMap.MAOrderedMapView<?, ?>) {
                return new LockedMAOrderedMapMAOrderedMapView<K, V>(
                    (MAOrderedMap.MAOrderedMapView<K, V>)m, readWriteLock, usingInternalLock);
            }
            return new LockedMAOrderedMap<K, V>(
                (MAOrderedMap<K, V>)m, readWriteLock, usingInternalLock);
        }
        if (m instanceof XOrderedMap.XOrderedMapView<?, ?>) {
            return new LockedXOrderedMapXOrderedMapView<K, V>(
                (XOrderedMap.XOrderedMapView<K, V>)m, readWriteLock, usingInternalLock);
        }
        return new LockedXOrderedMap<K, V>(m, readWriteLock, usingInternalLock);
    }

    public static <K, V> XOrderedMap.XOrderedMapView<K, V> locked(XOrderedMap.XOrderedMapView<K, V> m) {
        return locked(m, null, true);
    }

    public static <K, V> XOrderedMap.XOrderedMapView<K, V> locked(XOrderedMap.XOrderedMapView<K, V> m, ReadWriteLock readWriteLock) {
        return locked(m, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> XOrderedMap.XOrderedMapView<K, V> locked(XOrderedMap.XOrderedMapView<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(m, readWriteLock)) {
            return m;
        }
        MACollections.validateLockSource("m", m);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (m instanceof Proxy) {
            Proxy proxy = (Proxy)m;
            proxies = proxy.getProxies();
            m = (XOrderedMap.XOrderedMapView<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    m = locked0(m, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                m = proxy.recreate(m);
            }
        }
        if (!isApplied) {
            m = locked0(m, readWriteLock, usingInternalLock);
        }
        return m;
    }

    private static <K, V> XOrderedMap.XOrderedMapView<K, V> locked0(XOrderedMap.XOrderedMapView<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (m instanceof MAOrderedMap.MAOrderedMapView<?, ?>) {
            return new LockedMAOrderedMapMAOrderedMapView<K, V>(
                (MAOrderedMap.MAOrderedMapView<K, V>)m, readWriteLock, usingInternalLock);
        }
        return new LockedXOrderedMapXOrderedMapView<K, V>(m, readWriteLock, usingInternalLock);
    }

    public static <K, V> MAMap<K, V> locked(MAMap<K, V> m) {
        return locked(m, null, true);
    }

    public static <K, V> MAMap<K, V> locked(MAMap<K, V> m, ReadWriteLock readWriteLock) {
        return locked(m, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> MAMap<K, V> locked(MAMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(m, readWriteLock)) {
            return m;
        }
        MACollections.validateLockSource("m", m);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (m instanceof Proxy) {
            Proxy proxy = (Proxy)m;
            proxies = proxy.getProxies();
            m = (MAMap<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    m = locked0(m, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                m = proxy.recreate(m);
            }
        }
        if (!isApplied) {
            m = locked0(m, readWriteLock, usingInternalLock);
        }
        return m;
    }

    private static <K, V> MAMap<K, V> locked0(MAMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (m instanceof Serializable) {
            if (m instanceof MAOrderedMap<?, ?>) {
                return new LockedMAOrderedMapWithSerializable<K, V>(
                    (MAOrderedMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            if (m instanceof MASortedMap<?, ?>) {
                if (m instanceof MANavigableMap<?, ?>) {
                    return new LockedMANavigableMapWithSerializable<K, V>(
                        (MANavigableMap<K, V>)m, readWriteLock, usingInternalLock);
                }
                return new LockedMASortedMapWithSerializable<K, V>(
                    (MASortedMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            return new LockedMAMapWithSerializable<K, V>(m, readWriteLock, usingInternalLock);
        }
        if (m instanceof MAOrderedMap<?, ?>) {
            if (m instanceof MAOrderedMap.MAOrderedMapView<?, ?>) {
                return new LockedMAOrderedMapMAOrderedMapView<K, V>(
                    (MAOrderedMap.MAOrderedMapView<K, V>)m, readWriteLock, usingInternalLock);
            }
            return new LockedMAOrderedMap<K, V>(
                (MAOrderedMap<K, V>)m, readWriteLock, usingInternalLock);
        }
        if (m instanceof MASortedMap<?, ?>) {
            if (m instanceof MANavigableMap<?, ?>) {
                if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
                    return new LockedMANavigableMapMANavigableMapView<K, V>(
                        (MANavigableMap.MANavigableMapView<K, V>)m, readWriteLock, usingInternalLock);
                }
                return new LockedMANavigableMap<K, V>(
                    (MANavigableMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            if (m instanceof MASortedMap.MASortedMapView<?, ?>) {
                return new LockedMASortedMapMASortedMapView<K, V>(
                    (MASortedMap.MASortedMapView<K, V>)m, readWriteLock, usingInternalLock);
            }
            return new LockedMASortedMap<K, V>(
                (MASortedMap<K, V>)m, readWriteLock, usingInternalLock);
        }
        return new LockedMAMap<K, V>(m, readWriteLock, usingInternalLock);
    }

    public static <K, V> MASortedMap<K, V> locked(MASortedMap<K, V> m) {
        return locked(m, null, true);
    }

    public static <K, V> MASortedMap<K, V> locked(MASortedMap<K, V> m, ReadWriteLock readWriteLock) {
        return locked(m, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> MASortedMap<K, V> locked(MASortedMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(m, readWriteLock)) {
            return m;
        }
        MACollections.validateLockSource("m", m);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (m instanceof Proxy) {
            Proxy proxy = (Proxy)m;
            proxies = proxy.getProxies();
            m = (MASortedMap<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    m = locked0(m, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                m = proxy.recreate(m);
            }
        }
        if (!isApplied) {
            m = locked0(m, readWriteLock, usingInternalLock);
        }
        return m;
    }

    private static <K, V> MASortedMap<K, V> locked0(MASortedMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (m instanceof Serializable) {
            if (m instanceof MANavigableMap<?, ?>) {
                return new LockedMANavigableMapWithSerializable<K, V>(
                    (MANavigableMap<K, V>)m, readWriteLock, usingInternalLock);
            }
            return new LockedMASortedMapWithSerializable<K, V>(m, readWriteLock, usingInternalLock);
        }
        if (m instanceof MANavigableMap<?, ?>) {
            if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
                return new LockedMANavigableMapMANavigableMapView<K, V>(
                    (MANavigableMap.MANavigableMapView<K, V>)m, readWriteLock, usingInternalLock);
            }
            return new LockedMANavigableMap<K, V>(
                (MANavigableMap<K, V>)m, readWriteLock, usingInternalLock);
        }
        if (m instanceof MASortedMap.MASortedMapView<?, ?>) {
            return new LockedMASortedMapMASortedMapView<K, V>(
                (MASortedMap.MASortedMapView<K, V>)m, readWriteLock, usingInternalLock);
        }
        return new LockedMASortedMap<K, V>(m, readWriteLock, usingInternalLock);
    }

    public static <K, V> MASortedMap.MASortedMapView<K, V> locked(MASortedMap.MASortedMapView<K, V> m) {
        return locked(m, null, true);
    }

    public static <K, V> MASortedMap.MASortedMapView<K, V> locked(MASortedMap.MASortedMapView<K, V> m, ReadWriteLock readWriteLock) {
        return locked(m, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> MASortedMap.MASortedMapView<K, V> locked(MASortedMap.MASortedMapView<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(m, readWriteLock)) {
            return m;
        }
        MACollections.validateLockSource("m", m);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (m instanceof Proxy) {
            Proxy proxy = (Proxy)m;
            proxies = proxy.getProxies();
            m = (MASortedMap.MASortedMapView<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    m = locked0(m, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                m = proxy.recreate(m);
            }
        }
        if (!isApplied) {
            m = locked0(m, readWriteLock, usingInternalLock);
        }
        return m;
    }

    private static <K, V> MASortedMap.MASortedMapView<K, V> locked0(MASortedMap.MASortedMapView<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
            return new LockedMANavigableMapMANavigableMapView<K, V>(
                (MANavigableMap.MANavigableMapView<K, V>)m, readWriteLock, usingInternalLock);
        }
        return new LockedMASortedMapMASortedMapView<K, V>(m, readWriteLock, usingInternalLock);
    }

    public static <K, V> MANavigableMap<K, V> locked(MANavigableMap<K, V> m) {
        return locked(m, null, true);
    }

    public static <K, V> MANavigableMap<K, V> locked(MANavigableMap<K, V> m, ReadWriteLock readWriteLock) {
        return locked(m, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> MANavigableMap<K, V> locked(MANavigableMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(m, readWriteLock)) {
            return m;
        }
        MACollections.validateLockSource("m", m);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (m instanceof Proxy) {
            Proxy proxy = (Proxy)m;
            proxies = proxy.getProxies();
            m = (MANavigableMap<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    m = locked0(m, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                m = proxy.recreate(m);
            }
        }
        if (!isApplied) {
            m = locked0(m, readWriteLock, usingInternalLock);
        }
        return m;
    }

    private static <K, V> MANavigableMap<K, V> locked0(MANavigableMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (m instanceof Serializable) {
            return new LockedMANavigableMapWithSerializable<K, V>(m, readWriteLock, usingInternalLock);
        }
        if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
            return new LockedMANavigableMapMANavigableMapView<K, V>(
                (MANavigableMap.MANavigableMapView<K, V>)m, readWriteLock, usingInternalLock);
        }
        return new LockedMANavigableMap<K, V>(m, readWriteLock, usingInternalLock);
    }

    public static <K, V> MANavigableMap.MANavigableMapView<K, V> locked(MANavigableMap.MANavigableMapView<K, V> m) {
        return locked(m, null, true);
    }

    public static <K, V> MANavigableMap.MANavigableMapView<K, V> locked(MANavigableMap.MANavigableMapView<K, V> m, ReadWriteLock readWriteLock) {
        return locked(m, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> MANavigableMap.MANavigableMapView<K, V> locked(MANavigableMap.MANavigableMapView<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(m, readWriteLock)) {
            return m;
        }
        MACollections.validateLockSource("m", m);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (m instanceof Proxy) {
            Proxy proxy = (Proxy)m;
            proxies = proxy.getProxies();
            m = (MANavigableMap.MANavigableMapView<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    m = locked0(m, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                m = proxy.recreate(m);
            }
        }
        if (!isApplied) {
            m = locked0(m, readWriteLock, usingInternalLock);
        }
        return m;
    }

    private static <K, V> MANavigableMap.MANavigableMapView<K, V> locked0(MANavigableMap.MANavigableMapView<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        return new LockedMANavigableMapMANavigableMapView<K, V>(m, readWriteLock, usingInternalLock);
    }

    public static <K, V> MAOrderedMap<K, V> locked(MAOrderedMap<K, V> m) {
        return locked(m, null, true);
    }

    public static <K, V> MAOrderedMap<K, V> locked(MAOrderedMap<K, V> m, ReadWriteLock readWriteLock) {
        return locked(m, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> MAOrderedMap<K, V> locked(MAOrderedMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(m, readWriteLock)) {
            return m;
        }
        MACollections.validateLockSource("m", m);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (m instanceof Proxy) {
            Proxy proxy = (Proxy)m;
            proxies = proxy.getProxies();
            m = (MAOrderedMap<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    m = locked0(m, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                m = proxy.recreate(m);
            }
        }
        if (!isApplied) {
            m = locked0(m, readWriteLock, usingInternalLock);
        }
        return m;
    }

    private static <K, V> MAOrderedMap<K, V> locked0(MAOrderedMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (m instanceof Serializable) {
            return new LockedMAOrderedMapWithSerializable<K, V>(m, readWriteLock, usingInternalLock);
        }
        if (m instanceof MAOrderedMap.MAOrderedMapView<?, ?>) {
            return new LockedMAOrderedMapMAOrderedMapView<K, V>(
                (MAOrderedMap.MAOrderedMapView<K, V>)m, readWriteLock, usingInternalLock);
        }
        return new LockedMAOrderedMap<K, V>(m, readWriteLock, usingInternalLock);
    }

    public static <K, V> MAOrderedMap.MAOrderedMapView<K, V> locked(MAOrderedMap.MAOrderedMapView<K, V> m) {
        return locked(m, null, true);
    }

    public static <K, V> MAOrderedMap.MAOrderedMapView<K, V> locked(MAOrderedMap.MAOrderedMapView<K, V> m, ReadWriteLock readWriteLock) {
        return locked(m, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> MAOrderedMap.MAOrderedMapView<K, V> locked(MAOrderedMap.MAOrderedMapView<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(m, readWriteLock)) {
            return m;
        }
        MACollections.validateLockSource("m", m);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (m instanceof Proxy) {
            Proxy proxy = (Proxy)m;
            proxies = proxy.getProxies();
            m = (MAOrderedMap.MAOrderedMapView<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    m = locked0(m, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                m = proxy.recreate(m);
            }
        }
        if (!isApplied) {
            m = locked0(m, readWriteLock, usingInternalLock);
        }
        return m;
    }

    private static <K, V> MAOrderedMap.MAOrderedMapView<K, V> locked0(MAOrderedMap.MAOrderedMapView<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        return new LockedMAOrderedMapMAOrderedMapView<K, V>(m, readWriteLock, usingInternalLock);
    }

    public static <E> Collection<E> locked(Collection<E> c) {
        return locked(c, null, true);
    }

    public static <E> Collection<E> locked(Collection<E> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> Collection<E> locked(Collection<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (Collection<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    private static <E> Collection<E> locked0(Collection<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof Serializable) {
            if (c instanceof RandomAccess) {
                if (c instanceof MAList<?>) {
                    return new LockedMAListWithSerializableRandomAccess<E>(
                        (MAList<E>)c, readWriteLock, usingInternalLock);
                }
                if (c instanceof XList<?>) {
                    return new LockedXListWithSerializableRandomAccess<E>(
                        (XList<E>)c, readWriteLock, usingInternalLock);
                }
                if (c instanceof List<?>) {
                    return new LockedListWithSerializableRandomAccess<E>(
                        (List<E>)c, readWriteLock, usingInternalLock);
                }
            }
            if (c instanceof XCollection<?>) {
                if (c instanceof MACollection<?>) {
                    if (c instanceof MAList<?>) {
                        return new LockedMAListWithSerializable<E>(
                            (MAList<E>)c, readWriteLock, usingInternalLock);
                    }
                    if (c instanceof MASet<?>) {
                        if (c instanceof MAOrderedSet<?>) {
                            return new LockedMAOrderedSetWithSerializable<E>(
                                (MAOrderedSet<E>)c, readWriteLock, usingInternalLock);
                        }
                        if (c instanceof MASortedSet<?>) {
                            if (c instanceof MANavigableSet<?>) {
                                return new LockedMANavigableSetWithSerializable<E>(
                                    (MANavigableSet<E>)c, readWriteLock, usingInternalLock);
                            }
                            return new LockedMASortedSetWithSerializable<E>(
                                (MASortedSet<E>)c, readWriteLock, usingInternalLock);
                        }
                        return new LockedMASetWithSerializable<E>(
                            (MASet<E>)c, readWriteLock, usingInternalLock);
                    }
                    return new LockedMACollectionWithSerializable<E>(
                        (MACollection<E>)c, readWriteLock, usingInternalLock);
                }
                if (c instanceof XList<?>) {
                    return new LockedXListWithSerializable<E>(
                        (XList<E>)c, readWriteLock, usingInternalLock);
                }
                if (c instanceof XSet<?>) {
                    if (c instanceof XOrderedSet<?>) {
                        return new LockedXOrderedSetWithSerializable<E>(
                            (XOrderedSet<E>)c, readWriteLock, usingInternalLock);
                    }
                    if (c instanceof XSortedSet<?>) {
                        if (c instanceof XNavigableSet<?>) {
                            return new LockedXNavigableSetWithSerializable<E>(
                                (XNavigableSet<E>)c, readWriteLock, usingInternalLock);
                        }
                        return new LockedXSortedSetWithSerializable<E>(
                            (XSortedSet<E>)c, readWriteLock, usingInternalLock);
                    }
                    return new LockedXSetWithSerializable<E>(
                        (XSet<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedXCollectionWithSerializable<E>(
                    (XCollection<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof Set<?>) {
                if (c instanceof StandardMap.EntrySet<?, ?>) {
                    return new LockedStandardMapEntrySetWithSerializable(
                        (StandardMap.EntrySet)c, readWriteLock, usingInternalLock);
                }
                if (c instanceof SortedSet<?>) {
                    if (c instanceof NavigableSet<?>) {
                        return new LockedNavigableSetWithSerializable<E>(
                            (NavigableSet<E>)c, readWriteLock, usingInternalLock);
                    }
                    return new LockedSortedSetWithSerializable<E>(
                        (SortedSet<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedSetWithSerializable<E>(
                    (Set<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof List<?>) {
                return new LockedListWithSerializable<E>(
                    (List<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedCollectionWithSerializable<E>(c, readWriteLock, usingInternalLock);
        }
        if (c instanceof RandomAccess) {
            if (c instanceof MAList<?>) {
                if (c instanceof MAList.MAListView<?>) {
                    return new LockedMAListMAListViewWithRandomAccess<E>(
                        (MAList.MAListView<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMAListWithRandomAccess<E>(
                    (MAList<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof XList<?>) {
                if (c instanceof XList.XListView<?>) {
                    return new LockedXListXListViewWithRandomAccess<E>(
                        (XList.XListView<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedXListWithRandomAccess<E>(
                    (XList<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof List<?>) {
                return new LockedListWithRandomAccess<E>(
                    (List<E>)c, readWriteLock, usingInternalLock);
            }
        }
        if (c instanceof XCollection<?>) {
            if (c instanceof MACollection<?>) {
                if (c instanceof MAList<?>) {
                    if (c instanceof MAList.MAListView<?>) {
                        return new LockedMAListMAListView<E>(
                            (MAList.MAListView<E>)c, readWriteLock, usingInternalLock);
                    }
                    return new LockedMAList<E>(
                        (MAList<E>)c, readWriteLock, usingInternalLock);
                }
                if (c instanceof MASet<?>) {
                    if (c instanceof MAOrderedSet<?>) {
                        if (c instanceof MAOrderedSet.MAOrderedSetView<?>) {
                            if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
                                return new LockedMAOrderedMapMAOrderedKeySetView<E, Object>(
                                    (MAOrderedMap.MAOrderedKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
                            }
                            return new LockedMAOrderedSetMAOrderedSetView<E>(
                                (MAOrderedSet.MAOrderedSetView<E>)c, readWriteLock, usingInternalLock);
                        }
                        return new LockedMAOrderedSet<E>(
                            (MAOrderedSet<E>)c, readWriteLock, usingInternalLock);
                    }
                    if (c instanceof MASortedSet<?>) {
                        if (c instanceof MANavigableSet<?>) {
                            if (c instanceof MANavigableSet.MANavigableSetView<?>) {
                                if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                                    return new LockedMANavigableMapMANavigableKeySetView<E, Object>(
                                        (MANavigableMap.MANavigableKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
                                }
                                return new LockedMANavigableSetMANavigableSetView<E>(
                                    (MANavigableSet.MANavigableSetView<E>)c, readWriteLock, usingInternalLock);
                            }
                            return new LockedMANavigableSet<E>(
                                (MANavigableSet<E>)c, readWriteLock, usingInternalLock);
                        }
                        if (c instanceof MASortedSet.MASortedSetView<?>) {
                            if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
                                return new LockedMASortedMapMASortedKeySetView<E, Object>(
                                    (MASortedMap.MASortedKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
                            }
                            return new LockedMASortedSetMASortedSetView<E>(
                                (MASortedSet.MASortedSetView<E>)c, readWriteLock, usingInternalLock);
                        }
                        return new LockedMASortedSet<E>(
                            (MASortedSet<E>)c, readWriteLock, usingInternalLock);
                    }
                    if (c instanceof MAMap.MAEntrySetView<?, ?>) {
                        return new LockedMAMapMAEntrySetView(
                            (MAMap.MAEntrySetView)c, readWriteLock, usingInternalLock);
                    }
                    if (c instanceof MAMap.MAKeySetView<?, ?>) {
                        return new LockedMAMapMAKeySetView<E, Object>(
                            (MAMap.MAKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
                    }
                    return new LockedMASet<E>(
                        (MASet<E>)c, readWriteLock, usingInternalLock);
                }
                if (c instanceof MAMap.MAValuesView<?, ?>) {
                    return new LockedMAMapMAValuesView<Object, E>(
                        (MAMap.MAValuesView<Object, E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMACollection<E>(
                    (MACollection<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof XList<?>) {
                if (c instanceof XList.XListView<?>) {
                    return new LockedXListXListView<E>(
                        (XList.XListView<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedXList<E>(
                    (XList<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof XSet<?>) {
                if (c instanceof XOrderedSet<?>) {
                    if (c instanceof XOrderedSet.XOrderedSetView<?>) {
                        if (c instanceof XOrderedMap.XOrderedKeySetView<?>) {
                            return new LockedXOrderedMapXOrderedKeySetView<E>(
                                (XOrderedMap.XOrderedKeySetView<E>)c, readWriteLock, usingInternalLock);
                        }
                        return new LockedXOrderedSetXOrderedSetView<E>(
                            (XOrderedSet.XOrderedSetView<E>)c, readWriteLock, usingInternalLock);
                    }
                    return new LockedXOrderedSet<E>(
                        (XOrderedSet<E>)c, readWriteLock, usingInternalLock);
                }
                if (c instanceof XSortedSet<?>) {
                    if (c instanceof XNavigableSet<?>) {
                        if (c instanceof XNavigableSet.XNavigableSetView<?>) {
                            if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
                                return new LockedXNavigableMapXNavigableKeySetView<E>(
                                    (XNavigableMap.XNavigableKeySetView<E>)c, readWriteLock, usingInternalLock);
                            }
                            return new LockedXNavigableSetXNavigableSetView<E>(
                                (XNavigableSet.XNavigableSetView<E>)c, readWriteLock, usingInternalLock);
                        }
                        return new LockedXNavigableSet<E>(
                            (XNavigableSet<E>)c, readWriteLock, usingInternalLock);
                    }
                    if (c instanceof XSortedSet.XSortedSetView<?>) {
                        if (c instanceof XSortedMap.XSortedKeySetView<?>) {
                            return new LockedXSortedMapXSortedKeySetView<E>(
                                (XSortedMap.XSortedKeySetView<E>)c, readWriteLock, usingInternalLock);
                        }
                        return new LockedXSortedSetXSortedSetView<E>(
                            (XSortedSet.XSortedSetView<E>)c, readWriteLock, usingInternalLock);
                    }
                    return new LockedXSortedSet<E>(
                        (XSortedSet<E>)c, readWriteLock, usingInternalLock);
                }
                if (c instanceof XMap.XKeySetView<?>) {
                    return new LockedXMapXKeySetView<E>(
                        (XMap.XKeySetView<E>)c, readWriteLock, usingInternalLock);
                }
                if (c instanceof XMap.XEntrySetView<?, ?>) {
                    return new LockedXMapXEntrySetView(
                        (XMap.XEntrySetView)c, readWriteLock, usingInternalLock);
                }
                return new LockedXSet<E>(
                    (XSet<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof XMap.XValuesView<?>) {
                return new LockedXMapXValuesView<E>(
                    (XMap.XValuesView<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedXCollection<E>(
                (XCollection<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof Set<?>) {
            if (c instanceof StandardMap.EntrySet<?, ?>) {
                return new LockedStandardMapEntrySet(
                    (StandardMap.EntrySet)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof SortedSet<?>) {
                if (c instanceof NavigableSet<?>) {
                    return new LockedNavigableSet<E>(
                        (NavigableSet<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedSortedSet<E>(
                    (SortedSet<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedSet<E>(
                (Set<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof List<?>) {
            return new LockedList<E>(
                (List<E>)c, readWriteLock, usingInternalLock);
        }
        return new LockedCollection<E>(c, readWriteLock, usingInternalLock);
    }

    public static <E> Set<E> locked(Set<E> c) {
        return locked(c, null, true);
    }

    public static <E> Set<E> locked(Set<E> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> Set<E> locked(Set<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (Set<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    private static <E> Set<E> locked0(Set<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof Serializable) {
            if (c instanceof MAOrderedSet<?>) {
                return new LockedMAOrderedSetWithSerializable<E>(
                    (MAOrderedSet<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof MASortedSet<?>) {
                if (c instanceof MANavigableSet<?>) {
                    return new LockedMANavigableSetWithSerializable<E>(
                        (MANavigableSet<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMASortedSetWithSerializable<E>(
                    (MASortedSet<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof MASet<?>) {
                return new LockedMASetWithSerializable<E>(
                    (MASet<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof XSet<?>) {
                if (c instanceof XOrderedSet<?>) {
                    return new LockedXOrderedSetWithSerializable<E>(
                        (XOrderedSet<E>)c, readWriteLock, usingInternalLock);
                }
                if (c instanceof XSortedSet<?>) {
                    if (c instanceof XNavigableSet<?>) {
                        return new LockedXNavigableSetWithSerializable<E>(
                            (XNavigableSet<E>)c, readWriteLock, usingInternalLock);
                    }
                    return new LockedXSortedSetWithSerializable<E>(
                        (XSortedSet<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedXSetWithSerializable<E>(
                    (XSet<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof StandardMap.EntrySet<?, ?>) {
                return new LockedStandardMapEntrySetWithSerializable(
                    (StandardMap.EntrySet)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof SortedSet<?>) {
                if (c instanceof NavigableSet<?>) {
                    return new LockedNavigableSetWithSerializable<E>(
                        (NavigableSet<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedSortedSetWithSerializable<E>(
                    (SortedSet<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedSetWithSerializable<E>(c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MAOrderedSet<?>) {
            if (c instanceof MAOrderedSet.MAOrderedSetView<?>) {
                if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
                    return new LockedMAOrderedMapMAOrderedKeySetView<E, Object>(
                        (MAOrderedMap.MAOrderedKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMAOrderedSetMAOrderedSetView<E>(
                    (MAOrderedSet.MAOrderedSetView<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMAOrderedSet<E>(
                (MAOrderedSet<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MASortedSet<?>) {
            if (c instanceof MANavigableSet<?>) {
                if (c instanceof MANavigableSet.MANavigableSetView<?>) {
                    if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                        return new LockedMANavigableMapMANavigableKeySetView<E, Object>(
                            (MANavigableMap.MANavigableKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
                    }
                    return new LockedMANavigableSetMANavigableSetView<E>(
                        (MANavigableSet.MANavigableSetView<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMANavigableSet<E>(
                    (MANavigableSet<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof MASortedSet.MASortedSetView<?>) {
                if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
                    return new LockedMASortedMapMASortedKeySetView<E, Object>(
                        (MASortedMap.MASortedKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMASortedSetMASortedSetView<E>(
                    (MASortedSet.MASortedSetView<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMASortedSet<E>(
                (MASortedSet<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MAMap.MAEntrySetView<?, ?>) {
            return new LockedMAMapMAEntrySetView(
                (MAMap.MAEntrySetView)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MASet<?>) {
            if (c instanceof MAMap.MAKeySetView<?, ?>) {
                return new LockedMAMapMAKeySetView<E, Object>(
                    (MAMap.MAKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMASet<E>(
                (MASet<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof XSet<?>) {
            if (c instanceof XOrderedSet<?>) {
                if (c instanceof XOrderedSet.XOrderedSetView<?>) {
                    if (c instanceof XOrderedMap.XOrderedKeySetView<?>) {
                        return new LockedXOrderedMapXOrderedKeySetView<E>(
                            (XOrderedMap.XOrderedKeySetView<E>)c, readWriteLock, usingInternalLock);
                    }
                    return new LockedXOrderedSetXOrderedSetView<E>(
                        (XOrderedSet.XOrderedSetView<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedXOrderedSet<E>(
                    (XOrderedSet<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof XSortedSet<?>) {
                if (c instanceof XNavigableSet<?>) {
                    if (c instanceof XNavigableSet.XNavigableSetView<?>) {
                        if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
                            return new LockedXNavigableMapXNavigableKeySetView<E>(
                                (XNavigableMap.XNavigableKeySetView<E>)c, readWriteLock, usingInternalLock);
                        }
                        return new LockedXNavigableSetXNavigableSetView<E>(
                            (XNavigableSet.XNavigableSetView<E>)c, readWriteLock, usingInternalLock);
                    }
                    return new LockedXNavigableSet<E>(
                        (XNavigableSet<E>)c, readWriteLock, usingInternalLock);
                }
                if (c instanceof XSortedSet.XSortedSetView<?>) {
                    if (c instanceof XSortedMap.XSortedKeySetView<?>) {
                        return new LockedXSortedMapXSortedKeySetView<E>(
                            (XSortedMap.XSortedKeySetView<E>)c, readWriteLock, usingInternalLock);
                    }
                    return new LockedXSortedSetXSortedSetView<E>(
                        (XSortedSet.XSortedSetView<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedXSortedSet<E>(
                    (XSortedSet<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof XMap.XKeySetView<?>) {
                return new LockedXMapXKeySetView<E>(
                    (XMap.XKeySetView<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof XMap.XEntrySetView<?, ?>) {
                return new LockedXMapXEntrySetView(
                    (XMap.XEntrySetView)c, readWriteLock, usingInternalLock);
            }
            return new LockedXSet<E>(
                (XSet<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof StandardMap.EntrySet<?, ?>) {
            return new LockedStandardMapEntrySet(
                (StandardMap.EntrySet)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof SortedSet<?>) {
            if (c instanceof NavigableSet<?>) {
                return new LockedNavigableSet<E>(
                    (NavigableSet<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedSortedSet<E>(
                (SortedSet<E>)c, readWriteLock, usingInternalLock);
        }
        return new LockedSet<E>(c, readWriteLock, usingInternalLock);
    }

    public static <E> SortedSet<E> locked(SortedSet<E> c) {
        return locked(c, null, true);
    }

    public static <E> SortedSet<E> locked(SortedSet<E> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> SortedSet<E> locked(SortedSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (SortedSet<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    @SuppressWarnings("unchecked")
    private static <E> SortedSet<E> locked0(SortedSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof Serializable) {
            if (c instanceof MASortedSet<?>) {
                if (c instanceof MANavigableSet<?>) {
                    return new LockedMANavigableSetWithSerializable<E>(
                        (MANavigableSet<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMASortedSetWithSerializable<E>(
                    (MASortedSet<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof XSortedSet<?>) {
                if (c instanceof XNavigableSet<?>) {
                    return new LockedXNavigableSetWithSerializable<E>(
                        (XNavigableSet<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedXSortedSetWithSerializable<E>(
                    (XSortedSet<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof NavigableSet<?>) {
                return new LockedNavigableSetWithSerializable<E>(
                    (NavigableSet<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedSortedSetWithSerializable<E>(c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MASortedSet<?>) {
            if (c instanceof MANavigableSet<?>) {
                if (c instanceof MANavigableSet.MANavigableSetView<?>) {
                    if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                        return new LockedMANavigableMapMANavigableKeySetView<E, Object>(
                            (MANavigableMap.MANavigableKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
                    }
                    return new LockedMANavigableSetMANavigableSetView<E>(
                        (MANavigableSet.MANavigableSetView<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMANavigableSet<E>(
                    (MANavigableSet<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof MASortedSet.MASortedSetView<?>) {
                if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
                    return new LockedMASortedMapMASortedKeySetView<E, Object>(
                        (MASortedMap.MASortedKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMASortedSetMASortedSetView<E>(
                    (MASortedSet.MASortedSetView<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMASortedSet<E>(
                (MASortedSet<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof XSortedSet<?>) {
            if (c instanceof XNavigableSet<?>) {
                if (c instanceof XNavigableSet.XNavigableSetView<?>) {
                    if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
                        return new LockedXNavigableMapXNavigableKeySetView<E>(
                            (XNavigableMap.XNavigableKeySetView<E>)c, readWriteLock, usingInternalLock);
                    }
                    return new LockedXNavigableSetXNavigableSetView<E>(
                        (XNavigableSet.XNavigableSetView<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedXNavigableSet<E>(
                    (XNavigableSet<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof XSortedSet.XSortedSetView<?>) {
                if (c instanceof XSortedMap.XSortedKeySetView<?>) {
                    return new LockedXSortedMapXSortedKeySetView<E>(
                        (XSortedMap.XSortedKeySetView<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedXSortedSetXSortedSetView<E>(
                    (XSortedSet.XSortedSetView<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedXSortedSet<E>(
                (XSortedSet<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof NavigableSet<?>) {
            return new LockedNavigableSet<E>(
                (NavigableSet<E>)c, readWriteLock, usingInternalLock);
        }
        return new LockedSortedSet<E>(c, readWriteLock, usingInternalLock);
    }

    public static <E> NavigableSet<E> locked(NavigableSet<E> c) {
        return locked(c, null, true);
    }

    public static <E> NavigableSet<E> locked(NavigableSet<E> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> NavigableSet<E> locked(NavigableSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (NavigableSet<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    @SuppressWarnings("unchecked")
    private static <E> NavigableSet<E> locked0(NavigableSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof Serializable) {
            if (c instanceof MANavigableSet<?>) {
                return new LockedMANavigableSetWithSerializable<E>(
                    (MANavigableSet<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof XNavigableSet<?>) {
                return new LockedXNavigableSetWithSerializable<E>(
                    (XNavigableSet<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedNavigableSetWithSerializable<E>(c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MANavigableSet<?>) {
            if (c instanceof MANavigableSet.MANavigableSetView<?>) {
                if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                    return new LockedMANavigableMapMANavigableKeySetView<E, Object>(
                        (MANavigableMap.MANavigableKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMANavigableSetMANavigableSetView<E>(
                    (MANavigableSet.MANavigableSetView<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMANavigableSet<E>(
                (MANavigableSet<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof XNavigableSet<?>) {
            if (c instanceof XNavigableSet.XNavigableSetView<?>) {
                if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
                    return new LockedXNavigableMapXNavigableKeySetView<E>(
                        (XNavigableMap.XNavigableKeySetView<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedXNavigableSetXNavigableSetView<E>(
                    (XNavigableSet.XNavigableSetView<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedXNavigableSet<E>(
                (XNavigableSet<E>)c, readWriteLock, usingInternalLock);
        }
        return new LockedNavigableSet<E>(c, readWriteLock, usingInternalLock);
    }

    public static <E> List<E> locked(List<E> c) {
        return locked(c, null, true);
    }

    public static <E> List<E> locked(List<E> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> List<E> locked(List<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (List<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    private static <E> List<E> locked0(List<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof Serializable) {
            if (c instanceof RandomAccess) {
                if (c instanceof MAList<?>) {
                    return new LockedMAListWithSerializableRandomAccess<E>(
                        (MAList<E>)c, readWriteLock, usingInternalLock);
                }
                if (c instanceof XList<?>) {
                    return new LockedXListWithSerializableRandomAccess<E>(
                        (XList<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedListWithSerializableRandomAccess<E>(c, readWriteLock, usingInternalLock);
            }
            if (c instanceof MAList<?>) {
                return new LockedMAListWithSerializable<E>(
                    (MAList<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof XList<?>) {
                return new LockedXListWithSerializable<E>(
                    (XList<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedListWithSerializable<E>(c, readWriteLock, usingInternalLock);
        }
        if (c instanceof RandomAccess) {
            if (c instanceof MAList<?>) {
                if (c instanceof MAList.MAListView<?>) {
                    return new LockedMAListMAListViewWithRandomAccess<E>(
                        (MAList.MAListView<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMAListWithRandomAccess<E>(
                    (MAList<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof XList<?>) {
                if (c instanceof XList.XListView<?>) {
                    return new LockedXListXListViewWithRandomAccess<E>(
                        (XList.XListView<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedXListWithRandomAccess<E>(
                    (XList<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedListWithRandomAccess<E>(c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MAList<?>) {
            if (c instanceof MAList.MAListView<?>) {
                return new LockedMAListMAListView<E>(
                    (MAList.MAListView<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMAList<E>(
                (MAList<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof XList<?>) {
            if (c instanceof XList.XListView<?>) {
                return new LockedXListXListView<E>(
                    (XList.XListView<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedXList<E>(
                (XList<E>)c, readWriteLock, usingInternalLock);
        }
        return new LockedList<E>(c, readWriteLock, usingInternalLock);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> StandardMap.EntrySet<K, V> locked(StandardMap.EntrySet<K, V> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (StandardMap.EntrySet<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    private static <K, V> StandardMap.EntrySet<K, V> locked0(StandardMap.EntrySet<K, V> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof Serializable) {
            return new LockedStandardMapEntrySetWithSerializable<K, V>(c, readWriteLock, usingInternalLock);
        }
        return new LockedStandardMapEntrySet<K, V>(c, readWriteLock, usingInternalLock);
    }

    public static <E> XCollection<E> locked(XCollection<E> c) {
        return locked(c, null, true);
    }

    public static <E> XCollection<E> locked(XCollection<E> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> XCollection<E> locked(XCollection<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (XCollection<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    private static <E> XCollection<E> locked0(XCollection<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof Serializable) {
            if (c instanceof MACollection<?>) {
                if (c instanceof MAList<?>) {
                    return new LockedMAListWithSerializable<E>(
                        (MAList<E>)c, readWriteLock, usingInternalLock);
                }
                if (c instanceof MASet<?>) {
                    if (c instanceof MAOrderedSet<?>) {
                        return new LockedMAOrderedSetWithSerializable<E>(
                            (MAOrderedSet<E>)c, readWriteLock, usingInternalLock);
                    }
                    if (c instanceof MASortedSet<?>) {
                        if (c instanceof MANavigableSet<?>) {
                            return new LockedMANavigableSetWithSerializable<E>(
                                (MANavigableSet<E>)c, readWriteLock, usingInternalLock);
                        }
                        return new LockedMASortedSetWithSerializable<E>(
                            (MASortedSet<E>)c, readWriteLock, usingInternalLock);
                    }
                    return new LockedMASetWithSerializable<E>(
                        (MASet<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMACollectionWithSerializable<E>(
                    (MACollection<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof XList<?>) {
                return new LockedXListWithSerializable<E>(
                    (XList<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof XSet<?>) {
                if (c instanceof XOrderedSet<?>) {
                    return new LockedXOrderedSetWithSerializable<E>(
                        (XOrderedSet<E>)c, readWriteLock, usingInternalLock);
                }
                if (c instanceof XSortedSet<?>) {
                    if (c instanceof XNavigableSet<?>) {
                        return new LockedXNavigableSetWithSerializable<E>(
                            (XNavigableSet<E>)c, readWriteLock, usingInternalLock);
                    }
                    return new LockedXSortedSetWithSerializable<E>(
                        (XSortedSet<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedXSetWithSerializable<E>(
                    (XSet<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedXCollectionWithSerializable<E>(c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MACollection<?>) {
            if (c instanceof MAList<?>) {
                if (c instanceof MAList.MAListView<?>) {
                    return new LockedMAListMAListView<E>(
                        (MAList.MAListView<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMAList<E>(
                    (MAList<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof MASet<?>) {
                if (c instanceof MAOrderedSet<?>) {
                    if (c instanceof MAOrderedSet.MAOrderedSetView<?>) {
                        if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
                            return new LockedMAOrderedMapMAOrderedKeySetView<E, Object>(
                                (MAOrderedMap.MAOrderedKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
                        }
                        return new LockedMAOrderedSetMAOrderedSetView<E>(
                            (MAOrderedSet.MAOrderedSetView<E>)c, readWriteLock, usingInternalLock);
                    }
                    return new LockedMAOrderedSet<E>(
                        (MAOrderedSet<E>)c, readWriteLock, usingInternalLock);
                }
                if (c instanceof MASortedSet<?>) {
                    if (c instanceof MANavigableSet<?>) {
                        if (c instanceof MANavigableSet.MANavigableSetView<?>) {
                            if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                                return new LockedMANavigableMapMANavigableKeySetView<E, Object>(
                                    (MANavigableMap.MANavigableKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
                            }
                            return new LockedMANavigableSetMANavigableSetView<E>(
                                (MANavigableSet.MANavigableSetView<E>)c, readWriteLock, usingInternalLock);
                        }
                        return new LockedMANavigableSet<E>(
                            (MANavigableSet<E>)c, readWriteLock, usingInternalLock);
                    }
                    if (c instanceof MASortedSet.MASortedSetView<?>) {
                        if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
                            return new LockedMASortedMapMASortedKeySetView<E, Object>(
                                (MASortedMap.MASortedKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
                        }
                        return new LockedMASortedSetMASortedSetView<E>(
                            (MASortedSet.MASortedSetView<E>)c, readWriteLock, usingInternalLock);
                    }
                    return new LockedMASortedSet<E>(
                        (MASortedSet<E>)c, readWriteLock, usingInternalLock);
                }
                if (c instanceof MAMap.MAEntrySetView<?, ?>) {
                    return new LockedMAMapMAEntrySetView(
                        (MAMap.MAEntrySetView)c, readWriteLock, usingInternalLock);
                }
                if (c instanceof MAMap.MAKeySetView<?, ?>) {
                    return new LockedMAMapMAKeySetView<E, Object>(
                        (MAMap.MAKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMASet<E>(
                    (MASet<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof MAMap.MAValuesView<?, ?>) {
                return new LockedMAMapMAValuesView<Object, E>(
                    (MAMap.MAValuesView<Object, E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMACollection<E>(
                (MACollection<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof XList<?>) {
            if (c instanceof XList.XListView<?>) {
                return new LockedXListXListView<E>(
                    (XList.XListView<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedXList<E>(
                (XList<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof XSet<?>) {
            if (c instanceof XOrderedSet<?>) {
                if (c instanceof XOrderedSet.XOrderedSetView<?>) {
                    if (c instanceof XOrderedMap.XOrderedKeySetView<?>) {
                        return new LockedXOrderedMapXOrderedKeySetView<E>(
                            (XOrderedMap.XOrderedKeySetView<E>)c, readWriteLock, usingInternalLock);
                    }
                    return new LockedXOrderedSetXOrderedSetView<E>(
                        (XOrderedSet.XOrderedSetView<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedXOrderedSet<E>(
                    (XOrderedSet<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof XSortedSet<?>) {
                if (c instanceof XNavigableSet<?>) {
                    if (c instanceof XNavigableSet.XNavigableSetView<?>) {
                        if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
                            return new LockedXNavigableMapXNavigableKeySetView<E>(
                                (XNavigableMap.XNavigableKeySetView<E>)c, readWriteLock, usingInternalLock);
                        }
                        return new LockedXNavigableSetXNavigableSetView<E>(
                            (XNavigableSet.XNavigableSetView<E>)c, readWriteLock, usingInternalLock);
                    }
                    return new LockedXNavigableSet<E>(
                        (XNavigableSet<E>)c, readWriteLock, usingInternalLock);
                }
                if (c instanceof XSortedSet.XSortedSetView<?>) {
                    if (c instanceof XSortedMap.XSortedKeySetView<?>) {
                        return new LockedXSortedMapXSortedKeySetView<E>(
                            (XSortedMap.XSortedKeySetView<E>)c, readWriteLock, usingInternalLock);
                    }
                    return new LockedXSortedSetXSortedSetView<E>(
                        (XSortedSet.XSortedSetView<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedXSortedSet<E>(
                    (XSortedSet<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof XMap.XKeySetView<?>) {
                return new LockedXMapXKeySetView<E>(
                    (XMap.XKeySetView<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof XMap.XEntrySetView<?, ?>) {
                return new LockedXMapXEntrySetView(
                    (XMap.XEntrySetView)c, readWriteLock, usingInternalLock);
            }
            return new LockedXSet<E>(
                (XSet<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof XMap.XValuesView<?>) {
            return new LockedXMapXValuesView<E>(
                (XMap.XValuesView<E>)c, readWriteLock, usingInternalLock);
        }
        return new LockedXCollection<E>(c, readWriteLock, usingInternalLock);
    }

    public static <V> XMap.XValuesView<V> locked(XMap.XValuesView<V> c) {
        return locked(c, null, true);
    }

    public static <V> XMap.XValuesView<V> locked(XMap.XValuesView<V> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <V> XMap.XValuesView<V> locked(XMap.XValuesView<V> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (XMap.XValuesView<V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    @SuppressWarnings("unchecked")
    private static <V> XMap.XValuesView<V> locked0(XMap.XValuesView<V> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof MAMap.MAValuesView<?, ?>) {
            return new LockedMAMapMAValuesView<Object, V>(
                (MAMap.MAValuesView<Object, V>)c, readWriteLock, usingInternalLock);
        }
        return new LockedXMapXValuesView<V>(c, readWriteLock, usingInternalLock);
    }

    public static <E> XSet<E> locked(XSet<E> c) {
        return locked(c, null, true);
    }

    public static <E> XSet<E> locked(XSet<E> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> XSet<E> locked(XSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (XSet<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    private static <E> XSet<E> locked0(XSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof Serializable) {
            if (c instanceof MAOrderedSet<?>) {
                return new LockedMAOrderedSetWithSerializable<E>(
                    (MAOrderedSet<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof MASortedSet<?>) {
                if (c instanceof MANavigableSet<?>) {
                    return new LockedMANavigableSetWithSerializable<E>(
                        (MANavigableSet<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMASortedSetWithSerializable<E>(
                    (MASortedSet<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof MASet<?>) {
                return new LockedMASetWithSerializable<E>(
                    (MASet<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof XOrderedSet<?>) {
                return new LockedXOrderedSetWithSerializable<E>(
                    (XOrderedSet<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof XSortedSet<?>) {
                if (c instanceof XNavigableSet<?>) {
                    return new LockedXNavigableSetWithSerializable<E>(
                        (XNavigableSet<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedXSortedSetWithSerializable<E>(
                    (XSortedSet<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedXSetWithSerializable<E>(c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MAOrderedSet<?>) {
            if (c instanceof MAOrderedSet.MAOrderedSetView<?>) {
                if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
                    return new LockedMAOrderedMapMAOrderedKeySetView<E, Object>(
                        (MAOrderedMap.MAOrderedKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMAOrderedSetMAOrderedSetView<E>(
                    (MAOrderedSet.MAOrderedSetView<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMAOrderedSet<E>(
                (MAOrderedSet<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MASortedSet<?>) {
            if (c instanceof MANavigableSet<?>) {
                if (c instanceof MANavigableSet.MANavigableSetView<?>) {
                    if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                        return new LockedMANavigableMapMANavigableKeySetView<E, Object>(
                            (MANavigableMap.MANavigableKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
                    }
                    return new LockedMANavigableSetMANavigableSetView<E>(
                        (MANavigableSet.MANavigableSetView<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMANavigableSet<E>(
                    (MANavigableSet<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof MASortedSet.MASortedSetView<?>) {
                if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
                    return new LockedMASortedMapMASortedKeySetView<E, Object>(
                        (MASortedMap.MASortedKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMASortedSetMASortedSetView<E>(
                    (MASortedSet.MASortedSetView<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMASortedSet<E>(
                (MASortedSet<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MAMap.MAEntrySetView<?, ?>) {
            return new LockedMAMapMAEntrySetView(
                (MAMap.MAEntrySetView)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MASet<?>) {
            if (c instanceof MAMap.MAKeySetView<?, ?>) {
                return new LockedMAMapMAKeySetView<E, Object>(
                    (MAMap.MAKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMASet<E>(
                (MASet<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof XOrderedSet<?>) {
            if (c instanceof XOrderedSet.XOrderedSetView<?>) {
                if (c instanceof XOrderedMap.XOrderedKeySetView<?>) {
                    return new LockedXOrderedMapXOrderedKeySetView<E>(
                        (XOrderedMap.XOrderedKeySetView<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedXOrderedSetXOrderedSetView<E>(
                    (XOrderedSet.XOrderedSetView<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedXOrderedSet<E>(
                (XOrderedSet<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof XSortedSet<?>) {
            if (c instanceof XNavigableSet<?>) {
                if (c instanceof XNavigableSet.XNavigableSetView<?>) {
                    if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
                        return new LockedXNavigableMapXNavigableKeySetView<E>(
                            (XNavigableMap.XNavigableKeySetView<E>)c, readWriteLock, usingInternalLock);
                    }
                    return new LockedXNavigableSetXNavigableSetView<E>(
                        (XNavigableSet.XNavigableSetView<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedXNavigableSet<E>(
                    (XNavigableSet<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof XSortedSet.XSortedSetView<?>) {
                if (c instanceof XSortedMap.XSortedKeySetView<?>) {
                    return new LockedXSortedMapXSortedKeySetView<E>(
                        (XSortedMap.XSortedKeySetView<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedXSortedSetXSortedSetView<E>(
                    (XSortedSet.XSortedSetView<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedXSortedSet<E>(
                (XSortedSet<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof XMap.XKeySetView<?>) {
            return new LockedXMapXKeySetView<E>(
                (XMap.XKeySetView<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof XMap.XEntrySetView<?, ?>) {
            return new LockedXMapXEntrySetView(
                (XMap.XEntrySetView)c, readWriteLock, usingInternalLock);
        }
        return new LockedXSet<E>(c, readWriteLock, usingInternalLock);
    }

    public static <K, V> XMap.XEntrySetView<K, V> locked(XMap.XEntrySetView<K, V> c) {
        return locked(c, null, true);
    }

    public static <K, V> XMap.XEntrySetView<K, V> locked(XMap.XEntrySetView<K, V> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> XMap.XEntrySetView<K, V> locked(XMap.XEntrySetView<K, V> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (XMap.XEntrySetView<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    private static <K, V> XMap.XEntrySetView<K, V> locked0(XMap.XEntrySetView<K, V> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof MAMap.MAEntrySetView<?, ?>) {
            return new LockedMAMapMAEntrySetView(
                (MAMap.MAEntrySetView)c, readWriteLock, usingInternalLock);
        }
        return new LockedXMapXEntrySetView<K, V>(c, readWriteLock, usingInternalLock);
    }

    public static <K> XMap.XKeySetView<K> locked(XMap.XKeySetView<K> c) {
        return locked(c, null, true);
    }

    public static <K> XMap.XKeySetView<K> locked(XMap.XKeySetView<K> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K> XMap.XKeySetView<K> locked(XMap.XKeySetView<K> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (XMap.XKeySetView<K>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    @SuppressWarnings("unchecked")
    private static <K> XMap.XKeySetView<K> locked0(XMap.XKeySetView<K> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
            return new LockedMAOrderedMapMAOrderedKeySetView<K, Object>(
                (MAOrderedMap.MAOrderedKeySetView<K, Object>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
            return new LockedMANavigableMapMANavigableKeySetView<K, Object>(
                (MANavigableMap.MANavigableKeySetView<K, Object>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
            return new LockedMASortedMapMASortedKeySetView<K, Object>(
                (MASortedMap.MASortedKeySetView<K, Object>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MAMap.MAKeySetView<?, ?>) {
            return new LockedMAMapMAKeySetView<K, Object>(
                (MAMap.MAKeySetView<K, Object>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof XOrderedMap.XOrderedKeySetView<?>) {
            return new LockedXOrderedMapXOrderedKeySetView<K>(
                (XOrderedMap.XOrderedKeySetView<K>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
            return new LockedXNavigableMapXNavigableKeySetView<K>(
                (XNavigableMap.XNavigableKeySetView<K>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof XSortedMap.XSortedKeySetView<?>) {
            return new LockedXSortedMapXSortedKeySetView<K>(
                (XSortedMap.XSortedKeySetView<K>)c, readWriteLock, usingInternalLock);
        }
        return new LockedXMapXKeySetView<K>(c, readWriteLock, usingInternalLock);
    }

    public static <E> XSortedSet<E> locked(XSortedSet<E> c) {
        return locked(c, null, true);
    }

    public static <E> XSortedSet<E> locked(XSortedSet<E> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> XSortedSet<E> locked(XSortedSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (XSortedSet<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    @SuppressWarnings("unchecked")
    private static <E> XSortedSet<E> locked0(XSortedSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof Serializable) {
            if (c instanceof MASortedSet<?>) {
                if (c instanceof MANavigableSet<?>) {
                    return new LockedMANavigableSetWithSerializable<E>(
                        (MANavigableSet<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMASortedSetWithSerializable<E>(
                    (MASortedSet<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof XNavigableSet<?>) {
                return new LockedXNavigableSetWithSerializable<E>(
                    (XNavigableSet<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedXSortedSetWithSerializable<E>(c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MASortedSet<?>) {
            if (c instanceof MANavigableSet<?>) {
                if (c instanceof MANavigableSet.MANavigableSetView<?>) {
                    if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                        return new LockedMANavigableMapMANavigableKeySetView<E, Object>(
                            (MANavigableMap.MANavigableKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
                    }
                    return new LockedMANavigableSetMANavigableSetView<E>(
                        (MANavigableSet.MANavigableSetView<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMANavigableSet<E>(
                    (MANavigableSet<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof MASortedSet.MASortedSetView<?>) {
                if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
                    return new LockedMASortedMapMASortedKeySetView<E, Object>(
                        (MASortedMap.MASortedKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMASortedSetMASortedSetView<E>(
                    (MASortedSet.MASortedSetView<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMASortedSet<E>(
                (MASortedSet<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof XNavigableSet<?>) {
            if (c instanceof XNavigableSet.XNavigableSetView<?>) {
                if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
                    return new LockedXNavigableMapXNavigableKeySetView<E>(
                        (XNavigableMap.XNavigableKeySetView<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedXNavigableSetXNavigableSetView<E>(
                    (XNavigableSet.XNavigableSetView<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedXNavigableSet<E>(
                (XNavigableSet<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof XSortedSet.XSortedSetView<?>) {
            if (c instanceof XSortedMap.XSortedKeySetView<?>) {
                return new LockedXSortedMapXSortedKeySetView<E>(
                    (XSortedMap.XSortedKeySetView<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedXSortedSetXSortedSetView<E>(
                (XSortedSet.XSortedSetView<E>)c, readWriteLock, usingInternalLock);
        }
        return new LockedXSortedSet<E>(c, readWriteLock, usingInternalLock);
    }

    public static <E> XSortedSet.XSortedSetView<E> locked(XSortedSet.XSortedSetView<E> c) {
        return locked(c, null, true);
    }

    public static <E> XSortedSet.XSortedSetView<E> locked(XSortedSet.XSortedSetView<E> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> XSortedSet.XSortedSetView<E> locked(XSortedSet.XSortedSetView<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (XSortedSet.XSortedSetView<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    @SuppressWarnings("unchecked")
    private static <E> XSortedSet.XSortedSetView<E> locked0(XSortedSet.XSortedSetView<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof MANavigableSet.MANavigableSetView<?>) {
            if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                return new LockedMANavigableMapMANavigableKeySetView<E, Object>(
                    (MANavigableMap.MANavigableKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMANavigableSetMANavigableSetView<E>(
                (MANavigableSet.MANavigableSetView<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MASortedSet.MASortedSetView<?>) {
            if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
                return new LockedMASortedMapMASortedKeySetView<E, Object>(
                    (MASortedMap.MASortedKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMASortedSetMASortedSetView<E>(
                (MASortedSet.MASortedSetView<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof XNavigableSet.XNavigableSetView<?>) {
            if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
                return new LockedXNavigableMapXNavigableKeySetView<E>(
                    (XNavigableMap.XNavigableKeySetView<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedXNavigableSetXNavigableSetView<E>(
                (XNavigableSet.XNavigableSetView<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof XSortedMap.XSortedKeySetView<?>) {
            return new LockedXSortedMapXSortedKeySetView<E>(
                (XSortedMap.XSortedKeySetView<E>)c, readWriteLock, usingInternalLock);
        }
        return new LockedXSortedSetXSortedSetView<E>(c, readWriteLock, usingInternalLock);
    }

    public static <K> XSortedMap.XSortedKeySetView<K> locked(XSortedMap.XSortedKeySetView<K> c) {
        return locked(c, null, true);
    }

    public static <K> XSortedMap.XSortedKeySetView<K> locked(XSortedMap.XSortedKeySetView<K> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K> XSortedMap.XSortedKeySetView<K> locked(XSortedMap.XSortedKeySetView<K> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (XSortedMap.XSortedKeySetView<K>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    @SuppressWarnings("unchecked")
    private static <K> XSortedMap.XSortedKeySetView<K> locked0(XSortedMap.XSortedKeySetView<K> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
            return new LockedMANavigableMapMANavigableKeySetView<K, Object>(
                (MANavigableMap.MANavigableKeySetView<K, Object>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
            return new LockedMASortedMapMASortedKeySetView<K, Object>(
                (MASortedMap.MASortedKeySetView<K, Object>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
            return new LockedXNavigableMapXNavigableKeySetView<K>(
                (XNavigableMap.XNavigableKeySetView<K>)c, readWriteLock, usingInternalLock);
        }
        return new LockedXSortedMapXSortedKeySetView<K>(c, readWriteLock, usingInternalLock);
    }

    public static <E> XNavigableSet<E> locked(XNavigableSet<E> c) {
        return locked(c, null, true);
    }

    public static <E> XNavigableSet<E> locked(XNavigableSet<E> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> XNavigableSet<E> locked(XNavigableSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (XNavigableSet<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    @SuppressWarnings("unchecked")
    private static <E> XNavigableSet<E> locked0(XNavigableSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof Serializable) {
            if (c instanceof MANavigableSet<?>) {
                return new LockedMANavigableSetWithSerializable<E>(
                    (MANavigableSet<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedXNavigableSetWithSerializable<E>(c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MANavigableSet<?>) {
            if (c instanceof MANavigableSet.MANavigableSetView<?>) {
                if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                    return new LockedMANavigableMapMANavigableKeySetView<E, Object>(
                        (MANavigableMap.MANavigableKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMANavigableSetMANavigableSetView<E>(
                    (MANavigableSet.MANavigableSetView<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMANavigableSet<E>(
                (MANavigableSet<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof XNavigableSet.XNavigableSetView<?>) {
            if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
                return new LockedXNavigableMapXNavigableKeySetView<E>(
                    (XNavigableMap.XNavigableKeySetView<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedXNavigableSetXNavigableSetView<E>(
                (XNavigableSet.XNavigableSetView<E>)c, readWriteLock, usingInternalLock);
        }
        return new LockedXNavigableSet<E>(c, readWriteLock, usingInternalLock);
    }

    public static <E> XNavigableSet.XNavigableSetView<E> locked(XNavigableSet.XNavigableSetView<E> c) {
        return locked(c, null, true);
    }

    public static <E> XNavigableSet.XNavigableSetView<E> locked(XNavigableSet.XNavigableSetView<E> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> XNavigableSet.XNavigableSetView<E> locked(XNavigableSet.XNavigableSetView<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (XNavigableSet.XNavigableSetView<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    @SuppressWarnings("unchecked")
    private static <E> XNavigableSet.XNavigableSetView<E> locked0(XNavigableSet.XNavigableSetView<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof MANavigableSet.MANavigableSetView<?>) {
            if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                return new LockedMANavigableMapMANavigableKeySetView<E, Object>(
                    (MANavigableMap.MANavigableKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMANavigableSetMANavigableSetView<E>(
                (MANavigableSet.MANavigableSetView<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
            return new LockedXNavigableMapXNavigableKeySetView<E>(
                (XNavigableMap.XNavigableKeySetView<E>)c, readWriteLock, usingInternalLock);
        }
        return new LockedXNavigableSetXNavigableSetView<E>(c, readWriteLock, usingInternalLock);
    }

    public static <K> XNavigableMap.XNavigableKeySetView<K> locked(XNavigableMap.XNavigableKeySetView<K> c) {
        return locked(c, null, true);
    }

    public static <K> XNavigableMap.XNavigableKeySetView<K> locked(XNavigableMap.XNavigableKeySetView<K> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K> XNavigableMap.XNavigableKeySetView<K> locked(XNavigableMap.XNavigableKeySetView<K> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (XNavigableMap.XNavigableKeySetView<K>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    @SuppressWarnings("unchecked")
    private static <K> XNavigableMap.XNavigableKeySetView<K> locked0(XNavigableMap.XNavigableKeySetView<K> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
            return new LockedMANavigableMapMANavigableKeySetView<K, Object>(
                (MANavigableMap.MANavigableKeySetView<K, Object>)c, readWriteLock, usingInternalLock);
        }
        return new LockedXNavigableMapXNavigableKeySetView<K>(c, readWriteLock, usingInternalLock);
    }

    public static <E> XOrderedSet<E> locked(XOrderedSet<E> c) {
        return locked(c, null, true);
    }

    public static <E> XOrderedSet<E> locked(XOrderedSet<E> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> XOrderedSet<E> locked(XOrderedSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (XOrderedSet<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    @SuppressWarnings("unchecked")
    private static <E> XOrderedSet<E> locked0(XOrderedSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof Serializable) {
            if (c instanceof MAOrderedSet<?>) {
                return new LockedMAOrderedSetWithSerializable<E>(
                    (MAOrderedSet<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedXOrderedSetWithSerializable<E>(c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MAOrderedSet<?>) {
            if (c instanceof MAOrderedSet.MAOrderedSetView<?>) {
                if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
                    return new LockedMAOrderedMapMAOrderedKeySetView<E, Object>(
                        (MAOrderedMap.MAOrderedKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMAOrderedSetMAOrderedSetView<E>(
                    (MAOrderedSet.MAOrderedSetView<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMAOrderedSet<E>(
                (MAOrderedSet<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof XOrderedSet.XOrderedSetView<?>) {
            if (c instanceof XOrderedMap.XOrderedKeySetView<?>) {
                return new LockedXOrderedMapXOrderedKeySetView<E>(
                    (XOrderedMap.XOrderedKeySetView<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedXOrderedSetXOrderedSetView<E>(
                (XOrderedSet.XOrderedSetView<E>)c, readWriteLock, usingInternalLock);
        }
        return new LockedXOrderedSet<E>(c, readWriteLock, usingInternalLock);
    }

    public static <E> XOrderedSet.XOrderedSetView<E> locked(XOrderedSet.XOrderedSetView<E> c) {
        return locked(c, null, true);
    }

    public static <E> XOrderedSet.XOrderedSetView<E> locked(XOrderedSet.XOrderedSetView<E> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> XOrderedSet.XOrderedSetView<E> locked(XOrderedSet.XOrderedSetView<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (XOrderedSet.XOrderedSetView<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    @SuppressWarnings("unchecked")
    private static <E> XOrderedSet.XOrderedSetView<E> locked0(XOrderedSet.XOrderedSetView<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof MAOrderedSet.MAOrderedSetView<?>) {
            if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
                return new LockedMAOrderedMapMAOrderedKeySetView<E, Object>(
                    (MAOrderedMap.MAOrderedKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMAOrderedSetMAOrderedSetView<E>(
                (MAOrderedSet.MAOrderedSetView<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof XOrderedMap.XOrderedKeySetView<?>) {
            return new LockedXOrderedMapXOrderedKeySetView<E>(
                (XOrderedMap.XOrderedKeySetView<E>)c, readWriteLock, usingInternalLock);
        }
        return new LockedXOrderedSetXOrderedSetView<E>(c, readWriteLock, usingInternalLock);
    }

    public static <K> XOrderedMap.XOrderedKeySetView<K> locked(XOrderedMap.XOrderedKeySetView<K> c) {
        return locked(c, null, true);
    }

    public static <K> XOrderedMap.XOrderedKeySetView<K> locked(XOrderedMap.XOrderedKeySetView<K> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K> XOrderedMap.XOrderedKeySetView<K> locked(XOrderedMap.XOrderedKeySetView<K> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (XOrderedMap.XOrderedKeySetView<K>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    @SuppressWarnings("unchecked")
    private static <K> XOrderedMap.XOrderedKeySetView<K> locked0(XOrderedMap.XOrderedKeySetView<K> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
            return new LockedMAOrderedMapMAOrderedKeySetView<K, Object>(
                (MAOrderedMap.MAOrderedKeySetView<K, Object>)c, readWriteLock, usingInternalLock);
        }
        return new LockedXOrderedMapXOrderedKeySetView<K>(c, readWriteLock, usingInternalLock);
    }

    public static <E> XList<E> locked(XList<E> c) {
        return locked(c, null, true);
    }

    public static <E> XList<E> locked(XList<E> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> XList<E> locked(XList<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (XList<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    private static <E> XList<E> locked0(XList<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof Serializable) {
            if (c instanceof RandomAccess) {
                if (c instanceof MAList<?>) {
                    return new LockedMAListWithSerializableRandomAccess<E>(
                        (MAList<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedXListWithSerializableRandomAccess<E>(c, readWriteLock, usingInternalLock);
            }
            if (c instanceof MAList<?>) {
                return new LockedMAListWithSerializable<E>(
                    (MAList<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedXListWithSerializable<E>(c, readWriteLock, usingInternalLock);
        }
        if (c instanceof RandomAccess) {
            if (c instanceof MAList<?>) {
                if (c instanceof MAList.MAListView<?>) {
                    return new LockedMAListMAListViewWithRandomAccess<E>(
                        (MAList.MAListView<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMAListWithRandomAccess<E>(
                    (MAList<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof XList.XListView<?>) {
                return new LockedXListXListViewWithRandomAccess<E>(
                    (XList.XListView<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedXListWithRandomAccess<E>(c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MAList<?>) {
            if (c instanceof MAList.MAListView<?>) {
                return new LockedMAListMAListView<E>(
                    (MAList.MAListView<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMAList<E>(
                (MAList<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof XList.XListView<?>) {
            return new LockedXListXListView<E>(
                (XList.XListView<E>)c, readWriteLock, usingInternalLock);
        }
        return new LockedXList<E>(c, readWriteLock, usingInternalLock);
    }

    public static <E> XList.XListView<E> locked(XList.XListView<E> c) {
        return locked(c, null, true);
    }

    public static <E> XList.XListView<E> locked(XList.XListView<E> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> XList.XListView<E> locked(XList.XListView<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (XList.XListView<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    private static <E> XList.XListView<E> locked0(XList.XListView<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof RandomAccess) {
            if (c instanceof MAList.MAListView<?>) {
                return new LockedMAListMAListViewWithRandomAccess<E>(
                    (MAList.MAListView<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedXListXListViewWithRandomAccess<E>(c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MAList.MAListView<?>) {
            return new LockedMAListMAListView<E>(
                (MAList.MAListView<E>)c, readWriteLock, usingInternalLock);
        }
        return new LockedXListXListView<E>(c, readWriteLock, usingInternalLock);
    }

    public static <E> MACollection<E> locked(MACollection<E> c) {
        return locked(c, null, true);
    }

    public static <E> MACollection<E> locked(MACollection<E> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> MACollection<E> locked(MACollection<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (MACollection<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    private static <E> MACollection<E> locked0(MACollection<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof Serializable) {
            if (c instanceof MAList<?>) {
                return new LockedMAListWithSerializable<E>(
                    (MAList<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof MASet<?>) {
                if (c instanceof MAOrderedSet<?>) {
                    return new LockedMAOrderedSetWithSerializable<E>(
                        (MAOrderedSet<E>)c, readWriteLock, usingInternalLock);
                }
                if (c instanceof MASortedSet<?>) {
                    if (c instanceof MANavigableSet<?>) {
                        return new LockedMANavigableSetWithSerializable<E>(
                            (MANavigableSet<E>)c, readWriteLock, usingInternalLock);
                    }
                    return new LockedMASortedSetWithSerializable<E>(
                        (MASortedSet<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMASetWithSerializable<E>(
                    (MASet<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMACollectionWithSerializable<E>(c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MAList<?>) {
            if (c instanceof MAList.MAListView<?>) {
                return new LockedMAListMAListView<E>(
                    (MAList.MAListView<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMAList<E>(
                (MAList<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MASet<?>) {
            if (c instanceof MAOrderedSet<?>) {
                if (c instanceof MAOrderedSet.MAOrderedSetView<?>) {
                    if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
                        return new LockedMAOrderedMapMAOrderedKeySetView<E, Object>(
                            (MAOrderedMap.MAOrderedKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
                    }
                    return new LockedMAOrderedSetMAOrderedSetView<E>(
                        (MAOrderedSet.MAOrderedSetView<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMAOrderedSet<E>(
                    (MAOrderedSet<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof MASortedSet<?>) {
                if (c instanceof MANavigableSet<?>) {
                    if (c instanceof MANavigableSet.MANavigableSetView<?>) {
                        if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                            return new LockedMANavigableMapMANavigableKeySetView<E, Object>(
                                (MANavigableMap.MANavigableKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
                        }
                        return new LockedMANavigableSetMANavigableSetView<E>(
                            (MANavigableSet.MANavigableSetView<E>)c, readWriteLock, usingInternalLock);
                    }
                    return new LockedMANavigableSet<E>(
                        (MANavigableSet<E>)c, readWriteLock, usingInternalLock);
                }
                if (c instanceof MASortedSet.MASortedSetView<?>) {
                    if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
                        return new LockedMASortedMapMASortedKeySetView<E, Object>(
                            (MASortedMap.MASortedKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
                    }
                    return new LockedMASortedSetMASortedSetView<E>(
                        (MASortedSet.MASortedSetView<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMASortedSet<E>(
                    (MASortedSet<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof MAMap.MAEntrySetView<?, ?>) {
                return new LockedMAMapMAEntrySetView(
                    (MAMap.MAEntrySetView)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof MAMap.MAKeySetView<?, ?>) {
                return new LockedMAMapMAKeySetView<E, Object>(
                    (MAMap.MAKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMASet<E>(
                (MASet<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MAMap.MAValuesView<?, ?>) {
            return new LockedMAMapMAValuesView<Object, E>(
                (MAMap.MAValuesView<Object, E>)c, readWriteLock, usingInternalLock);
        }
        return new LockedMACollection<E>(c, readWriteLock, usingInternalLock);
    }

    public static <E> MASet<E> locked(MASet<E> c) {
        return locked(c, null, true);
    }

    public static <E> MASet<E> locked(MASet<E> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> MASet<E> locked(MASet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (MASet<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    private static <E> MASet<E> locked0(MASet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof Serializable) {
            if (c instanceof MAOrderedSet<?>) {
                return new LockedMAOrderedSetWithSerializable<E>(
                    (MAOrderedSet<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof MASortedSet<?>) {
                if (c instanceof MANavigableSet<?>) {
                    return new LockedMANavigableSetWithSerializable<E>(
                        (MANavigableSet<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMASortedSetWithSerializable<E>(
                    (MASortedSet<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMASetWithSerializable<E>(c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MAOrderedSet<?>) {
            if (c instanceof MAOrderedSet.MAOrderedSetView<?>) {
                if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
                    return new LockedMAOrderedMapMAOrderedKeySetView<E, Object>(
                        (MAOrderedMap.MAOrderedKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMAOrderedSetMAOrderedSetView<E>(
                    (MAOrderedSet.MAOrderedSetView<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMAOrderedSet<E>(
                (MAOrderedSet<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MASortedSet<?>) {
            if (c instanceof MANavigableSet<?>) {
                if (c instanceof MANavigableSet.MANavigableSetView<?>) {
                    if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                        return new LockedMANavigableMapMANavigableKeySetView<E, Object>(
                            (MANavigableMap.MANavigableKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
                    }
                    return new LockedMANavigableSetMANavigableSetView<E>(
                        (MANavigableSet.MANavigableSetView<E>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMANavigableSet<E>(
                    (MANavigableSet<E>)c, readWriteLock, usingInternalLock);
            }
            if (c instanceof MASortedSet.MASortedSetView<?>) {
                if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
                    return new LockedMASortedMapMASortedKeySetView<E, Object>(
                        (MASortedMap.MASortedKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMASortedSetMASortedSetView<E>(
                    (MASortedSet.MASortedSetView<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMASortedSet<E>(
                (MASortedSet<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MAMap.MAEntrySetView<?, ?>) {
            return new LockedMAMapMAEntrySetView(
                (MAMap.MAEntrySetView)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MAMap.MAKeySetView<?, ?>) {
            return new LockedMAMapMAKeySetView<E, Object>(
                (MAMap.MAKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
        }
        return new LockedMASet<E>(c, readWriteLock, usingInternalLock);
    }

    public static <K, V> MAMap.MAKeySetView<K, V> locked(MAMap.MAKeySetView<K, V> c) {
        return locked(c, null, true);
    }

    public static <K, V> MAMap.MAKeySetView<K, V> locked(MAMap.MAKeySetView<K, V> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> MAMap.MAKeySetView<K, V> locked(MAMap.MAKeySetView<K, V> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (MAMap.MAKeySetView<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    private static <K, V> MAMap.MAKeySetView<K, V> locked0(MAMap.MAKeySetView<K, V> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
            return new LockedMAOrderedMapMAOrderedKeySetView<K, V>(
                (MAOrderedMap.MAOrderedKeySetView<K, V>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
            return new LockedMANavigableMapMANavigableKeySetView<K, V>(
                (MANavigableMap.MANavigableKeySetView<K, V>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
            return new LockedMASortedMapMASortedKeySetView<K, V>(
                (MASortedMap.MASortedKeySetView<K, V>)c, readWriteLock, usingInternalLock);
        }
        return new LockedMAMapMAKeySetView<K, V>(c, readWriteLock, usingInternalLock);
    }

    public static <K, V> MAMap.MAValuesView<K, V> locked(MAMap.MAValuesView<K, V> c) {
        return locked(c, null, true);
    }

    public static <K, V> MAMap.MAValuesView<K, V> locked(MAMap.MAValuesView<K, V> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> MAMap.MAValuesView<K, V> locked(MAMap.MAValuesView<K, V> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (MAMap.MAValuesView<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    private static <K, V> MAMap.MAValuesView<K, V> locked0(MAMap.MAValuesView<K, V> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        return new LockedMAMapMAValuesView<K, V>(c, readWriteLock, usingInternalLock);
    }

    public static <K, V> MAMap.MAEntrySetView<K, V> locked(MAMap.MAEntrySetView<K, V> c) {
        return locked(c, null, true);
    }

    public static <K, V> MAMap.MAEntrySetView<K, V> locked(MAMap.MAEntrySetView<K, V> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> MAMap.MAEntrySetView<K, V> locked(MAMap.MAEntrySetView<K, V> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (MAMap.MAEntrySetView<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    private static <K, V> MAMap.MAEntrySetView<K, V> locked0(MAMap.MAEntrySetView<K, V> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        return new LockedMAMapMAEntrySetView<K, V>(c, readWriteLock, usingInternalLock);
    }

    public static <E> MASortedSet<E> locked(MASortedSet<E> c) {
        return locked(c, null, true);
    }

    public static <E> MASortedSet<E> locked(MASortedSet<E> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> MASortedSet<E> locked(MASortedSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (MASortedSet<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    @SuppressWarnings("unchecked")
    private static <E> MASortedSet<E> locked0(MASortedSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof Serializable) {
            if (c instanceof MANavigableSet<?>) {
                return new LockedMANavigableSetWithSerializable<E>(
                    (MANavigableSet<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMASortedSetWithSerializable<E>(c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MANavigableSet<?>) {
            if (c instanceof MANavigableSet.MANavigableSetView<?>) {
                if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                    return new LockedMANavigableMapMANavigableKeySetView<E, Object>(
                        (MANavigableMap.MANavigableKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
                }
                return new LockedMANavigableSetMANavigableSetView<E>(
                    (MANavigableSet.MANavigableSetView<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMANavigableSet<E>(
                (MANavigableSet<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MASortedSet.MASortedSetView<?>) {
            if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
                return new LockedMASortedMapMASortedKeySetView<E, Object>(
                    (MASortedMap.MASortedKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMASortedSetMASortedSetView<E>(
                (MASortedSet.MASortedSetView<E>)c, readWriteLock, usingInternalLock);
        }
        return new LockedMASortedSet<E>(c, readWriteLock, usingInternalLock);
    }

    public static <E> MASortedSet.MASortedSetView<E> locked(MASortedSet.MASortedSetView<E> c) {
        return locked(c, null, true);
    }

    public static <E> MASortedSet.MASortedSetView<E> locked(MASortedSet.MASortedSetView<E> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> MASortedSet.MASortedSetView<E> locked(MASortedSet.MASortedSetView<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (MASortedSet.MASortedSetView<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    @SuppressWarnings("unchecked")
    private static <E> MASortedSet.MASortedSetView<E> locked0(MASortedSet.MASortedSetView<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof MANavigableSet.MANavigableSetView<?>) {
            if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                return new LockedMANavigableMapMANavigableKeySetView<E, Object>(
                    (MANavigableMap.MANavigableKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMANavigableSetMANavigableSetView<E>(
                (MANavigableSet.MANavigableSetView<E>)c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
            return new LockedMASortedMapMASortedKeySetView<E, Object>(
                (MASortedMap.MASortedKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
        }
        return new LockedMASortedSetMASortedSetView<E>(c, readWriteLock, usingInternalLock);
    }

    public static <K, V> MASortedMap.MASortedKeySetView<K, V> locked(MASortedMap.MASortedKeySetView<K, V> c) {
        return locked(c, null, true);
    }

    public static <K, V> MASortedMap.MASortedKeySetView<K, V> locked(MASortedMap.MASortedKeySetView<K, V> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> MASortedMap.MASortedKeySetView<K, V> locked(MASortedMap.MASortedKeySetView<K, V> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (MASortedMap.MASortedKeySetView<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    private static <K, V> MASortedMap.MASortedKeySetView<K, V> locked0(MASortedMap.MASortedKeySetView<K, V> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
            return new LockedMANavigableMapMANavigableKeySetView<K, V>(
                (MANavigableMap.MANavigableKeySetView<K, V>)c, readWriteLock, usingInternalLock);
        }
        return new LockedMASortedMapMASortedKeySetView<K, V>(c, readWriteLock, usingInternalLock);
    }

    public static <E> MANavigableSet<E> locked(MANavigableSet<E> c) {
        return locked(c, null, true);
    }

    public static <E> MANavigableSet<E> locked(MANavigableSet<E> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> MANavigableSet<E> locked(MANavigableSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (MANavigableSet<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    @SuppressWarnings("unchecked")
    private static <E> MANavigableSet<E> locked0(MANavigableSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof Serializable) {
            return new LockedMANavigableSetWithSerializable<E>(c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MANavigableSet.MANavigableSetView<?>) {
            if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                return new LockedMANavigableMapMANavigableKeySetView<E, Object>(
                    (MANavigableMap.MANavigableKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMANavigableSetMANavigableSetView<E>(
                (MANavigableSet.MANavigableSetView<E>)c, readWriteLock, usingInternalLock);
        }
        return new LockedMANavigableSet<E>(c, readWriteLock, usingInternalLock);
    }

    public static <E> MANavigableSet.MANavigableSetView<E> locked(MANavigableSet.MANavigableSetView<E> c) {
        return locked(c, null, true);
    }

    public static <E> MANavigableSet.MANavigableSetView<E> locked(MANavigableSet.MANavigableSetView<E> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> MANavigableSet.MANavigableSetView<E> locked(MANavigableSet.MANavigableSetView<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (MANavigableSet.MANavigableSetView<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    @SuppressWarnings("unchecked")
    private static <E> MANavigableSet.MANavigableSetView<E> locked0(MANavigableSet.MANavigableSetView<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
            return new LockedMANavigableMapMANavigableKeySetView<E, Object>(
                (MANavigableMap.MANavigableKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
        }
        return new LockedMANavigableSetMANavigableSetView<E>(c, readWriteLock, usingInternalLock);
    }

    public static <K, V> MANavigableMap.MANavigableKeySetView<K, V> locked(MANavigableMap.MANavigableKeySetView<K, V> c) {
        return locked(c, null, true);
    }

    public static <K, V> MANavigableMap.MANavigableKeySetView<K, V> locked(MANavigableMap.MANavigableKeySetView<K, V> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> MANavigableMap.MANavigableKeySetView<K, V> locked(MANavigableMap.MANavigableKeySetView<K, V> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (MANavigableMap.MANavigableKeySetView<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    private static <K, V> MANavigableMap.MANavigableKeySetView<K, V> locked0(MANavigableMap.MANavigableKeySetView<K, V> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        return new LockedMANavigableMapMANavigableKeySetView<K, V>(c, readWriteLock, usingInternalLock);
    }

    public static <E> MAOrderedSet<E> locked(MAOrderedSet<E> c) {
        return locked(c, null, true);
    }

    public static <E> MAOrderedSet<E> locked(MAOrderedSet<E> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> MAOrderedSet<E> locked(MAOrderedSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (MAOrderedSet<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    @SuppressWarnings("unchecked")
    private static <E> MAOrderedSet<E> locked0(MAOrderedSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof Serializable) {
            return new LockedMAOrderedSetWithSerializable<E>(c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MAOrderedSet.MAOrderedSetView<?>) {
            if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
                return new LockedMAOrderedMapMAOrderedKeySetView<E, Object>(
                    (MAOrderedMap.MAOrderedKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMAOrderedSetMAOrderedSetView<E>(
                (MAOrderedSet.MAOrderedSetView<E>)c, readWriteLock, usingInternalLock);
        }
        return new LockedMAOrderedSet<E>(c, readWriteLock, usingInternalLock);
    }

    public static <E> MAOrderedSet.MAOrderedSetView<E> locked(MAOrderedSet.MAOrderedSetView<E> c) {
        return locked(c, null, true);
    }

    public static <E> MAOrderedSet.MAOrderedSetView<E> locked(MAOrderedSet.MAOrderedSetView<E> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> MAOrderedSet.MAOrderedSetView<E> locked(MAOrderedSet.MAOrderedSetView<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (MAOrderedSet.MAOrderedSetView<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    @SuppressWarnings("unchecked")
    private static <E> MAOrderedSet.MAOrderedSetView<E> locked0(MAOrderedSet.MAOrderedSetView<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
            return new LockedMAOrderedMapMAOrderedKeySetView<E, Object>(
                (MAOrderedMap.MAOrderedKeySetView<E, Object>)c, readWriteLock, usingInternalLock);
        }
        return new LockedMAOrderedSetMAOrderedSetView<E>(c, readWriteLock, usingInternalLock);
    }

    public static <K, V> MAOrderedMap.MAOrderedKeySetView<K, V> locked(MAOrderedMap.MAOrderedKeySetView<K, V> c) {
        return locked(c, null, true);
    }

    public static <K, V> MAOrderedMap.MAOrderedKeySetView<K, V> locked(MAOrderedMap.MAOrderedKeySetView<K, V> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> MAOrderedMap.MAOrderedKeySetView<K, V> locked(MAOrderedMap.MAOrderedKeySetView<K, V> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (MAOrderedMap.MAOrderedKeySetView<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    private static <K, V> MAOrderedMap.MAOrderedKeySetView<K, V> locked0(MAOrderedMap.MAOrderedKeySetView<K, V> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        return new LockedMAOrderedMapMAOrderedKeySetView<K, V>(c, readWriteLock, usingInternalLock);
    }

    public static <E> MAList<E> locked(MAList<E> c) {
        return locked(c, null, true);
    }

    public static <E> MAList<E> locked(MAList<E> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> MAList<E> locked(MAList<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (MAList<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    private static <E> MAList<E> locked0(MAList<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof Serializable) {
            if (c instanceof RandomAccess) {
                return new LockedMAListWithSerializableRandomAccess<E>(c, readWriteLock, usingInternalLock);
            }
            return new LockedMAListWithSerializable<E>(c, readWriteLock, usingInternalLock);
        }
        if (c instanceof RandomAccess) {
            if (c instanceof MAList.MAListView<?>) {
                return new LockedMAListMAListViewWithRandomAccess<E>(
                    (MAList.MAListView<E>)c, readWriteLock, usingInternalLock);
            }
            return new LockedMAListWithRandomAccess<E>(c, readWriteLock, usingInternalLock);
        }
        if (c instanceof MAList.MAListView<?>) {
            return new LockedMAListMAListView<E>(
                (MAList.MAListView<E>)c, readWriteLock, usingInternalLock);
        }
        return new LockedMAList<E>(c, readWriteLock, usingInternalLock);
    }

    public static <E> MAList.MAListView<E> locked(MAList.MAListView<E> c) {
        return locked(c, null, true);
    }

    public static <E> MAList.MAListView<E> locked(MAList.MAListView<E> c, ReadWriteLock readWriteLock) {
        return locked(c, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> MAList.MAListView<E> locked(MAList.MAListView<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(c, readWriteLock)) {
            return c;
        }
        MACollections.validateLockSource("c", c);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (c instanceof Proxy) {
            Proxy proxy = (Proxy)c;
            proxies = proxy.getProxies();
            c = (MAList.MAListView<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    c = locked0(c, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                c = proxy.recreate(c);
            }
        }
        if (!isApplied) {
            c = locked0(c, readWriteLock, usingInternalLock);
        }
        return c;
    }

    private static <E> MAList.MAListView<E> locked0(MAList.MAListView<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (c instanceof RandomAccess) {
            return new LockedMAListMAListViewWithRandomAccess<E>(c, readWriteLock, usingInternalLock);
        }
        return new LockedMAListMAListView<E>(c, readWriteLock, usingInternalLock);
    }

    public static <E> Iterator<E> locked(Iterator<E> itr) {
        return locked(itr, null, true);
    }

    public static <E> Iterator<E> locked(Iterator<E> itr, ReadWriteLock readWriteLock) {
        return locked(itr, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> Iterator<E> locked(Iterator<E> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(itr, readWriteLock)) {
            return itr;
        }
        MACollections.validateLockSource("itr", itr);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (itr instanceof Proxy) {
            Proxy proxy = (Proxy)itr;
            proxies = proxy.getProxies();
            itr = (Iterator<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    itr = locked0(itr, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                itr = proxy.recreate(itr);
            }
        }
        if (!isApplied) {
            itr = locked0(itr, readWriteLock, usingInternalLock);
        }
        return itr;
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    private static <E> Iterator<E> locked0(Iterator<E> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (itr instanceof Serializable) {
            if (itr instanceof StandardMap.EntrySet.EntryIterator<?, ?>) {
                return new LockedStandardMapEntrySetEntryIteratorWithSerializable(
                    (StandardMap.EntrySet.EntryIterator)itr, readWriteLock, usingInternalLock);
            }
            if (itr instanceof ListIterator<?>) {
                return new LockedListIteratorWithSerializable<E>(
                    (ListIterator<E>)itr, readWriteLock, usingInternalLock);
            }
            return new LockedIteratorWithSerializable<E>(itr, readWriteLock, usingInternalLock);
        }
        if (itr instanceof XCollection.XIterator<?>) {
            if (itr instanceof MACollection.MAIterator<?>) {
                if (itr instanceof MAMap.MAValuesView.MAValuesIterator<?, ?>) {
                    return new LockedMAMapMAValuesViewMAValuesIterator<Object, E>(
                        (MAMap.MAValuesView.MAValuesIterator<Object, E>)itr, readWriteLock, usingInternalLock);
                }
                if (itr instanceof MAMap.MAEntrySetView.MAEntrySetIterator<?, ?>) {
                    return new LockedMAMapMAEntrySetViewMAEntrySetIterator(
                        (MAMap.MAEntrySetView.MAEntrySetIterator)itr, readWriteLock, usingInternalLock);
                }
                if (itr instanceof MAList.MAListIterator<?>) {
                    return new LockedMAListMAListIterator<E>(
                        (MAList.MAListIterator<E>)itr, readWriteLock, usingInternalLock);
                }
                if (itr instanceof MAMap.MAKeySetView.MAKeySetIterator<?, ?>) {
                    return new LockedMAMapMAKeySetViewMAKeySetIterator<E, Object>(
                        (MAMap.MAKeySetView.MAKeySetIterator<E, Object>)itr, readWriteLock, usingInternalLock);
                }
                return new LockedMACollectionMAIterator<E>(
                    (MACollection.MAIterator<E>)itr, readWriteLock, usingInternalLock);
            }
            if (itr instanceof XList.XListIterator<?>) {
                return new LockedXListXListIterator<E>(
                    (XList.XListIterator<E>)itr, readWriteLock, usingInternalLock);
            }
            if (itr instanceof XMap.XEntrySetView.XEntrySetIterator<?, ?>) {
                return new LockedXMapXEntrySetViewXEntrySetIterator(
                    (XMap.XEntrySetView.XEntrySetIterator)itr, readWriteLock, usingInternalLock);
            }
            return new LockedXCollectionXIterator<E>(
                (XCollection.XIterator<E>)itr, readWriteLock, usingInternalLock);
        }
        if (itr instanceof StandardMap.EntrySet.EntryIterator<?, ?>) {
            return new LockedStandardMapEntrySetEntryIterator(
                (StandardMap.EntrySet.EntryIterator)itr, readWriteLock, usingInternalLock);
        }
        if (itr instanceof ListIterator<?>) {
            return new LockedListIterator<E>(
                (ListIterator<E>)itr, readWriteLock, usingInternalLock);
        }
        return new LockedIterator<E>(itr, readWriteLock, usingInternalLock);
    }

    public static <E> ListIterator<E> locked(ListIterator<E> itr) {
        return locked(itr, null, true);
    }

    public static <E> ListIterator<E> locked(ListIterator<E> itr, ReadWriteLock readWriteLock) {
        return locked(itr, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> ListIterator<E> locked(ListIterator<E> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(itr, readWriteLock)) {
            return itr;
        }
        MACollections.validateLockSource("itr", itr);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (itr instanceof Proxy) {
            Proxy proxy = (Proxy)itr;
            proxies = proxy.getProxies();
            itr = (ListIterator<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    itr = locked0(itr, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                itr = proxy.recreate(itr);
            }
        }
        if (!isApplied) {
            itr = locked0(itr, readWriteLock, usingInternalLock);
        }
        return itr;
    }

    private static <E> ListIterator<E> locked0(ListIterator<E> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (itr instanceof Serializable) {
            return new LockedListIteratorWithSerializable<E>(itr, readWriteLock, usingInternalLock);
        }
        if (itr instanceof MAList.MAListIterator<?>) {
            return new LockedMAListMAListIterator<E>(
                (MAList.MAListIterator<E>)itr, readWriteLock, usingInternalLock);
        }
        if (itr instanceof XList.XListIterator<?>) {
            return new LockedXListXListIterator<E>(
                (XList.XListIterator<E>)itr, readWriteLock, usingInternalLock);
        }
        return new LockedListIterator<E>(itr, readWriteLock, usingInternalLock);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> StandardMap.EntrySet.EntryIterator<K, V> locked(StandardMap.EntrySet.EntryIterator<K, V> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(itr, readWriteLock)) {
            return itr;
        }
        MACollections.validateLockSource("itr", itr);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (itr instanceof Proxy) {
            Proxy proxy = (Proxy)itr;
            proxies = proxy.getProxies();
            itr = (StandardMap.EntrySet.EntryIterator<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    itr = locked0(itr, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                itr = proxy.recreate(itr);
            }
        }
        if (!isApplied) {
            itr = locked0(itr, readWriteLock, usingInternalLock);
        }
        return itr;
    }

    private static <K, V> StandardMap.EntrySet.EntryIterator<K, V> locked0(StandardMap.EntrySet.EntryIterator<K, V> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (itr instanceof Serializable) {
            return new LockedStandardMapEntrySetEntryIteratorWithSerializable<K, V>(itr, readWriteLock, usingInternalLock);
        }
        return new LockedStandardMapEntrySetEntryIterator<K, V>(itr, readWriteLock, usingInternalLock);
    }

    public static <E> XCollection.XIterator<E> locked(XCollection.XIterator<E> itr) {
        return locked(itr, null, true);
    }

    public static <E> XCollection.XIterator<E> locked(XCollection.XIterator<E> itr, ReadWriteLock readWriteLock) {
        return locked(itr, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> XCollection.XIterator<E> locked(XCollection.XIterator<E> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(itr, readWriteLock)) {
            return itr;
        }
        MACollections.validateLockSource("itr", itr);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (itr instanceof Proxy) {
            Proxy proxy = (Proxy)itr;
            proxies = proxy.getProxies();
            itr = (XCollection.XIterator<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    itr = locked0(itr, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                itr = proxy.recreate(itr);
            }
        }
        if (!isApplied) {
            itr = locked0(itr, readWriteLock, usingInternalLock);
        }
        return itr;
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    private static <E> XCollection.XIterator<E> locked0(XCollection.XIterator<E> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (itr instanceof MACollection.MAIterator<?>) {
            if (itr instanceof MAMap.MAValuesView.MAValuesIterator<?, ?>) {
                return new LockedMAMapMAValuesViewMAValuesIterator<Object, E>(
                    (MAMap.MAValuesView.MAValuesIterator<Object, E>)itr, readWriteLock, usingInternalLock);
            }
            if (itr instanceof MAMap.MAEntrySetView.MAEntrySetIterator<?, ?>) {
                return new LockedMAMapMAEntrySetViewMAEntrySetIterator(
                    (MAMap.MAEntrySetView.MAEntrySetIterator)itr, readWriteLock, usingInternalLock);
            }
            if (itr instanceof MAList.MAListIterator<?>) {
                return new LockedMAListMAListIterator<E>(
                    (MAList.MAListIterator<E>)itr, readWriteLock, usingInternalLock);
            }
            if (itr instanceof MAMap.MAKeySetView.MAKeySetIterator<?, ?>) {
                return new LockedMAMapMAKeySetViewMAKeySetIterator<E, Object>(
                    (MAMap.MAKeySetView.MAKeySetIterator<E, Object>)itr, readWriteLock, usingInternalLock);
            }
            return new LockedMACollectionMAIterator<E>(
                (MACollection.MAIterator<E>)itr, readWriteLock, usingInternalLock);
        }
        if (itr instanceof XList.XListIterator<?>) {
            return new LockedXListXListIterator<E>(
                (XList.XListIterator<E>)itr, readWriteLock, usingInternalLock);
        }
        if (itr instanceof XMap.XEntrySetView.XEntrySetIterator<?, ?>) {
            return new LockedXMapXEntrySetViewXEntrySetIterator(
                (XMap.XEntrySetView.XEntrySetIterator)itr, readWriteLock, usingInternalLock);
        }
        return new LockedXCollectionXIterator<E>(itr, readWriteLock, usingInternalLock);
    }

    public static <K, V> XMap.XEntrySetView.XEntrySetIterator<K, V> locked(XMap.XEntrySetView.XEntrySetIterator<K, V> itr) {
        return locked(itr, null, true);
    }

    public static <K, V> XMap.XEntrySetView.XEntrySetIterator<K, V> locked(XMap.XEntrySetView.XEntrySetIterator<K, V> itr, ReadWriteLock readWriteLock) {
        return locked(itr, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> XMap.XEntrySetView.XEntrySetIterator<K, V> locked(XMap.XEntrySetView.XEntrySetIterator<K, V> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(itr, readWriteLock)) {
            return itr;
        }
        MACollections.validateLockSource("itr", itr);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (itr instanceof Proxy) {
            Proxy proxy = (Proxy)itr;
            proxies = proxy.getProxies();
            itr = (XMap.XEntrySetView.XEntrySetIterator<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    itr = locked0(itr, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                itr = proxy.recreate(itr);
            }
        }
        if (!isApplied) {
            itr = locked0(itr, readWriteLock, usingInternalLock);
        }
        return itr;
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    private static <K, V> XMap.XEntrySetView.XEntrySetIterator<K, V> locked0(XMap.XEntrySetView.XEntrySetIterator<K, V> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (itr instanceof MAMap.MAEntrySetView.MAEntrySetIterator<?, ?>) {
            return new LockedMAMapMAEntrySetViewMAEntrySetIterator(
                (MAMap.MAEntrySetView.MAEntrySetIterator)itr, readWriteLock, usingInternalLock);
        }
        return new LockedXMapXEntrySetViewXEntrySetIterator<K, V>(itr, readWriteLock, usingInternalLock);
    }

    public static <E> XList.XListIterator<E> locked(XList.XListIterator<E> itr) {
        return locked(itr, null, true);
    }

    public static <E> XList.XListIterator<E> locked(XList.XListIterator<E> itr, ReadWriteLock readWriteLock) {
        return locked(itr, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> XList.XListIterator<E> locked(XList.XListIterator<E> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(itr, readWriteLock)) {
            return itr;
        }
        MACollections.validateLockSource("itr", itr);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (itr instanceof Proxy) {
            Proxy proxy = (Proxy)itr;
            proxies = proxy.getProxies();
            itr = (XList.XListIterator<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    itr = locked0(itr, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                itr = proxy.recreate(itr);
            }
        }
        if (!isApplied) {
            itr = locked0(itr, readWriteLock, usingInternalLock);
        }
        return itr;
    }

    private static <E> XList.XListIterator<E> locked0(XList.XListIterator<E> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (itr instanceof MAList.MAListIterator<?>) {
            return new LockedMAListMAListIterator<E>(
                (MAList.MAListIterator<E>)itr, readWriteLock, usingInternalLock);
        }
        return new LockedXListXListIterator<E>(itr, readWriteLock, usingInternalLock);
    }

    public static <E> MACollection.MAIterator<E> locked(MACollection.MAIterator<E> itr) {
        return locked(itr, null, true);
    }

    public static <E> MACollection.MAIterator<E> locked(MACollection.MAIterator<E> itr, ReadWriteLock readWriteLock) {
        return locked(itr, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> MACollection.MAIterator<E> locked(MACollection.MAIterator<E> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(itr, readWriteLock)) {
            return itr;
        }
        MACollections.validateLockSource("itr", itr);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (itr instanceof Proxy) {
            Proxy proxy = (Proxy)itr;
            proxies = proxy.getProxies();
            itr = (MACollection.MAIterator<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    itr = locked0(itr, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                itr = proxy.recreate(itr);
            }
        }
        if (!isApplied) {
            itr = locked0(itr, readWriteLock, usingInternalLock);
        }
        return itr;
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    private static <E> MACollection.MAIterator<E> locked0(MACollection.MAIterator<E> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (itr instanceof MAMap.MAValuesView.MAValuesIterator<?, ?>) {
            return new LockedMAMapMAValuesViewMAValuesIterator<Object, E>(
                (MAMap.MAValuesView.MAValuesIterator<Object, E>)itr, readWriteLock, usingInternalLock);
        }
        if (itr instanceof MAMap.MAEntrySetView.MAEntrySetIterator<?, ?>) {
            return new LockedMAMapMAEntrySetViewMAEntrySetIterator(
                (MAMap.MAEntrySetView.MAEntrySetIterator)itr, readWriteLock, usingInternalLock);
        }
        if (itr instanceof MAList.MAListIterator<?>) {
            return new LockedMAListMAListIterator<E>(
                (MAList.MAListIterator<E>)itr, readWriteLock, usingInternalLock);
        }
        if (itr instanceof MAMap.MAKeySetView.MAKeySetIterator<?, ?>) {
            return new LockedMAMapMAKeySetViewMAKeySetIterator<E, Object>(
                (MAMap.MAKeySetView.MAKeySetIterator<E, Object>)itr, readWriteLock, usingInternalLock);
        }
        return new LockedMACollectionMAIterator<E>(itr, readWriteLock, usingInternalLock);
    }

    public static <K, V> MAMap.MAKeySetView.MAKeySetIterator<K, V> locked(MAMap.MAKeySetView.MAKeySetIterator<K, V> itr) {
        return locked(itr, null, true);
    }

    public static <K, V> MAMap.MAKeySetView.MAKeySetIterator<K, V> locked(MAMap.MAKeySetView.MAKeySetIterator<K, V> itr, ReadWriteLock readWriteLock) {
        return locked(itr, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> MAMap.MAKeySetView.MAKeySetIterator<K, V> locked(MAMap.MAKeySetView.MAKeySetIterator<K, V> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(itr, readWriteLock)) {
            return itr;
        }
        MACollections.validateLockSource("itr", itr);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (itr instanceof Proxy) {
            Proxy proxy = (Proxy)itr;
            proxies = proxy.getProxies();
            itr = (MAMap.MAKeySetView.MAKeySetIterator<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    itr = locked0(itr, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                itr = proxy.recreate(itr);
            }
        }
        if (!isApplied) {
            itr = locked0(itr, readWriteLock, usingInternalLock);
        }
        return itr;
    }

    private static <K, V> MAMap.MAKeySetView.MAKeySetIterator<K, V> locked0(MAMap.MAKeySetView.MAKeySetIterator<K, V> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        return new LockedMAMapMAKeySetViewMAKeySetIterator<K, V>(itr, readWriteLock, usingInternalLock);
    }

    public static <E> MAList.MAListIterator<E> locked(MAList.MAListIterator<E> itr) {
        return locked(itr, null, true);
    }

    public static <E> MAList.MAListIterator<E> locked(MAList.MAListIterator<E> itr, ReadWriteLock readWriteLock) {
        return locked(itr, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <E> MAList.MAListIterator<E> locked(MAList.MAListIterator<E> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(itr, readWriteLock)) {
            return itr;
        }
        MACollections.validateLockSource("itr", itr);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (itr instanceof Proxy) {
            Proxy proxy = (Proxy)itr;
            proxies = proxy.getProxies();
            itr = (MAList.MAListIterator<E>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    itr = locked0(itr, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                itr = proxy.recreate(itr);
            }
        }
        if (!isApplied) {
            itr = locked0(itr, readWriteLock, usingInternalLock);
        }
        return itr;
    }

    private static <E> MAList.MAListIterator<E> locked0(MAList.MAListIterator<E> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        return new LockedMAListMAListIterator<E>(itr, readWriteLock, usingInternalLock);
    }

    public static <K, V> MAMap.MAEntrySetView.MAEntrySetIterator<K, V> locked(MAMap.MAEntrySetView.MAEntrySetIterator<K, V> itr) {
        return locked(itr, null, true);
    }

    public static <K, V> MAMap.MAEntrySetView.MAEntrySetIterator<K, V> locked(MAMap.MAEntrySetView.MAEntrySetIterator<K, V> itr, ReadWriteLock readWriteLock) {
        return locked(itr, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> MAMap.MAEntrySetView.MAEntrySetIterator<K, V> locked(MAMap.MAEntrySetView.MAEntrySetIterator<K, V> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(itr, readWriteLock)) {
            return itr;
        }
        MACollections.validateLockSource("itr", itr);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (itr instanceof Proxy) {
            Proxy proxy = (Proxy)itr;
            proxies = proxy.getProxies();
            itr = (MAMap.MAEntrySetView.MAEntrySetIterator<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    itr = locked0(itr, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                itr = proxy.recreate(itr);
            }
        }
        if (!isApplied) {
            itr = locked0(itr, readWriteLock, usingInternalLock);
        }
        return itr;
    }

    private static <K, V> MAMap.MAEntrySetView.MAEntrySetIterator<K, V> locked0(MAMap.MAEntrySetView.MAEntrySetIterator<K, V> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        return new LockedMAMapMAEntrySetViewMAEntrySetIterator<K, V>(itr, readWriteLock, usingInternalLock);
    }

    public static <K, V> MAMap.MAValuesView.MAValuesIterator<K, V> locked(MAMap.MAValuesView.MAValuesIterator<K, V> itr) {
        return locked(itr, null, true);
    }

    public static <K, V> MAMap.MAValuesView.MAValuesIterator<K, V> locked(MAMap.MAValuesView.MAValuesIterator<K, V> itr, ReadWriteLock readWriteLock) {
        return locked(itr, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> MAMap.MAValuesView.MAValuesIterator<K, V> locked(MAMap.MAValuesView.MAValuesIterator<K, V> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(itr, readWriteLock)) {
            return itr;
        }
        MACollections.validateLockSource("itr", itr);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (itr instanceof Proxy) {
            Proxy proxy = (Proxy)itr;
            proxies = proxy.getProxies();
            itr = (MAMap.MAValuesView.MAValuesIterator<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    itr = locked0(itr, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                itr = proxy.recreate(itr);
            }
        }
        if (!isApplied) {
            itr = locked0(itr, readWriteLock, usingInternalLock);
        }
        return itr;
    }

    private static <K, V> MAMap.MAValuesView.MAValuesIterator<K, V> locked0(MAMap.MAValuesView.MAValuesIterator<K, V> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        return new LockedMAMapMAValuesViewMAValuesIterator<K, V>(itr, readWriteLock, usingInternalLock);
    }

    public static <K, V> Map.Entry<K, V> locked(Map.Entry<K, V> e) {
        return locked(e, null, true);
    }

    public static <K, V> Map.Entry<K, V> locked(Map.Entry<K, V> e, ReadWriteLock readWriteLock) {
        return locked(e, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> Map.Entry<K, V> locked(Map.Entry<K, V> e, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(e, readWriteLock)) {
            return e;
        }
        MACollections.validateLockSource("e", e);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (e instanceof Proxy) {
            Proxy proxy = (Proxy)e;
            proxies = proxy.getProxies();
            e = (Map.Entry<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    e = locked0(e, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                e = proxy.recreate(e);
            }
        }
        if (!isApplied) {
            e = locked0(e, readWriteLock, usingInternalLock);
        }
        return e;
    }

    private static <K, V> Map.Entry<K, V> locked0(Map.Entry<K, V> e, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (e instanceof Serializable) {
            return new LockedMapEntryWithSerializable<K, V>(e, readWriteLock, usingInternalLock);
        }
        if (e instanceof XMap.XEntry<?, ?>) {
            if (e instanceof MAMap.MAEntry<?, ?>) {
                return new LockedMAMapMAEntry<K, V>(
                    (MAMap.MAEntry<K, V>)e, readWriteLock, usingInternalLock);
            }
            return new LockedXMapXEntry<K, V>(
                (XMap.XEntry<K, V>)e, readWriteLock, usingInternalLock);
        }
        return new LockedMapEntry<K, V>(e, readWriteLock, usingInternalLock);
    }

    public static <K, V> XMap.XEntry<K, V> locked(XMap.XEntry<K, V> e) {
        return locked(e, null, true);
    }

    public static <K, V> XMap.XEntry<K, V> locked(XMap.XEntry<K, V> e, ReadWriteLock readWriteLock) {
        return locked(e, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> XMap.XEntry<K, V> locked(XMap.XEntry<K, V> e, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(e, readWriteLock)) {
            return e;
        }
        MACollections.validateLockSource("e", e);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (e instanceof Proxy) {
            Proxy proxy = (Proxy)e;
            proxies = proxy.getProxies();
            e = (XMap.XEntry<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    e = locked0(e, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                e = proxy.recreate(e);
            }
        }
        if (!isApplied) {
            e = locked0(e, readWriteLock, usingInternalLock);
        }
        return e;
    }

    private static <K, V> XMap.XEntry<K, V> locked0(XMap.XEntry<K, V> e, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (e instanceof MAMap.MAEntry<?, ?>) {
            return new LockedMAMapMAEntry<K, V>(
                (MAMap.MAEntry<K, V>)e, readWriteLock, usingInternalLock);
        }
        return new LockedXMapXEntry<K, V>(e, readWriteLock, usingInternalLock);
    }

    public static <K, V> MAMap.MAEntry<K, V> locked(MAMap.MAEntry<K, V> e) {
        return locked(e, null, true);
    }

    public static <K, V> MAMap.MAEntry<K, V> locked(MAMap.MAEntry<K, V> e, ReadWriteLock readWriteLock) {
        return locked(e, readWriteLock, readWriteLock == null);
    }

    @SuppressWarnings("unchecked")
    private static <K, V> MAMap.MAEntry<K, V> locked(MAMap.MAEntry<K, V> e, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        if (MACollections.isLocked(e, readWriteLock)) {
            return e;
        }
        MACollections.validateLockSource("e", e);
        Proxy[] proxies = null;
        boolean isApplied = false;
        if (e instanceof Proxy) {
            Proxy proxy = (Proxy)e;
            proxies = proxy.getProxies();
            e = (MAMap.MAEntry<K, V>)proxies[0].getRealObject();
        }
        if (proxies != null) {
            for (Proxy proxy : proxies) {
                if (!isApplied && proxy instanceof GatewayProxy) {
                    e = locked0(e, readWriteLock, usingInternalLock);
                    isApplied = true;
                }
                e = proxy.recreate(e);
            }
        }
        if (!isApplied) {
            e = locked0(e, readWriteLock, usingInternalLock);
        }
        return e;
    }

    private static <K, V> MAMap.MAEntry<K, V> locked0(MAMap.MAEntry<K, V> e, ReadWriteLock readWriteLock, boolean usingInternalLock) {
        return new LockedMAMapMAEntry<K, V>(e, readWriteLock, usingInternalLock);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(Map<K, V> lockedMap, LockMode lockMode, Function<Map<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            return lockingFunction.apply(lockedMap);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (Map<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (Map<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        return toppestProxy.locking(lockedMap, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(Map<K, V> lockedMap, LockMode lockMode, Consumer<Map<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            lockingConsumer.accept(lockedMap);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (Map<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (Map<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        toppestProxy.locking(lockedMap, lockingManager.state, lockingConsumer);
    }

    private static <K, V> Map<K, V> locking(Map<K, V> m, LockingManager lockingManager) {
        if (m instanceof Serializable) {
            if (m instanceof XMap<?, ?>) {
                if (m instanceof MAMap<?, ?>) {
                    if (m instanceof MAOrderedMap<?, ?>) {
                        return new LockingMAOrderedMapWithSerializable<K, V>(
                            (MAOrderedMap<K, V>)m, lockingManager);
                    }
                    if (m instanceof MASortedMap<?, ?>) {
                        if (m instanceof MANavigableMap<?, ?>) {
                            return new LockingMANavigableMapWithSerializable<K, V>(
                                (MANavigableMap<K, V>)m, lockingManager);
                        }
                        return new LockingMASortedMapWithSerializable<K, V>(
                            (MASortedMap<K, V>)m, lockingManager);
                    }
                    return new LockingMAMapWithSerializable<K, V>(
                        (MAMap<K, V>)m, lockingManager);
                }
                if (m instanceof XOrderedMap<?, ?>) {
                    return new LockingXOrderedMapWithSerializable<K, V>(
                        (XOrderedMap<K, V>)m, lockingManager);
                }
                if (m instanceof XSortedMap<?, ?>) {
                    if (m instanceof XNavigableMap<?, ?>) {
                        return new LockingXNavigableMapWithSerializable<K, V>(
                            (XNavigableMap<K, V>)m, lockingManager);
                    }
                    return new LockingXSortedMapWithSerializable<K, V>(
                        (XSortedMap<K, V>)m, lockingManager);
                }
                return new LockingXMapWithSerializable<K, V>(
                    (XMap<K, V>)m, lockingManager);
            }
            if (m instanceof StandardMap<?, ?>) {
                if (m instanceof StandardSortedMap<?, ?>) {
                    if (m instanceof StandardNavigableMap<?, ?>) {
                        return new LockingStandardNavigableMapWithSerializable<K, V>(
                            (StandardNavigableMap<K, V>)m, lockingManager);
                    }
                    return new LockingStandardSortedMapWithSerializable<K, V>(
                        (StandardSortedMap<K, V>)m, lockingManager);
                }
                return new LockingStandardMapWithSerializable<K, V>(
                    (StandardMap<K, V>)m, lockingManager);
            }
            if (m instanceof SortedMap<?, ?>) {
                if (m instanceof NavigableMap<?, ?>) {
                    return locking(standard((NavigableMap<K, V>)m), lockingManager);
                }
                return locking(standard((SortedMap<K, V>)m), lockingManager);
            }
            return locking(standard(standard(m)), lockingManager);
        }
        if (m instanceof XMap<?, ?>) {
            if (m instanceof MAMap<?, ?>) {
                if (m instanceof MAOrderedMap<?, ?>) {
                    if (m instanceof MAOrderedMap.MAOrderedMapView<?, ?>) {
                        return new LockingMAOrderedMapMAOrderedMapView<K, V>(
                            (MAOrderedMap.MAOrderedMapView<K, V>)m, lockingManager);
                    }
                    return new LockingMAOrderedMap<K, V>(
                        (MAOrderedMap<K, V>)m, lockingManager);
                }
                if (m instanceof MASortedMap<?, ?>) {
                    if (m instanceof MANavigableMap<?, ?>) {
                        if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
                            return new LockingMANavigableMapMANavigableMapView<K, V>(
                                (MANavigableMap.MANavigableMapView<K, V>)m, lockingManager);
                        }
                        return new LockingMANavigableMap<K, V>(
                            (MANavigableMap<K, V>)m, lockingManager);
                    }
                    if (m instanceof MASortedMap.MASortedMapView<?, ?>) {
                        return new LockingMASortedMapMASortedMapView<K, V>(
                            (MASortedMap.MASortedMapView<K, V>)m, lockingManager);
                    }
                    return new LockingMASortedMap<K, V>(
                        (MASortedMap<K, V>)m, lockingManager);
                }
                return new LockingMAMap<K, V>(
                    (MAMap<K, V>)m, lockingManager);
            }
            if (m instanceof XOrderedMap<?, ?>) {
                if (m instanceof XOrderedMap.XOrderedMapView<?, ?>) {
                    return new LockingXOrderedMapXOrderedMapView<K, V>(
                        (XOrderedMap.XOrderedMapView<K, V>)m, lockingManager);
                }
                return new LockingXOrderedMap<K, V>(
                    (XOrderedMap<K, V>)m, lockingManager);
            }
            if (m instanceof XSortedMap<?, ?>) {
                if (m instanceof XNavigableMap<?, ?>) {
                    if (m instanceof XNavigableMap.XNavigableMapView<?, ?>) {
                        return new LockingXNavigableMapXNavigableMapView<K, V>(
                            (XNavigableMap.XNavigableMapView<K, V>)m, lockingManager);
                    }
                    return new LockingXNavigableMap<K, V>(
                        (XNavigableMap<K, V>)m, lockingManager);
                }
                if (m instanceof XSortedMap.XSortedMapView<?, ?>) {
                    return new LockingXSortedMapXSortedMapView<K, V>(
                        (XSortedMap.XSortedMapView<K, V>)m, lockingManager);
                }
                return new LockingXSortedMap<K, V>(
                    (XSortedMap<K, V>)m, lockingManager);
            }
            return new LockingXMap<K, V>(
                (XMap<K, V>)m, lockingManager);
        }
        if (m instanceof StandardMap<?, ?>) {
            if (m instanceof StandardSortedMap<?, ?>) {
                if (m instanceof StandardNavigableMap<?, ?>) {
                    return new LockingStandardNavigableMap<K, V>(
                        (StandardNavigableMap<K, V>)m, lockingManager);
                }
                return new LockingStandardSortedMap<K, V>(
                    (StandardSortedMap<K, V>)m, lockingManager);
            }
            return new LockingStandardMap<K, V>(
                (StandardMap<K, V>)m, lockingManager);
        }
        if (m instanceof SortedMap<?, ?>) {
            if (m instanceof NavigableMap<?, ?>) {
                return locking(standard((NavigableMap<K, V>)m), lockingManager);
            }
            return locking(standard((SortedMap<K, V>)m), lockingManager);
        }
        return locking(standard(standard(m)), lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(SortedMap<K, V> lockedMap, LockMode lockMode, Function<SortedMap<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            return lockingFunction.apply(lockedMap);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (SortedMap<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (SortedMap<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        return toppestProxy.locking(lockedMap, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(SortedMap<K, V> lockedMap, LockMode lockMode, Consumer<SortedMap<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            lockingConsumer.accept(lockedMap);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (SortedMap<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (SortedMap<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        toppestProxy.locking(lockedMap, lockingManager.state, lockingConsumer);
    }

    private static <K, V> SortedMap<K, V> locking(SortedMap<K, V> m, LockingManager lockingManager) {
        if (m instanceof Serializable) {
            if (m instanceof MASortedMap<?, ?>) {
                if (m instanceof MANavigableMap<?, ?>) {
                    return new LockingMANavigableMapWithSerializable<K, V>(
                        (MANavigableMap<K, V>)m, lockingManager);
                }
                return new LockingMASortedMapWithSerializable<K, V>(
                    (MASortedMap<K, V>)m, lockingManager);
            }
            if (m instanceof XSortedMap<?, ?>) {
                if (m instanceof XNavigableMap<?, ?>) {
                    return new LockingXNavigableMapWithSerializable<K, V>(
                        (XNavigableMap<K, V>)m, lockingManager);
                }
                return new LockingXSortedMapWithSerializable<K, V>(
                    (XSortedMap<K, V>)m, lockingManager);
            }
            if (m instanceof StandardSortedMap<?, ?>) {
                if (m instanceof StandardNavigableMap<?, ?>) {
                    return new LockingStandardNavigableMapWithSerializable<K, V>(
                        (StandardNavigableMap<K, V>)m, lockingManager);
                }
                return new LockingStandardSortedMapWithSerializable<K, V>(
                    (StandardSortedMap<K, V>)m, lockingManager);
            }
            if (m instanceof NavigableMap<?, ?>) {
                return locking(standard((NavigableMap<K, V>)m), lockingManager);
            }
            return locking(standard(standard(m)), lockingManager);
        }
        if (m instanceof MASortedMap<?, ?>) {
            if (m instanceof MANavigableMap<?, ?>) {
                if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
                    return new LockingMANavigableMapMANavigableMapView<K, V>(
                        (MANavigableMap.MANavigableMapView<K, V>)m, lockingManager);
                }
                return new LockingMANavigableMap<K, V>(
                    (MANavigableMap<K, V>)m, lockingManager);
            }
            if (m instanceof MASortedMap.MASortedMapView<?, ?>) {
                return new LockingMASortedMapMASortedMapView<K, V>(
                    (MASortedMap.MASortedMapView<K, V>)m, lockingManager);
            }
            return new LockingMASortedMap<K, V>(
                (MASortedMap<K, V>)m, lockingManager);
        }
        if (m instanceof XSortedMap<?, ?>) {
            if (m instanceof XNavigableMap<?, ?>) {
                if (m instanceof XNavigableMap.XNavigableMapView<?, ?>) {
                    return new LockingXNavigableMapXNavigableMapView<K, V>(
                        (XNavigableMap.XNavigableMapView<K, V>)m, lockingManager);
                }
                return new LockingXNavigableMap<K, V>(
                    (XNavigableMap<K, V>)m, lockingManager);
            }
            if (m instanceof XSortedMap.XSortedMapView<?, ?>) {
                return new LockingXSortedMapXSortedMapView<K, V>(
                    (XSortedMap.XSortedMapView<K, V>)m, lockingManager);
            }
            return new LockingXSortedMap<K, V>(
                (XSortedMap<K, V>)m, lockingManager);
        }
        if (m instanceof StandardSortedMap<?, ?>) {
            if (m instanceof StandardNavigableMap<?, ?>) {
                return new LockingStandardNavigableMap<K, V>(
                    (StandardNavigableMap<K, V>)m, lockingManager);
            }
            return new LockingStandardSortedMap<K, V>(
                (StandardSortedMap<K, V>)m, lockingManager);
        }
        if (m instanceof NavigableMap<?, ?>) {
            return locking(standard((NavigableMap<K, V>)m), lockingManager);
        }
        return locking(standard(standard(m)), lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(NavigableMap<K, V> lockedMap, LockMode lockMode, Function<NavigableMap<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            return lockingFunction.apply(lockedMap);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (NavigableMap<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (NavigableMap<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        return toppestProxy.locking(lockedMap, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(NavigableMap<K, V> lockedMap, LockMode lockMode, Consumer<NavigableMap<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            lockingConsumer.accept(lockedMap);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (NavigableMap<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (NavigableMap<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        toppestProxy.locking(lockedMap, lockingManager.state, lockingConsumer);
    }

    private static <K, V> NavigableMap<K, V> locking(NavigableMap<K, V> m, LockingManager lockingManager) {
        if (m instanceof Serializable) {
            if (m instanceof MANavigableMap<?, ?>) {
                return new LockingMANavigableMapWithSerializable<K, V>(
                    (MANavigableMap<K, V>)m, lockingManager);
            }
            if (m instanceof XNavigableMap<?, ?>) {
                return new LockingXNavigableMapWithSerializable<K, V>(
                    (XNavigableMap<K, V>)m, lockingManager);
            }
            if (m instanceof StandardNavigableMap<?, ?>) {
                return new LockingStandardNavigableMapWithSerializable<K, V>(
                    (StandardNavigableMap<K, V>)m, lockingManager);
            }
            return locking(standard(standard(m)), lockingManager);
        }
        if (m instanceof MANavigableMap<?, ?>) {
            if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
                return new LockingMANavigableMapMANavigableMapView<K, V>(
                    (MANavigableMap.MANavigableMapView<K, V>)m, lockingManager);
            }
            return new LockingMANavigableMap<K, V>(
                (MANavigableMap<K, V>)m, lockingManager);
        }
        if (m instanceof XNavigableMap<?, ?>) {
            if (m instanceof XNavigableMap.XNavigableMapView<?, ?>) {
                return new LockingXNavigableMapXNavigableMapView<K, V>(
                    (XNavigableMap.XNavigableMapView<K, V>)m, lockingManager);
            }
            return new LockingXNavigableMap<K, V>(
                (XNavigableMap<K, V>)m, lockingManager);
        }
        if (m instanceof StandardNavigableMap<?, ?>) {
            return new LockingStandardNavigableMap<K, V>(
                (StandardNavigableMap<K, V>)m, lockingManager);
        }
        return locking(standard(standard(m)), lockingManager);
    }

    private static <K, V> StandardSortedMap<K, V> locking(StandardSortedMap<K, V> m, LockingManager lockingManager) {
        if (m instanceof Serializable) {
            if (m instanceof StandardNavigableMap<?, ?>) {
                return new LockingStandardNavigableMapWithSerializable<K, V>(
                    (StandardNavigableMap<K, V>)m, lockingManager);
            }
            return new LockingStandardSortedMapWithSerializable<K, V>(m, lockingManager);
        }
        if (m instanceof StandardNavigableMap<?, ?>) {
            return new LockingStandardNavigableMap<K, V>(
                (StandardNavigableMap<K, V>)m, lockingManager);
        }
        return new LockingStandardSortedMap<K, V>(m, lockingManager);
    }

    private static <K, V> StandardNavigableMap<K, V> locking(StandardNavigableMap<K, V> m, LockingManager lockingManager) {
        if (m instanceof Serializable) {
            return new LockingStandardNavigableMapWithSerializable<K, V>(m, lockingManager);
        }
        return new LockingStandardNavigableMap<K, V>(m, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(XMap<K, V> lockedMap, LockMode lockMode, Function<XMap<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            return lockingFunction.apply(lockedMap);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (XMap<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (XMap<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        return toppestProxy.locking(lockedMap, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(XMap<K, V> lockedMap, LockMode lockMode, Consumer<XMap<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            lockingConsumer.accept(lockedMap);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (XMap<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (XMap<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        toppestProxy.locking(lockedMap, lockingManager.state, lockingConsumer);
    }

    private static <K, V> XMap<K, V> locking(XMap<K, V> m, LockingManager lockingManager) {
        if (m instanceof Serializable) {
            if (m instanceof MAMap<?, ?>) {
                if (m instanceof MAOrderedMap<?, ?>) {
                    return new LockingMAOrderedMapWithSerializable<K, V>(
                        (MAOrderedMap<K, V>)m, lockingManager);
                }
                if (m instanceof MASortedMap<?, ?>) {
                    if (m instanceof MANavigableMap<?, ?>) {
                        return new LockingMANavigableMapWithSerializable<K, V>(
                            (MANavigableMap<K, V>)m, lockingManager);
                    }
                    return new LockingMASortedMapWithSerializable<K, V>(
                        (MASortedMap<K, V>)m, lockingManager);
                }
                return new LockingMAMapWithSerializable<K, V>(
                    (MAMap<K, V>)m, lockingManager);
            }
            if (m instanceof XOrderedMap<?, ?>) {
                return new LockingXOrderedMapWithSerializable<K, V>(
                    (XOrderedMap<K, V>)m, lockingManager);
            }
            if (m instanceof XSortedMap<?, ?>) {
                if (m instanceof XNavigableMap<?, ?>) {
                    return new LockingXNavigableMapWithSerializable<K, V>(
                        (XNavigableMap<K, V>)m, lockingManager);
                }
                return new LockingXSortedMapWithSerializable<K, V>(
                    (XSortedMap<K, V>)m, lockingManager);
            }
            return new LockingXMapWithSerializable<K, V>(m, lockingManager);
        }
        if (m instanceof MAMap<?, ?>) {
            if (m instanceof MAOrderedMap<?, ?>) {
                if (m instanceof MAOrderedMap.MAOrderedMapView<?, ?>) {
                    return new LockingMAOrderedMapMAOrderedMapView<K, V>(
                        (MAOrderedMap.MAOrderedMapView<K, V>)m, lockingManager);
                }
                return new LockingMAOrderedMap<K, V>(
                    (MAOrderedMap<K, V>)m, lockingManager);
            }
            if (m instanceof MASortedMap<?, ?>) {
                if (m instanceof MANavigableMap<?, ?>) {
                    if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
                        return new LockingMANavigableMapMANavigableMapView<K, V>(
                            (MANavigableMap.MANavigableMapView<K, V>)m, lockingManager);
                    }
                    return new LockingMANavigableMap<K, V>(
                        (MANavigableMap<K, V>)m, lockingManager);
                }
                if (m instanceof MASortedMap.MASortedMapView<?, ?>) {
                    return new LockingMASortedMapMASortedMapView<K, V>(
                        (MASortedMap.MASortedMapView<K, V>)m, lockingManager);
                }
                return new LockingMASortedMap<K, V>(
                    (MASortedMap<K, V>)m, lockingManager);
            }
            return new LockingMAMap<K, V>(
                (MAMap<K, V>)m, lockingManager);
        }
        if (m instanceof XOrderedMap<?, ?>) {
            if (m instanceof XOrderedMap.XOrderedMapView<?, ?>) {
                return new LockingXOrderedMapXOrderedMapView<K, V>(
                    (XOrderedMap.XOrderedMapView<K, V>)m, lockingManager);
            }
            return new LockingXOrderedMap<K, V>(
                (XOrderedMap<K, V>)m, lockingManager);
        }
        if (m instanceof XSortedMap<?, ?>) {
            if (m instanceof XNavigableMap<?, ?>) {
                if (m instanceof XNavigableMap.XNavigableMapView<?, ?>) {
                    return new LockingXNavigableMapXNavigableMapView<K, V>(
                        (XNavigableMap.XNavigableMapView<K, V>)m, lockingManager);
                }
                return new LockingXNavigableMap<K, V>(
                    (XNavigableMap<K, V>)m, lockingManager);
            }
            if (m instanceof XSortedMap.XSortedMapView<?, ?>) {
                return new LockingXSortedMapXSortedMapView<K, V>(
                    (XSortedMap.XSortedMapView<K, V>)m, lockingManager);
            }
            return new LockingXSortedMap<K, V>(
                (XSortedMap<K, V>)m, lockingManager);
        }
        return new LockingXMap<K, V>(m, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(XSortedMap<K, V> lockedMap, LockMode lockMode, Function<XSortedMap<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            return lockingFunction.apply(lockedMap);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (XSortedMap<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (XSortedMap<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        return toppestProxy.locking(lockedMap, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(XSortedMap<K, V> lockedMap, LockMode lockMode, Consumer<XSortedMap<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            lockingConsumer.accept(lockedMap);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (XSortedMap<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (XSortedMap<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        toppestProxy.locking(lockedMap, lockingManager.state, lockingConsumer);
    }

    private static <K, V> XSortedMap<K, V> locking(XSortedMap<K, V> m, LockingManager lockingManager) {
        if (m instanceof Serializable) {
            if (m instanceof MASortedMap<?, ?>) {
                if (m instanceof MANavigableMap<?, ?>) {
                    return new LockingMANavigableMapWithSerializable<K, V>(
                        (MANavigableMap<K, V>)m, lockingManager);
                }
                return new LockingMASortedMapWithSerializable<K, V>(
                    (MASortedMap<K, V>)m, lockingManager);
            }
            if (m instanceof XNavigableMap<?, ?>) {
                return new LockingXNavigableMapWithSerializable<K, V>(
                    (XNavigableMap<K, V>)m, lockingManager);
            }
            return new LockingXSortedMapWithSerializable<K, V>(m, lockingManager);
        }
        if (m instanceof MASortedMap<?, ?>) {
            if (m instanceof MANavigableMap<?, ?>) {
                if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
                    return new LockingMANavigableMapMANavigableMapView<K, V>(
                        (MANavigableMap.MANavigableMapView<K, V>)m, lockingManager);
                }
                return new LockingMANavigableMap<K, V>(
                    (MANavigableMap<K, V>)m, lockingManager);
            }
            if (m instanceof MASortedMap.MASortedMapView<?, ?>) {
                return new LockingMASortedMapMASortedMapView<K, V>(
                    (MASortedMap.MASortedMapView<K, V>)m, lockingManager);
            }
            return new LockingMASortedMap<K, V>(
                (MASortedMap<K, V>)m, lockingManager);
        }
        if (m instanceof XNavigableMap<?, ?>) {
            if (m instanceof XNavigableMap.XNavigableMapView<?, ?>) {
                return new LockingXNavigableMapXNavigableMapView<K, V>(
                    (XNavigableMap.XNavigableMapView<K, V>)m, lockingManager);
            }
            return new LockingXNavigableMap<K, V>(
                (XNavigableMap<K, V>)m, lockingManager);
        }
        if (m instanceof XSortedMap.XSortedMapView<?, ?>) {
            return new LockingXSortedMapXSortedMapView<K, V>(
                (XSortedMap.XSortedMapView<K, V>)m, lockingManager);
        }
        return new LockingXSortedMap<K, V>(m, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(XSortedMap.XSortedMapView<K, V> lockedMap, LockMode lockMode, Function<XSortedMap.XSortedMapView<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            return lockingFunction.apply(lockedMap);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (XSortedMap.XSortedMapView<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (XSortedMap.XSortedMapView<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        return toppestProxy.locking(lockedMap, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(XSortedMap.XSortedMapView<K, V> lockedMap, LockMode lockMode, Consumer<XSortedMap.XSortedMapView<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            lockingConsumer.accept(lockedMap);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (XSortedMap.XSortedMapView<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (XSortedMap.XSortedMapView<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        toppestProxy.locking(lockedMap, lockingManager.state, lockingConsumer);
    }

    private static <K, V> XSortedMap.XSortedMapView<K, V> locking(XSortedMap.XSortedMapView<K, V> m, LockingManager lockingManager) {
        if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
            return new LockingMANavigableMapMANavigableMapView<K, V>(
                (MANavigableMap.MANavigableMapView<K, V>)m, lockingManager);
        }
        if (m instanceof MASortedMap.MASortedMapView<?, ?>) {
            return new LockingMASortedMapMASortedMapView<K, V>(
                (MASortedMap.MASortedMapView<K, V>)m, lockingManager);
        }
        if (m instanceof XNavigableMap.XNavigableMapView<?, ?>) {
            return new LockingXNavigableMapXNavigableMapView<K, V>(
                (XNavigableMap.XNavigableMapView<K, V>)m, lockingManager);
        }
        return new LockingXSortedMapXSortedMapView<K, V>(m, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(XNavigableMap<K, V> lockedMap, LockMode lockMode, Function<XNavigableMap<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            return lockingFunction.apply(lockedMap);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (XNavigableMap<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (XNavigableMap<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        return toppestProxy.locking(lockedMap, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(XNavigableMap<K, V> lockedMap, LockMode lockMode, Consumer<XNavigableMap<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            lockingConsumer.accept(lockedMap);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (XNavigableMap<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (XNavigableMap<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        toppestProxy.locking(lockedMap, lockingManager.state, lockingConsumer);
    }

    private static <K, V> XNavigableMap<K, V> locking(XNavigableMap<K, V> m, LockingManager lockingManager) {
        if (m instanceof Serializable) {
            if (m instanceof MANavigableMap<?, ?>) {
                return new LockingMANavigableMapWithSerializable<K, V>(
                    (MANavigableMap<K, V>)m, lockingManager);
            }
            return new LockingXNavigableMapWithSerializable<K, V>(m, lockingManager);
        }
        if (m instanceof MANavigableMap<?, ?>) {
            if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
                return new LockingMANavigableMapMANavigableMapView<K, V>(
                    (MANavigableMap.MANavigableMapView<K, V>)m, lockingManager);
            }
            return new LockingMANavigableMap<K, V>(
                (MANavigableMap<K, V>)m, lockingManager);
        }
        if (m instanceof XNavigableMap.XNavigableMapView<?, ?>) {
            return new LockingXNavigableMapXNavigableMapView<K, V>(
                (XNavigableMap.XNavigableMapView<K, V>)m, lockingManager);
        }
        return new LockingXNavigableMap<K, V>(m, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(XNavigableMap.XNavigableMapView<K, V> lockedMap, LockMode lockMode, Function<XNavigableMap.XNavigableMapView<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            return lockingFunction.apply(lockedMap);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (XNavigableMap.XNavigableMapView<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (XNavigableMap.XNavigableMapView<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        return toppestProxy.locking(lockedMap, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(XNavigableMap.XNavigableMapView<K, V> lockedMap, LockMode lockMode, Consumer<XNavigableMap.XNavigableMapView<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            lockingConsumer.accept(lockedMap);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (XNavigableMap.XNavigableMapView<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (XNavigableMap.XNavigableMapView<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        toppestProxy.locking(lockedMap, lockingManager.state, lockingConsumer);
    }

    private static <K, V> XNavigableMap.XNavigableMapView<K, V> locking(XNavigableMap.XNavigableMapView<K, V> m, LockingManager lockingManager) {
        if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
            return new LockingMANavigableMapMANavigableMapView<K, V>(
                (MANavigableMap.MANavigableMapView<K, V>)m, lockingManager);
        }
        return new LockingXNavigableMapXNavigableMapView<K, V>(m, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(XOrderedMap<K, V> lockedMap, LockMode lockMode, Function<XOrderedMap<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            return lockingFunction.apply(lockedMap);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (XOrderedMap<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (XOrderedMap<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        return toppestProxy.locking(lockedMap, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(XOrderedMap<K, V> lockedMap, LockMode lockMode, Consumer<XOrderedMap<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            lockingConsumer.accept(lockedMap);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (XOrderedMap<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (XOrderedMap<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        toppestProxy.locking(lockedMap, lockingManager.state, lockingConsumer);
    }

    private static <K, V> XOrderedMap<K, V> locking(XOrderedMap<K, V> m, LockingManager lockingManager) {
        if (m instanceof Serializable) {
            if (m instanceof MAOrderedMap<?, ?>) {
                return new LockingMAOrderedMapWithSerializable<K, V>(
                    (MAOrderedMap<K, V>)m, lockingManager);
            }
            return new LockingXOrderedMapWithSerializable<K, V>(m, lockingManager);
        }
        if (m instanceof MAOrderedMap<?, ?>) {
            if (m instanceof MAOrderedMap.MAOrderedMapView<?, ?>) {
                return new LockingMAOrderedMapMAOrderedMapView<K, V>(
                    (MAOrderedMap.MAOrderedMapView<K, V>)m, lockingManager);
            }
            return new LockingMAOrderedMap<K, V>(
                (MAOrderedMap<K, V>)m, lockingManager);
        }
        if (m instanceof XOrderedMap.XOrderedMapView<?, ?>) {
            return new LockingXOrderedMapXOrderedMapView<K, V>(
                (XOrderedMap.XOrderedMapView<K, V>)m, lockingManager);
        }
        return new LockingXOrderedMap<K, V>(m, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(XOrderedMap.XOrderedMapView<K, V> lockedMap, LockMode lockMode, Function<XOrderedMap.XOrderedMapView<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            return lockingFunction.apply(lockedMap);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (XOrderedMap.XOrderedMapView<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (XOrderedMap.XOrderedMapView<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        return toppestProxy.locking(lockedMap, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(XOrderedMap.XOrderedMapView<K, V> lockedMap, LockMode lockMode, Consumer<XOrderedMap.XOrderedMapView<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            lockingConsumer.accept(lockedMap);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (XOrderedMap.XOrderedMapView<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (XOrderedMap.XOrderedMapView<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        toppestProxy.locking(lockedMap, lockingManager.state, lockingConsumer);
    }

    private static <K, V> XOrderedMap.XOrderedMapView<K, V> locking(XOrderedMap.XOrderedMapView<K, V> m, LockingManager lockingManager) {
        if (m instanceof MAOrderedMap.MAOrderedMapView<?, ?>) {
            return new LockingMAOrderedMapMAOrderedMapView<K, V>(
                (MAOrderedMap.MAOrderedMapView<K, V>)m, lockingManager);
        }
        return new LockingXOrderedMapXOrderedMapView<K, V>(m, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(MAMap<K, V> lockedMap, LockMode lockMode, Function<MAMap<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            return lockingFunction.apply(lockedMap);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (MAMap<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (MAMap<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        return toppestProxy.locking(lockedMap, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(MAMap<K, V> lockedMap, LockMode lockMode, Consumer<MAMap<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            lockingConsumer.accept(lockedMap);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (MAMap<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (MAMap<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        toppestProxy.locking(lockedMap, lockingManager.state, lockingConsumer);
    }

    private static <K, V> MAMap<K, V> locking(MAMap<K, V> m, LockingManager lockingManager) {
        if (m instanceof Serializable) {
            if (m instanceof MAOrderedMap<?, ?>) {
                return new LockingMAOrderedMapWithSerializable<K, V>(
                    (MAOrderedMap<K, V>)m, lockingManager);
            }
            if (m instanceof MASortedMap<?, ?>) {
                if (m instanceof MANavigableMap<?, ?>) {
                    return new LockingMANavigableMapWithSerializable<K, V>(
                        (MANavigableMap<K, V>)m, lockingManager);
                }
                return new LockingMASortedMapWithSerializable<K, V>(
                    (MASortedMap<K, V>)m, lockingManager);
            }
            return new LockingMAMapWithSerializable<K, V>(m, lockingManager);
        }
        if (m instanceof MAOrderedMap<?, ?>) {
            if (m instanceof MAOrderedMap.MAOrderedMapView<?, ?>) {
                return new LockingMAOrderedMapMAOrderedMapView<K, V>(
                    (MAOrderedMap.MAOrderedMapView<K, V>)m, lockingManager);
            }
            return new LockingMAOrderedMap<K, V>(
                (MAOrderedMap<K, V>)m, lockingManager);
        }
        if (m instanceof MASortedMap<?, ?>) {
            if (m instanceof MANavigableMap<?, ?>) {
                if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
                    return new LockingMANavigableMapMANavigableMapView<K, V>(
                        (MANavigableMap.MANavigableMapView<K, V>)m, lockingManager);
                }
                return new LockingMANavigableMap<K, V>(
                    (MANavigableMap<K, V>)m, lockingManager);
            }
            if (m instanceof MASortedMap.MASortedMapView<?, ?>) {
                return new LockingMASortedMapMASortedMapView<K, V>(
                    (MASortedMap.MASortedMapView<K, V>)m, lockingManager);
            }
            return new LockingMASortedMap<K, V>(
                (MASortedMap<K, V>)m, lockingManager);
        }
        return new LockingMAMap<K, V>(m, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(MASortedMap<K, V> lockedMap, LockMode lockMode, Function<MASortedMap<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            return lockingFunction.apply(lockedMap);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (MASortedMap<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (MASortedMap<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        return toppestProxy.locking(lockedMap, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(MASortedMap<K, V> lockedMap, LockMode lockMode, Consumer<MASortedMap<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            lockingConsumer.accept(lockedMap);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (MASortedMap<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (MASortedMap<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        toppestProxy.locking(lockedMap, lockingManager.state, lockingConsumer);
    }

    private static <K, V> MASortedMap<K, V> locking(MASortedMap<K, V> m, LockingManager lockingManager) {
        if (m instanceof Serializable) {
            if (m instanceof MANavigableMap<?, ?>) {
                return new LockingMANavigableMapWithSerializable<K, V>(
                    (MANavigableMap<K, V>)m, lockingManager);
            }
            return new LockingMASortedMapWithSerializable<K, V>(m, lockingManager);
        }
        if (m instanceof MANavigableMap<?, ?>) {
            if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
                return new LockingMANavigableMapMANavigableMapView<K, V>(
                    (MANavigableMap.MANavigableMapView<K, V>)m, lockingManager);
            }
            return new LockingMANavigableMap<K, V>(
                (MANavigableMap<K, V>)m, lockingManager);
        }
        if (m instanceof MASortedMap.MASortedMapView<?, ?>) {
            return new LockingMASortedMapMASortedMapView<K, V>(
                (MASortedMap.MASortedMapView<K, V>)m, lockingManager);
        }
        return new LockingMASortedMap<K, V>(m, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(MASortedMap.MASortedMapView<K, V> lockedMap, LockMode lockMode, Function<MASortedMap.MASortedMapView<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            return lockingFunction.apply(lockedMap);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (MASortedMap.MASortedMapView<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (MASortedMap.MASortedMapView<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        return toppestProxy.locking(lockedMap, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(MASortedMap.MASortedMapView<K, V> lockedMap, LockMode lockMode, Consumer<MASortedMap.MASortedMapView<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            lockingConsumer.accept(lockedMap);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (MASortedMap.MASortedMapView<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (MASortedMap.MASortedMapView<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        toppestProxy.locking(lockedMap, lockingManager.state, lockingConsumer);
    }

    private static <K, V> MASortedMap.MASortedMapView<K, V> locking(MASortedMap.MASortedMapView<K, V> m, LockingManager lockingManager) {
        if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
            return new LockingMANavigableMapMANavigableMapView<K, V>(
                (MANavigableMap.MANavigableMapView<K, V>)m, lockingManager);
        }
        return new LockingMASortedMapMASortedMapView<K, V>(m, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(MANavigableMap<K, V> lockedMap, LockMode lockMode, Function<MANavigableMap<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            return lockingFunction.apply(lockedMap);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (MANavigableMap<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (MANavigableMap<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        return toppestProxy.locking(lockedMap, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(MANavigableMap<K, V> lockedMap, LockMode lockMode, Consumer<MANavigableMap<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            lockingConsumer.accept(lockedMap);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (MANavigableMap<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (MANavigableMap<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        toppestProxy.locking(lockedMap, lockingManager.state, lockingConsumer);
    }

    private static <K, V> MANavigableMap<K, V> locking(MANavigableMap<K, V> m, LockingManager lockingManager) {
        if (m instanceof Serializable) {
            return new LockingMANavigableMapWithSerializable<K, V>(m, lockingManager);
        }
        if (m instanceof MANavigableMap.MANavigableMapView<?, ?>) {
            return new LockingMANavigableMapMANavigableMapView<K, V>(
                (MANavigableMap.MANavigableMapView<K, V>)m, lockingManager);
        }
        return new LockingMANavigableMap<K, V>(m, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(MANavigableMap.MANavigableMapView<K, V> lockedMap, LockMode lockMode, Function<MANavigableMap.MANavigableMapView<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            return lockingFunction.apply(lockedMap);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (MANavigableMap.MANavigableMapView<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (MANavigableMap.MANavigableMapView<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        return toppestProxy.locking(lockedMap, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(MANavigableMap.MANavigableMapView<K, V> lockedMap, LockMode lockMode, Consumer<MANavigableMap.MANavigableMapView<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            lockingConsumer.accept(lockedMap);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (MANavigableMap.MANavigableMapView<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (MANavigableMap.MANavigableMapView<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        toppestProxy.locking(lockedMap, lockingManager.state, lockingConsumer);
    }

    private static <K, V> MANavigableMap.MANavigableMapView<K, V> locking(MANavigableMap.MANavigableMapView<K, V> m, LockingManager lockingManager) {
        return new LockingMANavigableMapMANavigableMapView<K, V>(m, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(MAOrderedMap<K, V> lockedMap, LockMode lockMode, Function<MAOrderedMap<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            return lockingFunction.apply(lockedMap);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (MAOrderedMap<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (MAOrderedMap<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        return toppestProxy.locking(lockedMap, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(MAOrderedMap<K, V> lockedMap, LockMode lockMode, Consumer<MAOrderedMap<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            lockingConsumer.accept(lockedMap);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (MAOrderedMap<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (MAOrderedMap<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        toppestProxy.locking(lockedMap, lockingManager.state, lockingConsumer);
    }

    private static <K, V> MAOrderedMap<K, V> locking(MAOrderedMap<K, V> m, LockingManager lockingManager) {
        if (m instanceof Serializable) {
            return new LockingMAOrderedMapWithSerializable<K, V>(m, lockingManager);
        }
        if (m instanceof MAOrderedMap.MAOrderedMapView<?, ?>) {
            return new LockingMAOrderedMapMAOrderedMapView<K, V>(
                (MAOrderedMap.MAOrderedMapView<K, V>)m, lockingManager);
        }
        return new LockingMAOrderedMap<K, V>(m, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(MAOrderedMap.MAOrderedMapView<K, V> lockedMap, LockMode lockMode, Function<MAOrderedMap.MAOrderedMapView<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            return lockingFunction.apply(lockedMap);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (MAOrderedMap.MAOrderedMapView<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (MAOrderedMap.MAOrderedMapView<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        return toppestProxy.locking(lockedMap, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(MAOrderedMap.MAOrderedMapView<K, V> lockedMap, LockMode lockMode, Consumer<MAOrderedMap.MAOrderedMapView<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedMap", lockedMap);
        if (!(lockedMap instanceof Proxy)) {
            lockingConsumer.accept(lockedMap);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedMap;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedMap = (MAOrderedMap.MAOrderedMapView<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedMap = (MAOrderedMap.MAOrderedMapView<K, V>)proxy.recreate(lockedMap);
            }
        }
        lockedMap = locking(lockedMap, lockingManager);
        toppestProxy.locking(lockedMap, lockingManager.state, lockingConsumer);
    }

    private static <K, V> MAOrderedMap.MAOrderedMapView<K, V> locking(MAOrderedMap.MAOrderedMapView<K, V> m, LockingManager lockingManager) {
        return new LockingMAOrderedMapMAOrderedMapView<K, V>(m, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(Collection<E> lockedCollection, LockMode lockMode, Function<Collection<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (Collection<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (Collection<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(Collection<E> lockedCollection, LockMode lockMode, Consumer<Collection<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (Collection<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (Collection<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    private static <E> Collection<E> locking(Collection<E> c, LockingManager lockingManager) {
        if (c instanceof Serializable) {
            if (c instanceof RandomAccess) {
                if (c instanceof MAList<?>) {
                    return new LockingMAListWithSerializableRandomAccess<E>(
                        (MAList<E>)c, lockingManager);
                }
                if (c instanceof XList<?>) {
                    return new LockingXListWithSerializableRandomAccess<E>(
                        (XList<E>)c, lockingManager);
                }
                if (c instanceof List<?>) {
                    return new LockingListWithSerializableRandomAccess<E>(
                        (List<E>)c, lockingManager);
                }
            }
            if (c instanceof XCollection<?>) {
                if (c instanceof MACollection<?>) {
                    if (c instanceof MAList<?>) {
                        return new LockingMAListWithSerializable<E>(
                            (MAList<E>)c, lockingManager);
                    }
                    if (c instanceof MASet<?>) {
                        if (c instanceof MAOrderedSet<?>) {
                            return new LockingMAOrderedSetWithSerializable<E>(
                                (MAOrderedSet<E>)c, lockingManager);
                        }
                        if (c instanceof MASortedSet<?>) {
                            if (c instanceof MANavigableSet<?>) {
                                return new LockingMANavigableSetWithSerializable<E>(
                                    (MANavigableSet<E>)c, lockingManager);
                            }
                            return new LockingMASortedSetWithSerializable<E>(
                                (MASortedSet<E>)c, lockingManager);
                        }
                        return new LockingMASetWithSerializable<E>(
                            (MASet<E>)c, lockingManager);
                    }
                    return new LockingMACollectionWithSerializable<E>(
                        (MACollection<E>)c, lockingManager);
                }
                if (c instanceof XList<?>) {
                    return new LockingXListWithSerializable<E>(
                        (XList<E>)c, lockingManager);
                }
                if (c instanceof XSet<?>) {
                    if (c instanceof XOrderedSet<?>) {
                        return new LockingXOrderedSetWithSerializable<E>(
                            (XOrderedSet<E>)c, lockingManager);
                    }
                    if (c instanceof XSortedSet<?>) {
                        if (c instanceof XNavigableSet<?>) {
                            return new LockingXNavigableSetWithSerializable<E>(
                                (XNavigableSet<E>)c, lockingManager);
                        }
                        return new LockingXSortedSetWithSerializable<E>(
                            (XSortedSet<E>)c, lockingManager);
                    }
                    return new LockingXSetWithSerializable<E>(
                        (XSet<E>)c, lockingManager);
                }
                return new LockingXCollectionWithSerializable<E>(
                    (XCollection<E>)c, lockingManager);
            }
            if (c instanceof Set<?>) {
                if (c instanceof StandardMap.EntrySet<?, ?>) {
                    return new LockingStandardMapEntrySetWithSerializable(
                        (StandardMap.EntrySet)c, lockingManager);
                }
                if (c instanceof SortedSet<?>) {
                    if (c instanceof NavigableSet<?>) {
                        return new LockingNavigableSetWithSerializable<E>(
                            (NavigableSet<E>)c, lockingManager);
                    }
                    return new LockingSortedSetWithSerializable<E>(
                        (SortedSet<E>)c, lockingManager);
                }
                return new LockingSetWithSerializable<E>(
                    (Set<E>)c, lockingManager);
            }
            if (c instanceof List<?>) {
                return new LockingListWithSerializable<E>(
                    (List<E>)c, lockingManager);
            }
            return new LockingCollectionWithSerializable<E>(c, lockingManager);
        }
        if (c instanceof RandomAccess) {
            if (c instanceof MAList<?>) {
                if (c instanceof MAList.MAListView<?>) {
                    return new LockingMAListMAListViewWithRandomAccess<E>(
                        (MAList.MAListView<E>)c, lockingManager);
                }
                return new LockingMAListWithRandomAccess<E>(
                    (MAList<E>)c, lockingManager);
            }
            if (c instanceof XList<?>) {
                if (c instanceof XList.XListView<?>) {
                    return new LockingXListXListViewWithRandomAccess<E>(
                        (XList.XListView<E>)c, lockingManager);
                }
                return new LockingXListWithRandomAccess<E>(
                    (XList<E>)c, lockingManager);
            }
            if (c instanceof List<?>) {
                return new LockingListWithRandomAccess<E>(
                    (List<E>)c, lockingManager);
            }
        }
        if (c instanceof XCollection<?>) {
            if (c instanceof MACollection<?>) {
                if (c instanceof MAList<?>) {
                    if (c instanceof MAList.MAListView<?>) {
                        return new LockingMAListMAListView<E>(
                            (MAList.MAListView<E>)c, lockingManager);
                    }
                    return new LockingMAList<E>(
                        (MAList<E>)c, lockingManager);
                }
                if (c instanceof MASet<?>) {
                    if (c instanceof MAOrderedSet<?>) {
                        if (c instanceof MAOrderedSet.MAOrderedSetView<?>) {
                            if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
                                return new LockingMAOrderedMapMAOrderedKeySetView<E, Object>(
                                    (MAOrderedMap.MAOrderedKeySetView<E, Object>)c, lockingManager);
                            }
                            return new LockingMAOrderedSetMAOrderedSetView<E>(
                                (MAOrderedSet.MAOrderedSetView<E>)c, lockingManager);
                        }
                        return new LockingMAOrderedSet<E>(
                            (MAOrderedSet<E>)c, lockingManager);
                    }
                    if (c instanceof MASortedSet<?>) {
                        if (c instanceof MANavigableSet<?>) {
                            if (c instanceof MANavigableSet.MANavigableSetView<?>) {
                                if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                                    return new LockingMANavigableMapMANavigableKeySetView<E, Object>(
                                        (MANavigableMap.MANavigableKeySetView<E, Object>)c, lockingManager);
                                }
                                return new LockingMANavigableSetMANavigableSetView<E>(
                                    (MANavigableSet.MANavigableSetView<E>)c, lockingManager);
                            }
                            return new LockingMANavigableSet<E>(
                                (MANavigableSet<E>)c, lockingManager);
                        }
                        if (c instanceof MASortedSet.MASortedSetView<?>) {
                            if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
                                return new LockingMASortedMapMASortedKeySetView<E, Object>(
                                    (MASortedMap.MASortedKeySetView<E, Object>)c, lockingManager);
                            }
                            return new LockingMASortedSetMASortedSetView<E>(
                                (MASortedSet.MASortedSetView<E>)c, lockingManager);
                        }
                        return new LockingMASortedSet<E>(
                            (MASortedSet<E>)c, lockingManager);
                    }
                    if (c instanceof MAMap.MAEntrySetView<?, ?>) {
                        return new LockingMAMapMAEntrySetView(
                            (MAMap.MAEntrySetView)c, lockingManager);
                    }
                    if (c instanceof MAMap.MAKeySetView<?, ?>) {
                        return new LockingMAMapMAKeySetView<E, Object>(
                            (MAMap.MAKeySetView<E, Object>)c, lockingManager);
                    }
                    return new LockingMASet<E>(
                        (MASet<E>)c, lockingManager);
                }
                if (c instanceof MAMap.MAValuesView<?, ?>) {
                    return new LockingMAMapMAValuesView<Object, E>(
                        (MAMap.MAValuesView<Object, E>)c, lockingManager);
                }
                return new LockingMACollection<E>(
                    (MACollection<E>)c, lockingManager);
            }
            if (c instanceof XList<?>) {
                if (c instanceof XList.XListView<?>) {
                    return new LockingXListXListView<E>(
                        (XList.XListView<E>)c, lockingManager);
                }
                return new LockingXList<E>(
                    (XList<E>)c, lockingManager);
            }
            if (c instanceof XSet<?>) {
                if (c instanceof XOrderedSet<?>) {
                    if (c instanceof XOrderedSet.XOrderedSetView<?>) {
                        if (c instanceof XOrderedMap.XOrderedKeySetView<?>) {
                            return new LockingXOrderedMapXOrderedKeySetView<E>(
                                (XOrderedMap.XOrderedKeySetView<E>)c, lockingManager);
                        }
                        return new LockingXOrderedSetXOrderedSetView<E>(
                            (XOrderedSet.XOrderedSetView<E>)c, lockingManager);
                    }
                    return new LockingXOrderedSet<E>(
                        (XOrderedSet<E>)c, lockingManager);
                }
                if (c instanceof XSortedSet<?>) {
                    if (c instanceof XNavigableSet<?>) {
                        if (c instanceof XNavigableSet.XNavigableSetView<?>) {
                            if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
                                return new LockingXNavigableMapXNavigableKeySetView<E>(
                                    (XNavigableMap.XNavigableKeySetView<E>)c, lockingManager);
                            }
                            return new LockingXNavigableSetXNavigableSetView<E>(
                                (XNavigableSet.XNavigableSetView<E>)c, lockingManager);
                        }
                        return new LockingXNavigableSet<E>(
                            (XNavigableSet<E>)c, lockingManager);
                    }
                    if (c instanceof XSortedSet.XSortedSetView<?>) {
                        if (c instanceof XSortedMap.XSortedKeySetView<?>) {
                            return new LockingXSortedMapXSortedKeySetView<E>(
                                (XSortedMap.XSortedKeySetView<E>)c, lockingManager);
                        }
                        return new LockingXSortedSetXSortedSetView<E>(
                            (XSortedSet.XSortedSetView<E>)c, lockingManager);
                    }
                    return new LockingXSortedSet<E>(
                        (XSortedSet<E>)c, lockingManager);
                }
                if (c instanceof XMap.XKeySetView<?>) {
                    return new LockingXMapXKeySetView<E>(
                        (XMap.XKeySetView<E>)c, lockingManager);
                }
                if (c instanceof XMap.XEntrySetView<?, ?>) {
                    return new LockingXMapXEntrySetView(
                        (XMap.XEntrySetView)c, lockingManager);
                }
                return new LockingXSet<E>(
                    (XSet<E>)c, lockingManager);
            }
            if (c instanceof XMap.XValuesView<?>) {
                return new LockingXMapXValuesView<E>(
                    (XMap.XValuesView<E>)c, lockingManager);
            }
            return new LockingXCollection<E>(
                (XCollection<E>)c, lockingManager);
        }
        if (c instanceof Set<?>) {
            if (c instanceof StandardMap.EntrySet<?, ?>) {
                return new LockingStandardMapEntrySet(
                    (StandardMap.EntrySet)c, lockingManager);
            }
            if (c instanceof SortedSet<?>) {
                if (c instanceof NavigableSet<?>) {
                    return new LockingNavigableSet<E>(
                        (NavigableSet<E>)c, lockingManager);
                }
                return new LockingSortedSet<E>(
                    (SortedSet<E>)c, lockingManager);
            }
            return new LockingSet<E>(
                (Set<E>)c, lockingManager);
        }
        if (c instanceof List<?>) {
            return new LockingList<E>(
                (List<E>)c, lockingManager);
        }
        return new LockingCollection<E>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(Set<E> lockedCollection, LockMode lockMode, Function<Set<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (Set<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (Set<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(Set<E> lockedCollection, LockMode lockMode, Consumer<Set<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (Set<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (Set<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    private static <E> Set<E> locking(Set<E> c, LockingManager lockingManager) {
        if (c instanceof Serializable) {
            if (c instanceof MAOrderedSet<?>) {
                return new LockingMAOrderedSetWithSerializable<E>(
                    (MAOrderedSet<E>)c, lockingManager);
            }
            if (c instanceof MASortedSet<?>) {
                if (c instanceof MANavigableSet<?>) {
                    return new LockingMANavigableSetWithSerializable<E>(
                        (MANavigableSet<E>)c, lockingManager);
                }
                return new LockingMASortedSetWithSerializable<E>(
                    (MASortedSet<E>)c, lockingManager);
            }
            if (c instanceof MASet<?>) {
                return new LockingMASetWithSerializable<E>(
                    (MASet<E>)c, lockingManager);
            }
            if (c instanceof XSet<?>) {
                if (c instanceof XOrderedSet<?>) {
                    return new LockingXOrderedSetWithSerializable<E>(
                        (XOrderedSet<E>)c, lockingManager);
                }
                if (c instanceof XSortedSet<?>) {
                    if (c instanceof XNavigableSet<?>) {
                        return new LockingXNavigableSetWithSerializable<E>(
                            (XNavigableSet<E>)c, lockingManager);
                    }
                    return new LockingXSortedSetWithSerializable<E>(
                        (XSortedSet<E>)c, lockingManager);
                }
                return new LockingXSetWithSerializable<E>(
                    (XSet<E>)c, lockingManager);
            }
            if (c instanceof StandardMap.EntrySet<?, ?>) {
                return new LockingStandardMapEntrySetWithSerializable(
                    (StandardMap.EntrySet)c, lockingManager);
            }
            if (c instanceof SortedSet<?>) {
                if (c instanceof NavigableSet<?>) {
                    return new LockingNavigableSetWithSerializable<E>(
                        (NavigableSet<E>)c, lockingManager);
                }
                return new LockingSortedSetWithSerializable<E>(
                    (SortedSet<E>)c, lockingManager);
            }
            return new LockingSetWithSerializable<E>(c, lockingManager);
        }
        if (c instanceof MAOrderedSet<?>) {
            if (c instanceof MAOrderedSet.MAOrderedSetView<?>) {
                if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
                    return new LockingMAOrderedMapMAOrderedKeySetView<E, Object>(
                        (MAOrderedMap.MAOrderedKeySetView<E, Object>)c, lockingManager);
                }
                return new LockingMAOrderedSetMAOrderedSetView<E>(
                    (MAOrderedSet.MAOrderedSetView<E>)c, lockingManager);
            }
            return new LockingMAOrderedSet<E>(
                (MAOrderedSet<E>)c, lockingManager);
        }
        if (c instanceof MASortedSet<?>) {
            if (c instanceof MANavigableSet<?>) {
                if (c instanceof MANavigableSet.MANavigableSetView<?>) {
                    if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                        return new LockingMANavigableMapMANavigableKeySetView<E, Object>(
                            (MANavigableMap.MANavigableKeySetView<E, Object>)c, lockingManager);
                    }
                    return new LockingMANavigableSetMANavigableSetView<E>(
                        (MANavigableSet.MANavigableSetView<E>)c, lockingManager);
                }
                return new LockingMANavigableSet<E>(
                    (MANavigableSet<E>)c, lockingManager);
            }
            if (c instanceof MASortedSet.MASortedSetView<?>) {
                if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
                    return new LockingMASortedMapMASortedKeySetView<E, Object>(
                        (MASortedMap.MASortedKeySetView<E, Object>)c, lockingManager);
                }
                return new LockingMASortedSetMASortedSetView<E>(
                    (MASortedSet.MASortedSetView<E>)c, lockingManager);
            }
            return new LockingMASortedSet<E>(
                (MASortedSet<E>)c, lockingManager);
        }
        if (c instanceof MAMap.MAEntrySetView<?, ?>) {
            return new LockingMAMapMAEntrySetView(
                (MAMap.MAEntrySetView)c, lockingManager);
        }
        if (c instanceof MASet<?>) {
            if (c instanceof MAMap.MAKeySetView<?, ?>) {
                return new LockingMAMapMAKeySetView<E, Object>(
                    (MAMap.MAKeySetView<E, Object>)c, lockingManager);
            }
            return new LockingMASet<E>(
                (MASet<E>)c, lockingManager);
        }
        if (c instanceof XSet<?>) {
            if (c instanceof XOrderedSet<?>) {
                if (c instanceof XOrderedSet.XOrderedSetView<?>) {
                    if (c instanceof XOrderedMap.XOrderedKeySetView<?>) {
                        return new LockingXOrderedMapXOrderedKeySetView<E>(
                            (XOrderedMap.XOrderedKeySetView<E>)c, lockingManager);
                    }
                    return new LockingXOrderedSetXOrderedSetView<E>(
                        (XOrderedSet.XOrderedSetView<E>)c, lockingManager);
                }
                return new LockingXOrderedSet<E>(
                    (XOrderedSet<E>)c, lockingManager);
            }
            if (c instanceof XSortedSet<?>) {
                if (c instanceof XNavigableSet<?>) {
                    if (c instanceof XNavigableSet.XNavigableSetView<?>) {
                        if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
                            return new LockingXNavigableMapXNavigableKeySetView<E>(
                                (XNavigableMap.XNavigableKeySetView<E>)c, lockingManager);
                        }
                        return new LockingXNavigableSetXNavigableSetView<E>(
                            (XNavigableSet.XNavigableSetView<E>)c, lockingManager);
                    }
                    return new LockingXNavigableSet<E>(
                        (XNavigableSet<E>)c, lockingManager);
                }
                if (c instanceof XSortedSet.XSortedSetView<?>) {
                    if (c instanceof XSortedMap.XSortedKeySetView<?>) {
                        return new LockingXSortedMapXSortedKeySetView<E>(
                            (XSortedMap.XSortedKeySetView<E>)c, lockingManager);
                    }
                    return new LockingXSortedSetXSortedSetView<E>(
                        (XSortedSet.XSortedSetView<E>)c, lockingManager);
                }
                return new LockingXSortedSet<E>(
                    (XSortedSet<E>)c, lockingManager);
            }
            if (c instanceof XMap.XKeySetView<?>) {
                return new LockingXMapXKeySetView<E>(
                    (XMap.XKeySetView<E>)c, lockingManager);
            }
            if (c instanceof XMap.XEntrySetView<?, ?>) {
                return new LockingXMapXEntrySetView(
                    (XMap.XEntrySetView)c, lockingManager);
            }
            return new LockingXSet<E>(
                (XSet<E>)c, lockingManager);
        }
        if (c instanceof StandardMap.EntrySet<?, ?>) {
            return new LockingStandardMapEntrySet(
                (StandardMap.EntrySet)c, lockingManager);
        }
        if (c instanceof SortedSet<?>) {
            if (c instanceof NavigableSet<?>) {
                return new LockingNavigableSet<E>(
                    (NavigableSet<E>)c, lockingManager);
            }
            return new LockingSortedSet<E>(
                (SortedSet<E>)c, lockingManager);
        }
        return new LockingSet<E>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(SortedSet<E> lockedCollection, LockMode lockMode, Function<SortedSet<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (SortedSet<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (SortedSet<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(SortedSet<E> lockedCollection, LockMode lockMode, Consumer<SortedSet<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (SortedSet<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (SortedSet<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    @SuppressWarnings("unchecked")
    private static <E> SortedSet<E> locking(SortedSet<E> c, LockingManager lockingManager) {
        if (c instanceof Serializable) {
            if (c instanceof MASortedSet<?>) {
                if (c instanceof MANavigableSet<?>) {
                    return new LockingMANavigableSetWithSerializable<E>(
                        (MANavigableSet<E>)c, lockingManager);
                }
                return new LockingMASortedSetWithSerializable<E>(
                    (MASortedSet<E>)c, lockingManager);
            }
            if (c instanceof XSortedSet<?>) {
                if (c instanceof XNavigableSet<?>) {
                    return new LockingXNavigableSetWithSerializable<E>(
                        (XNavigableSet<E>)c, lockingManager);
                }
                return new LockingXSortedSetWithSerializable<E>(
                    (XSortedSet<E>)c, lockingManager);
            }
            if (c instanceof NavigableSet<?>) {
                return new LockingNavigableSetWithSerializable<E>(
                    (NavigableSet<E>)c, lockingManager);
            }
            return new LockingSortedSetWithSerializable<E>(c, lockingManager);
        }
        if (c instanceof MASortedSet<?>) {
            if (c instanceof MANavigableSet<?>) {
                if (c instanceof MANavigableSet.MANavigableSetView<?>) {
                    if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                        return new LockingMANavigableMapMANavigableKeySetView<E, Object>(
                            (MANavigableMap.MANavigableKeySetView<E, Object>)c, lockingManager);
                    }
                    return new LockingMANavigableSetMANavigableSetView<E>(
                        (MANavigableSet.MANavigableSetView<E>)c, lockingManager);
                }
                return new LockingMANavigableSet<E>(
                    (MANavigableSet<E>)c, lockingManager);
            }
            if (c instanceof MASortedSet.MASortedSetView<?>) {
                if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
                    return new LockingMASortedMapMASortedKeySetView<E, Object>(
                        (MASortedMap.MASortedKeySetView<E, Object>)c, lockingManager);
                }
                return new LockingMASortedSetMASortedSetView<E>(
                    (MASortedSet.MASortedSetView<E>)c, lockingManager);
            }
            return new LockingMASortedSet<E>(
                (MASortedSet<E>)c, lockingManager);
        }
        if (c instanceof XSortedSet<?>) {
            if (c instanceof XNavigableSet<?>) {
                if (c instanceof XNavigableSet.XNavigableSetView<?>) {
                    if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
                        return new LockingXNavigableMapXNavigableKeySetView<E>(
                            (XNavigableMap.XNavigableKeySetView<E>)c, lockingManager);
                    }
                    return new LockingXNavigableSetXNavigableSetView<E>(
                        (XNavigableSet.XNavigableSetView<E>)c, lockingManager);
                }
                return new LockingXNavigableSet<E>(
                    (XNavigableSet<E>)c, lockingManager);
            }
            if (c instanceof XSortedSet.XSortedSetView<?>) {
                if (c instanceof XSortedMap.XSortedKeySetView<?>) {
                    return new LockingXSortedMapXSortedKeySetView<E>(
                        (XSortedMap.XSortedKeySetView<E>)c, lockingManager);
                }
                return new LockingXSortedSetXSortedSetView<E>(
                    (XSortedSet.XSortedSetView<E>)c, lockingManager);
            }
            return new LockingXSortedSet<E>(
                (XSortedSet<E>)c, lockingManager);
        }
        if (c instanceof NavigableSet<?>) {
            return new LockingNavigableSet<E>(
                (NavigableSet<E>)c, lockingManager);
        }
        return new LockingSortedSet<E>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(NavigableSet<E> lockedCollection, LockMode lockMode, Function<NavigableSet<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (NavigableSet<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (NavigableSet<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(NavigableSet<E> lockedCollection, LockMode lockMode, Consumer<NavigableSet<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (NavigableSet<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (NavigableSet<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    @SuppressWarnings("unchecked")
    private static <E> NavigableSet<E> locking(NavigableSet<E> c, LockingManager lockingManager) {
        if (c instanceof Serializable) {
            if (c instanceof MANavigableSet<?>) {
                return new LockingMANavigableSetWithSerializable<E>(
                    (MANavigableSet<E>)c, lockingManager);
            }
            if (c instanceof XNavigableSet<?>) {
                return new LockingXNavigableSetWithSerializable<E>(
                    (XNavigableSet<E>)c, lockingManager);
            }
            return new LockingNavigableSetWithSerializable<E>(c, lockingManager);
        }
        if (c instanceof MANavigableSet<?>) {
            if (c instanceof MANavigableSet.MANavigableSetView<?>) {
                if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                    return new LockingMANavigableMapMANavigableKeySetView<E, Object>(
                        (MANavigableMap.MANavigableKeySetView<E, Object>)c, lockingManager);
                }
                return new LockingMANavigableSetMANavigableSetView<E>(
                    (MANavigableSet.MANavigableSetView<E>)c, lockingManager);
            }
            return new LockingMANavigableSet<E>(
                (MANavigableSet<E>)c, lockingManager);
        }
        if (c instanceof XNavigableSet<?>) {
            if (c instanceof XNavigableSet.XNavigableSetView<?>) {
                if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
                    return new LockingXNavigableMapXNavigableKeySetView<E>(
                        (XNavigableMap.XNavigableKeySetView<E>)c, lockingManager);
                }
                return new LockingXNavigableSetXNavigableSetView<E>(
                    (XNavigableSet.XNavigableSetView<E>)c, lockingManager);
            }
            return new LockingXNavigableSet<E>(
                (XNavigableSet<E>)c, lockingManager);
        }
        return new LockingNavigableSet<E>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(List<E> lockedCollection, LockMode lockMode, Function<List<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (List<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (List<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(List<E> lockedCollection, LockMode lockMode, Consumer<List<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (List<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (List<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    private static <E> List<E> locking(List<E> c, LockingManager lockingManager) {
        if (c instanceof Serializable) {
            if (c instanceof RandomAccess) {
                if (c instanceof MAList<?>) {
                    return new LockingMAListWithSerializableRandomAccess<E>(
                        (MAList<E>)c, lockingManager);
                }
                if (c instanceof XList<?>) {
                    return new LockingXListWithSerializableRandomAccess<E>(
                        (XList<E>)c, lockingManager);
                }
                return new LockingListWithSerializableRandomAccess<E>(c, lockingManager);
            }
            if (c instanceof MAList<?>) {
                return new LockingMAListWithSerializable<E>(
                    (MAList<E>)c, lockingManager);
            }
            if (c instanceof XList<?>) {
                return new LockingXListWithSerializable<E>(
                    (XList<E>)c, lockingManager);
            }
            return new LockingListWithSerializable<E>(c, lockingManager);
        }
        if (c instanceof RandomAccess) {
            if (c instanceof MAList<?>) {
                if (c instanceof MAList.MAListView<?>) {
                    return new LockingMAListMAListViewWithRandomAccess<E>(
                        (MAList.MAListView<E>)c, lockingManager);
                }
                return new LockingMAListWithRandomAccess<E>(
                    (MAList<E>)c, lockingManager);
            }
            if (c instanceof XList<?>) {
                if (c instanceof XList.XListView<?>) {
                    return new LockingXListXListViewWithRandomAccess<E>(
                        (XList.XListView<E>)c, lockingManager);
                }
                return new LockingXListWithRandomAccess<E>(
                    (XList<E>)c, lockingManager);
            }
            return new LockingListWithRandomAccess<E>(c, lockingManager);
        }
        if (c instanceof MAList<?>) {
            if (c instanceof MAList.MAListView<?>) {
                return new LockingMAListMAListView<E>(
                    (MAList.MAListView<E>)c, lockingManager);
            }
            return new LockingMAList<E>(
                (MAList<E>)c, lockingManager);
        }
        if (c instanceof XList<?>) {
            if (c instanceof XList.XListView<?>) {
                return new LockingXListXListView<E>(
                    (XList.XListView<E>)c, lockingManager);
            }
            return new LockingXList<E>(
                (XList<E>)c, lockingManager);
        }
        return new LockingList<E>(c, lockingManager);
    }

    private static <K, V> StandardMap.EntrySet<K, V> locking(StandardMap.EntrySet<K, V> c, LockingManager lockingManager) {
        if (c instanceof Serializable) {
            return new LockingStandardMapEntrySetWithSerializable<K, V>(c, lockingManager);
        }
        return new LockingStandardMapEntrySet<K, V>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(XCollection<E> lockedCollection, LockMode lockMode, Function<XCollection<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XCollection<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XCollection<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(XCollection<E> lockedCollection, LockMode lockMode, Consumer<XCollection<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XCollection<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XCollection<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    private static <E> XCollection<E> locking(XCollection<E> c, LockingManager lockingManager) {
        if (c instanceof Serializable) {
            if (c instanceof MACollection<?>) {
                if (c instanceof MAList<?>) {
                    return new LockingMAListWithSerializable<E>(
                        (MAList<E>)c, lockingManager);
                }
                if (c instanceof MASet<?>) {
                    if (c instanceof MAOrderedSet<?>) {
                        return new LockingMAOrderedSetWithSerializable<E>(
                            (MAOrderedSet<E>)c, lockingManager);
                    }
                    if (c instanceof MASortedSet<?>) {
                        if (c instanceof MANavigableSet<?>) {
                            return new LockingMANavigableSetWithSerializable<E>(
                                (MANavigableSet<E>)c, lockingManager);
                        }
                        return new LockingMASortedSetWithSerializable<E>(
                            (MASortedSet<E>)c, lockingManager);
                    }
                    return new LockingMASetWithSerializable<E>(
                        (MASet<E>)c, lockingManager);
                }
                return new LockingMACollectionWithSerializable<E>(
                    (MACollection<E>)c, lockingManager);
            }
            if (c instanceof XList<?>) {
                return new LockingXListWithSerializable<E>(
                    (XList<E>)c, lockingManager);
            }
            if (c instanceof XSet<?>) {
                if (c instanceof XOrderedSet<?>) {
                    return new LockingXOrderedSetWithSerializable<E>(
                        (XOrderedSet<E>)c, lockingManager);
                }
                if (c instanceof XSortedSet<?>) {
                    if (c instanceof XNavigableSet<?>) {
                        return new LockingXNavigableSetWithSerializable<E>(
                            (XNavigableSet<E>)c, lockingManager);
                    }
                    return new LockingXSortedSetWithSerializable<E>(
                        (XSortedSet<E>)c, lockingManager);
                }
                return new LockingXSetWithSerializable<E>(
                    (XSet<E>)c, lockingManager);
            }
            return new LockingXCollectionWithSerializable<E>(c, lockingManager);
        }
        if (c instanceof MACollection<?>) {
            if (c instanceof MAList<?>) {
                if (c instanceof MAList.MAListView<?>) {
                    return new LockingMAListMAListView<E>(
                        (MAList.MAListView<E>)c, lockingManager);
                }
                return new LockingMAList<E>(
                    (MAList<E>)c, lockingManager);
            }
            if (c instanceof MASet<?>) {
                if (c instanceof MAOrderedSet<?>) {
                    if (c instanceof MAOrderedSet.MAOrderedSetView<?>) {
                        if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
                            return new LockingMAOrderedMapMAOrderedKeySetView<E, Object>(
                                (MAOrderedMap.MAOrderedKeySetView<E, Object>)c, lockingManager);
                        }
                        return new LockingMAOrderedSetMAOrderedSetView<E>(
                            (MAOrderedSet.MAOrderedSetView<E>)c, lockingManager);
                    }
                    return new LockingMAOrderedSet<E>(
                        (MAOrderedSet<E>)c, lockingManager);
                }
                if (c instanceof MASortedSet<?>) {
                    if (c instanceof MANavigableSet<?>) {
                        if (c instanceof MANavigableSet.MANavigableSetView<?>) {
                            if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                                return new LockingMANavigableMapMANavigableKeySetView<E, Object>(
                                    (MANavigableMap.MANavigableKeySetView<E, Object>)c, lockingManager);
                            }
                            return new LockingMANavigableSetMANavigableSetView<E>(
                                (MANavigableSet.MANavigableSetView<E>)c, lockingManager);
                        }
                        return new LockingMANavigableSet<E>(
                            (MANavigableSet<E>)c, lockingManager);
                    }
                    if (c instanceof MASortedSet.MASortedSetView<?>) {
                        if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
                            return new LockingMASortedMapMASortedKeySetView<E, Object>(
                                (MASortedMap.MASortedKeySetView<E, Object>)c, lockingManager);
                        }
                        return new LockingMASortedSetMASortedSetView<E>(
                            (MASortedSet.MASortedSetView<E>)c, lockingManager);
                    }
                    return new LockingMASortedSet<E>(
                        (MASortedSet<E>)c, lockingManager);
                }
                if (c instanceof MAMap.MAEntrySetView<?, ?>) {
                    return new LockingMAMapMAEntrySetView(
                        (MAMap.MAEntrySetView)c, lockingManager);
                }
                if (c instanceof MAMap.MAKeySetView<?, ?>) {
                    return new LockingMAMapMAKeySetView<E, Object>(
                        (MAMap.MAKeySetView<E, Object>)c, lockingManager);
                }
                return new LockingMASet<E>(
                    (MASet<E>)c, lockingManager);
            }
            if (c instanceof MAMap.MAValuesView<?, ?>) {
                return new LockingMAMapMAValuesView<Object, E>(
                    (MAMap.MAValuesView<Object, E>)c, lockingManager);
            }
            return new LockingMACollection<E>(
                (MACollection<E>)c, lockingManager);
        }
        if (c instanceof XList<?>) {
            if (c instanceof XList.XListView<?>) {
                return new LockingXListXListView<E>(
                    (XList.XListView<E>)c, lockingManager);
            }
            return new LockingXList<E>(
                (XList<E>)c, lockingManager);
        }
        if (c instanceof XSet<?>) {
            if (c instanceof XOrderedSet<?>) {
                if (c instanceof XOrderedSet.XOrderedSetView<?>) {
                    if (c instanceof XOrderedMap.XOrderedKeySetView<?>) {
                        return new LockingXOrderedMapXOrderedKeySetView<E>(
                            (XOrderedMap.XOrderedKeySetView<E>)c, lockingManager);
                    }
                    return new LockingXOrderedSetXOrderedSetView<E>(
                        (XOrderedSet.XOrderedSetView<E>)c, lockingManager);
                }
                return new LockingXOrderedSet<E>(
                    (XOrderedSet<E>)c, lockingManager);
            }
            if (c instanceof XSortedSet<?>) {
                if (c instanceof XNavigableSet<?>) {
                    if (c instanceof XNavigableSet.XNavigableSetView<?>) {
                        if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
                            return new LockingXNavigableMapXNavigableKeySetView<E>(
                                (XNavigableMap.XNavigableKeySetView<E>)c, lockingManager);
                        }
                        return new LockingXNavigableSetXNavigableSetView<E>(
                            (XNavigableSet.XNavigableSetView<E>)c, lockingManager);
                    }
                    return new LockingXNavigableSet<E>(
                        (XNavigableSet<E>)c, lockingManager);
                }
                if (c instanceof XSortedSet.XSortedSetView<?>) {
                    if (c instanceof XSortedMap.XSortedKeySetView<?>) {
                        return new LockingXSortedMapXSortedKeySetView<E>(
                            (XSortedMap.XSortedKeySetView<E>)c, lockingManager);
                    }
                    return new LockingXSortedSetXSortedSetView<E>(
                        (XSortedSet.XSortedSetView<E>)c, lockingManager);
                }
                return new LockingXSortedSet<E>(
                    (XSortedSet<E>)c, lockingManager);
            }
            if (c instanceof XMap.XKeySetView<?>) {
                return new LockingXMapXKeySetView<E>(
                    (XMap.XKeySetView<E>)c, lockingManager);
            }
            if (c instanceof XMap.XEntrySetView<?, ?>) {
                return new LockingXMapXEntrySetView(
                    (XMap.XEntrySetView)c, lockingManager);
            }
            return new LockingXSet<E>(
                (XSet<E>)c, lockingManager);
        }
        if (c instanceof XMap.XValuesView<?>) {
            return new LockingXMapXValuesView<E>(
                (XMap.XValuesView<E>)c, lockingManager);
        }
        return new LockingXCollection<E>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <V, R> R locking(XMap.XValuesView<V> lockedCollection, LockMode lockMode, Function<XMap.XValuesView<V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XMap.XValuesView<V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XMap.XValuesView<V>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <V> void locking(XMap.XValuesView<V> lockedCollection, LockMode lockMode, Consumer<XMap.XValuesView<V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XMap.XValuesView<V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XMap.XValuesView<V>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    @SuppressWarnings("unchecked")
    private static <V> XMap.XValuesView<V> locking(XMap.XValuesView<V> c, LockingManager lockingManager) {
        if (c instanceof MAMap.MAValuesView<?, ?>) {
            return new LockingMAMapMAValuesView<Object, V>(
                (MAMap.MAValuesView<Object, V>)c, lockingManager);
        }
        return new LockingXMapXValuesView<V>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(XSet<E> lockedCollection, LockMode lockMode, Function<XSet<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XSet<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XSet<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(XSet<E> lockedCollection, LockMode lockMode, Consumer<XSet<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XSet<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XSet<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    private static <E> XSet<E> locking(XSet<E> c, LockingManager lockingManager) {
        if (c instanceof Serializable) {
            if (c instanceof MAOrderedSet<?>) {
                return new LockingMAOrderedSetWithSerializable<E>(
                    (MAOrderedSet<E>)c, lockingManager);
            }
            if (c instanceof MASortedSet<?>) {
                if (c instanceof MANavigableSet<?>) {
                    return new LockingMANavigableSetWithSerializable<E>(
                        (MANavigableSet<E>)c, lockingManager);
                }
                return new LockingMASortedSetWithSerializable<E>(
                    (MASortedSet<E>)c, lockingManager);
            }
            if (c instanceof MASet<?>) {
                return new LockingMASetWithSerializable<E>(
                    (MASet<E>)c, lockingManager);
            }
            if (c instanceof XOrderedSet<?>) {
                return new LockingXOrderedSetWithSerializable<E>(
                    (XOrderedSet<E>)c, lockingManager);
            }
            if (c instanceof XSortedSet<?>) {
                if (c instanceof XNavigableSet<?>) {
                    return new LockingXNavigableSetWithSerializable<E>(
                        (XNavigableSet<E>)c, lockingManager);
                }
                return new LockingXSortedSetWithSerializable<E>(
                    (XSortedSet<E>)c, lockingManager);
            }
            return new LockingXSetWithSerializable<E>(c, lockingManager);
        }
        if (c instanceof MAOrderedSet<?>) {
            if (c instanceof MAOrderedSet.MAOrderedSetView<?>) {
                if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
                    return new LockingMAOrderedMapMAOrderedKeySetView<E, Object>(
                        (MAOrderedMap.MAOrderedKeySetView<E, Object>)c, lockingManager);
                }
                return new LockingMAOrderedSetMAOrderedSetView<E>(
                    (MAOrderedSet.MAOrderedSetView<E>)c, lockingManager);
            }
            return new LockingMAOrderedSet<E>(
                (MAOrderedSet<E>)c, lockingManager);
        }
        if (c instanceof MASortedSet<?>) {
            if (c instanceof MANavigableSet<?>) {
                if (c instanceof MANavigableSet.MANavigableSetView<?>) {
                    if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                        return new LockingMANavigableMapMANavigableKeySetView<E, Object>(
                            (MANavigableMap.MANavigableKeySetView<E, Object>)c, lockingManager);
                    }
                    return new LockingMANavigableSetMANavigableSetView<E>(
                        (MANavigableSet.MANavigableSetView<E>)c, lockingManager);
                }
                return new LockingMANavigableSet<E>(
                    (MANavigableSet<E>)c, lockingManager);
            }
            if (c instanceof MASortedSet.MASortedSetView<?>) {
                if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
                    return new LockingMASortedMapMASortedKeySetView<E, Object>(
                        (MASortedMap.MASortedKeySetView<E, Object>)c, lockingManager);
                }
                return new LockingMASortedSetMASortedSetView<E>(
                    (MASortedSet.MASortedSetView<E>)c, lockingManager);
            }
            return new LockingMASortedSet<E>(
                (MASortedSet<E>)c, lockingManager);
        }
        if (c instanceof MAMap.MAEntrySetView<?, ?>) {
            return new LockingMAMapMAEntrySetView(
                (MAMap.MAEntrySetView)c, lockingManager);
        }
        if (c instanceof MASet<?>) {
            if (c instanceof MAMap.MAKeySetView<?, ?>) {
                return new LockingMAMapMAKeySetView<E, Object>(
                    (MAMap.MAKeySetView<E, Object>)c, lockingManager);
            }
            return new LockingMASet<E>(
                (MASet<E>)c, lockingManager);
        }
        if (c instanceof XOrderedSet<?>) {
            if (c instanceof XOrderedSet.XOrderedSetView<?>) {
                if (c instanceof XOrderedMap.XOrderedKeySetView<?>) {
                    return new LockingXOrderedMapXOrderedKeySetView<E>(
                        (XOrderedMap.XOrderedKeySetView<E>)c, lockingManager);
                }
                return new LockingXOrderedSetXOrderedSetView<E>(
                    (XOrderedSet.XOrderedSetView<E>)c, lockingManager);
            }
            return new LockingXOrderedSet<E>(
                (XOrderedSet<E>)c, lockingManager);
        }
        if (c instanceof XSortedSet<?>) {
            if (c instanceof XNavigableSet<?>) {
                if (c instanceof XNavigableSet.XNavigableSetView<?>) {
                    if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
                        return new LockingXNavigableMapXNavigableKeySetView<E>(
                            (XNavigableMap.XNavigableKeySetView<E>)c, lockingManager);
                    }
                    return new LockingXNavigableSetXNavigableSetView<E>(
                        (XNavigableSet.XNavigableSetView<E>)c, lockingManager);
                }
                return new LockingXNavigableSet<E>(
                    (XNavigableSet<E>)c, lockingManager);
            }
            if (c instanceof XSortedSet.XSortedSetView<?>) {
                if (c instanceof XSortedMap.XSortedKeySetView<?>) {
                    return new LockingXSortedMapXSortedKeySetView<E>(
                        (XSortedMap.XSortedKeySetView<E>)c, lockingManager);
                }
                return new LockingXSortedSetXSortedSetView<E>(
                    (XSortedSet.XSortedSetView<E>)c, lockingManager);
            }
            return new LockingXSortedSet<E>(
                (XSortedSet<E>)c, lockingManager);
        }
        if (c instanceof XMap.XKeySetView<?>) {
            return new LockingXMapXKeySetView<E>(
                (XMap.XKeySetView<E>)c, lockingManager);
        }
        if (c instanceof XMap.XEntrySetView<?, ?>) {
            return new LockingXMapXEntrySetView(
                (XMap.XEntrySetView)c, lockingManager);
        }
        return new LockingXSet<E>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(XMap.XEntrySetView<K, V> lockedCollection, LockMode lockMode, Function<XMap.XEntrySetView<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XMap.XEntrySetView<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XMap.XEntrySetView<K, V>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(XMap.XEntrySetView<K, V> lockedCollection, LockMode lockMode, Consumer<XMap.XEntrySetView<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XMap.XEntrySetView<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XMap.XEntrySetView<K, V>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    private static <K, V> XMap.XEntrySetView<K, V> locking(XMap.XEntrySetView<K, V> c, LockingManager lockingManager) {
        if (c instanceof MAMap.MAEntrySetView<?, ?>) {
            return new LockingMAMapMAEntrySetView(
                (MAMap.MAEntrySetView)c, lockingManager);
        }
        return new LockingXMapXEntrySetView<K, V>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, R> R locking(XMap.XKeySetView<K> lockedCollection, LockMode lockMode, Function<XMap.XKeySetView<K>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XMap.XKeySetView<K>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XMap.XKeySetView<K>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K> void locking(XMap.XKeySetView<K> lockedCollection, LockMode lockMode, Consumer<XMap.XKeySetView<K>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XMap.XKeySetView<K>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XMap.XKeySetView<K>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    @SuppressWarnings("unchecked")
    private static <K> XMap.XKeySetView<K> locking(XMap.XKeySetView<K> c, LockingManager lockingManager) {
        if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
            return new LockingMAOrderedMapMAOrderedKeySetView<K, Object>(
                (MAOrderedMap.MAOrderedKeySetView<K, Object>)c, lockingManager);
        }
        if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
            return new LockingMANavigableMapMANavigableKeySetView<K, Object>(
                (MANavigableMap.MANavigableKeySetView<K, Object>)c, lockingManager);
        }
        if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
            return new LockingMASortedMapMASortedKeySetView<K, Object>(
                (MASortedMap.MASortedKeySetView<K, Object>)c, lockingManager);
        }
        if (c instanceof MAMap.MAKeySetView<?, ?>) {
            return new LockingMAMapMAKeySetView<K, Object>(
                (MAMap.MAKeySetView<K, Object>)c, lockingManager);
        }
        if (c instanceof XOrderedMap.XOrderedKeySetView<?>) {
            return new LockingXOrderedMapXOrderedKeySetView<K>(
                (XOrderedMap.XOrderedKeySetView<K>)c, lockingManager);
        }
        if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
            return new LockingXNavigableMapXNavigableKeySetView<K>(
                (XNavigableMap.XNavigableKeySetView<K>)c, lockingManager);
        }
        if (c instanceof XSortedMap.XSortedKeySetView<?>) {
            return new LockingXSortedMapXSortedKeySetView<K>(
                (XSortedMap.XSortedKeySetView<K>)c, lockingManager);
        }
        return new LockingXMapXKeySetView<K>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(XSortedSet<E> lockedCollection, LockMode lockMode, Function<XSortedSet<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XSortedSet<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XSortedSet<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(XSortedSet<E> lockedCollection, LockMode lockMode, Consumer<XSortedSet<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XSortedSet<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XSortedSet<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    @SuppressWarnings("unchecked")
    private static <E> XSortedSet<E> locking(XSortedSet<E> c, LockingManager lockingManager) {
        if (c instanceof Serializable) {
            if (c instanceof MASortedSet<?>) {
                if (c instanceof MANavigableSet<?>) {
                    return new LockingMANavigableSetWithSerializable<E>(
                        (MANavigableSet<E>)c, lockingManager);
                }
                return new LockingMASortedSetWithSerializable<E>(
                    (MASortedSet<E>)c, lockingManager);
            }
            if (c instanceof XNavigableSet<?>) {
                return new LockingXNavigableSetWithSerializable<E>(
                    (XNavigableSet<E>)c, lockingManager);
            }
            return new LockingXSortedSetWithSerializable<E>(c, lockingManager);
        }
        if (c instanceof MASortedSet<?>) {
            if (c instanceof MANavigableSet<?>) {
                if (c instanceof MANavigableSet.MANavigableSetView<?>) {
                    if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                        return new LockingMANavigableMapMANavigableKeySetView<E, Object>(
                            (MANavigableMap.MANavigableKeySetView<E, Object>)c, lockingManager);
                    }
                    return new LockingMANavigableSetMANavigableSetView<E>(
                        (MANavigableSet.MANavigableSetView<E>)c, lockingManager);
                }
                return new LockingMANavigableSet<E>(
                    (MANavigableSet<E>)c, lockingManager);
            }
            if (c instanceof MASortedSet.MASortedSetView<?>) {
                if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
                    return new LockingMASortedMapMASortedKeySetView<E, Object>(
                        (MASortedMap.MASortedKeySetView<E, Object>)c, lockingManager);
                }
                return new LockingMASortedSetMASortedSetView<E>(
                    (MASortedSet.MASortedSetView<E>)c, lockingManager);
            }
            return new LockingMASortedSet<E>(
                (MASortedSet<E>)c, lockingManager);
        }
        if (c instanceof XNavigableSet<?>) {
            if (c instanceof XNavigableSet.XNavigableSetView<?>) {
                if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
                    return new LockingXNavigableMapXNavigableKeySetView<E>(
                        (XNavigableMap.XNavigableKeySetView<E>)c, lockingManager);
                }
                return new LockingXNavigableSetXNavigableSetView<E>(
                    (XNavigableSet.XNavigableSetView<E>)c, lockingManager);
            }
            return new LockingXNavigableSet<E>(
                (XNavigableSet<E>)c, lockingManager);
        }
        if (c instanceof XSortedSet.XSortedSetView<?>) {
            if (c instanceof XSortedMap.XSortedKeySetView<?>) {
                return new LockingXSortedMapXSortedKeySetView<E>(
                    (XSortedMap.XSortedKeySetView<E>)c, lockingManager);
            }
            return new LockingXSortedSetXSortedSetView<E>(
                (XSortedSet.XSortedSetView<E>)c, lockingManager);
        }
        return new LockingXSortedSet<E>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(XSortedSet.XSortedSetView<E> lockedCollection, LockMode lockMode, Function<XSortedSet.XSortedSetView<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XSortedSet.XSortedSetView<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XSortedSet.XSortedSetView<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(XSortedSet.XSortedSetView<E> lockedCollection, LockMode lockMode, Consumer<XSortedSet.XSortedSetView<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XSortedSet.XSortedSetView<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XSortedSet.XSortedSetView<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    @SuppressWarnings("unchecked")
    private static <E> XSortedSet.XSortedSetView<E> locking(XSortedSet.XSortedSetView<E> c, LockingManager lockingManager) {
        if (c instanceof MANavigableSet.MANavigableSetView<?>) {
            if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                return new LockingMANavigableMapMANavigableKeySetView<E, Object>(
                    (MANavigableMap.MANavigableKeySetView<E, Object>)c, lockingManager);
            }
            return new LockingMANavigableSetMANavigableSetView<E>(
                (MANavigableSet.MANavigableSetView<E>)c, lockingManager);
        }
        if (c instanceof MASortedSet.MASortedSetView<?>) {
            if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
                return new LockingMASortedMapMASortedKeySetView<E, Object>(
                    (MASortedMap.MASortedKeySetView<E, Object>)c, lockingManager);
            }
            return new LockingMASortedSetMASortedSetView<E>(
                (MASortedSet.MASortedSetView<E>)c, lockingManager);
        }
        if (c instanceof XNavigableSet.XNavigableSetView<?>) {
            if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
                return new LockingXNavigableMapXNavigableKeySetView<E>(
                    (XNavigableMap.XNavigableKeySetView<E>)c, lockingManager);
            }
            return new LockingXNavigableSetXNavigableSetView<E>(
                (XNavigableSet.XNavigableSetView<E>)c, lockingManager);
        }
        if (c instanceof XSortedMap.XSortedKeySetView<?>) {
            return new LockingXSortedMapXSortedKeySetView<E>(
                (XSortedMap.XSortedKeySetView<E>)c, lockingManager);
        }
        return new LockingXSortedSetXSortedSetView<E>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, R> R locking(XSortedMap.XSortedKeySetView<K> lockedCollection, LockMode lockMode, Function<XSortedMap.XSortedKeySetView<K>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XSortedMap.XSortedKeySetView<K>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XSortedMap.XSortedKeySetView<K>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K> void locking(XSortedMap.XSortedKeySetView<K> lockedCollection, LockMode lockMode, Consumer<XSortedMap.XSortedKeySetView<K>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XSortedMap.XSortedKeySetView<K>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XSortedMap.XSortedKeySetView<K>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    @SuppressWarnings("unchecked")
    private static <K> XSortedMap.XSortedKeySetView<K> locking(XSortedMap.XSortedKeySetView<K> c, LockingManager lockingManager) {
        if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
            return new LockingMANavigableMapMANavigableKeySetView<K, Object>(
                (MANavigableMap.MANavigableKeySetView<K, Object>)c, lockingManager);
        }
        if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
            return new LockingMASortedMapMASortedKeySetView<K, Object>(
                (MASortedMap.MASortedKeySetView<K, Object>)c, lockingManager);
        }
        if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
            return new LockingXNavigableMapXNavigableKeySetView<K>(
                (XNavigableMap.XNavigableKeySetView<K>)c, lockingManager);
        }
        return new LockingXSortedMapXSortedKeySetView<K>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(XNavigableSet<E> lockedCollection, LockMode lockMode, Function<XNavigableSet<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XNavigableSet<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XNavigableSet<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(XNavigableSet<E> lockedCollection, LockMode lockMode, Consumer<XNavigableSet<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XNavigableSet<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XNavigableSet<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    @SuppressWarnings("unchecked")
    private static <E> XNavigableSet<E> locking(XNavigableSet<E> c, LockingManager lockingManager) {
        if (c instanceof Serializable) {
            if (c instanceof MANavigableSet<?>) {
                return new LockingMANavigableSetWithSerializable<E>(
                    (MANavigableSet<E>)c, lockingManager);
            }
            return new LockingXNavigableSetWithSerializable<E>(c, lockingManager);
        }
        if (c instanceof MANavigableSet<?>) {
            if (c instanceof MANavigableSet.MANavigableSetView<?>) {
                if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                    return new LockingMANavigableMapMANavigableKeySetView<E, Object>(
                        (MANavigableMap.MANavigableKeySetView<E, Object>)c, lockingManager);
                }
                return new LockingMANavigableSetMANavigableSetView<E>(
                    (MANavigableSet.MANavigableSetView<E>)c, lockingManager);
            }
            return new LockingMANavigableSet<E>(
                (MANavigableSet<E>)c, lockingManager);
        }
        if (c instanceof XNavigableSet.XNavigableSetView<?>) {
            if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
                return new LockingXNavigableMapXNavigableKeySetView<E>(
                    (XNavigableMap.XNavigableKeySetView<E>)c, lockingManager);
            }
            return new LockingXNavigableSetXNavigableSetView<E>(
                (XNavigableSet.XNavigableSetView<E>)c, lockingManager);
        }
        return new LockingXNavigableSet<E>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(XNavigableSet.XNavigableSetView<E> lockedCollection, LockMode lockMode, Function<XNavigableSet.XNavigableSetView<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XNavigableSet.XNavigableSetView<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XNavigableSet.XNavigableSetView<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(XNavigableSet.XNavigableSetView<E> lockedCollection, LockMode lockMode, Consumer<XNavigableSet.XNavigableSetView<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XNavigableSet.XNavigableSetView<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XNavigableSet.XNavigableSetView<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    @SuppressWarnings("unchecked")
    private static <E> XNavigableSet.XNavigableSetView<E> locking(XNavigableSet.XNavigableSetView<E> c, LockingManager lockingManager) {
        if (c instanceof MANavigableSet.MANavigableSetView<?>) {
            if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                return new LockingMANavigableMapMANavigableKeySetView<E, Object>(
                    (MANavigableMap.MANavigableKeySetView<E, Object>)c, lockingManager);
            }
            return new LockingMANavigableSetMANavigableSetView<E>(
                (MANavigableSet.MANavigableSetView<E>)c, lockingManager);
        }
        if (c instanceof XNavigableMap.XNavigableKeySetView<?>) {
            return new LockingXNavigableMapXNavigableKeySetView<E>(
                (XNavigableMap.XNavigableKeySetView<E>)c, lockingManager);
        }
        return new LockingXNavigableSetXNavigableSetView<E>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, R> R locking(XNavigableMap.XNavigableKeySetView<K> lockedCollection, LockMode lockMode, Function<XNavigableMap.XNavigableKeySetView<K>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XNavigableMap.XNavigableKeySetView<K>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XNavigableMap.XNavigableKeySetView<K>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K> void locking(XNavigableMap.XNavigableKeySetView<K> lockedCollection, LockMode lockMode, Consumer<XNavigableMap.XNavigableKeySetView<K>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XNavigableMap.XNavigableKeySetView<K>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XNavigableMap.XNavigableKeySetView<K>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    @SuppressWarnings("unchecked")
    private static <K> XNavigableMap.XNavigableKeySetView<K> locking(XNavigableMap.XNavigableKeySetView<K> c, LockingManager lockingManager) {
        if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
            return new LockingMANavigableMapMANavigableKeySetView<K, Object>(
                (MANavigableMap.MANavigableKeySetView<K, Object>)c, lockingManager);
        }
        return new LockingXNavigableMapXNavigableKeySetView<K>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(XOrderedSet<E> lockedCollection, LockMode lockMode, Function<XOrderedSet<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XOrderedSet<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XOrderedSet<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(XOrderedSet<E> lockedCollection, LockMode lockMode, Consumer<XOrderedSet<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XOrderedSet<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XOrderedSet<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    @SuppressWarnings("unchecked")
    private static <E> XOrderedSet<E> locking(XOrderedSet<E> c, LockingManager lockingManager) {
        if (c instanceof Serializable) {
            if (c instanceof MAOrderedSet<?>) {
                return new LockingMAOrderedSetWithSerializable<E>(
                    (MAOrderedSet<E>)c, lockingManager);
            }
            return new LockingXOrderedSetWithSerializable<E>(c, lockingManager);
        }
        if (c instanceof MAOrderedSet<?>) {
            if (c instanceof MAOrderedSet.MAOrderedSetView<?>) {
                if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
                    return new LockingMAOrderedMapMAOrderedKeySetView<E, Object>(
                        (MAOrderedMap.MAOrderedKeySetView<E, Object>)c, lockingManager);
                }
                return new LockingMAOrderedSetMAOrderedSetView<E>(
                    (MAOrderedSet.MAOrderedSetView<E>)c, lockingManager);
            }
            return new LockingMAOrderedSet<E>(
                (MAOrderedSet<E>)c, lockingManager);
        }
        if (c instanceof XOrderedSet.XOrderedSetView<?>) {
            if (c instanceof XOrderedMap.XOrderedKeySetView<?>) {
                return new LockingXOrderedMapXOrderedKeySetView<E>(
                    (XOrderedMap.XOrderedKeySetView<E>)c, lockingManager);
            }
            return new LockingXOrderedSetXOrderedSetView<E>(
                (XOrderedSet.XOrderedSetView<E>)c, lockingManager);
        }
        return new LockingXOrderedSet<E>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(XOrderedSet.XOrderedSetView<E> lockedCollection, LockMode lockMode, Function<XOrderedSet.XOrderedSetView<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XOrderedSet.XOrderedSetView<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XOrderedSet.XOrderedSetView<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(XOrderedSet.XOrderedSetView<E> lockedCollection, LockMode lockMode, Consumer<XOrderedSet.XOrderedSetView<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XOrderedSet.XOrderedSetView<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XOrderedSet.XOrderedSetView<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    @SuppressWarnings("unchecked")
    private static <E> XOrderedSet.XOrderedSetView<E> locking(XOrderedSet.XOrderedSetView<E> c, LockingManager lockingManager) {
        if (c instanceof MAOrderedSet.MAOrderedSetView<?>) {
            if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
                return new LockingMAOrderedMapMAOrderedKeySetView<E, Object>(
                    (MAOrderedMap.MAOrderedKeySetView<E, Object>)c, lockingManager);
            }
            return new LockingMAOrderedSetMAOrderedSetView<E>(
                (MAOrderedSet.MAOrderedSetView<E>)c, lockingManager);
        }
        if (c instanceof XOrderedMap.XOrderedKeySetView<?>) {
            return new LockingXOrderedMapXOrderedKeySetView<E>(
                (XOrderedMap.XOrderedKeySetView<E>)c, lockingManager);
        }
        return new LockingXOrderedSetXOrderedSetView<E>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, R> R locking(XOrderedMap.XOrderedKeySetView<K> lockedCollection, LockMode lockMode, Function<XOrderedMap.XOrderedKeySetView<K>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XOrderedMap.XOrderedKeySetView<K>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XOrderedMap.XOrderedKeySetView<K>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K> void locking(XOrderedMap.XOrderedKeySetView<K> lockedCollection, LockMode lockMode, Consumer<XOrderedMap.XOrderedKeySetView<K>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XOrderedMap.XOrderedKeySetView<K>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XOrderedMap.XOrderedKeySetView<K>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    @SuppressWarnings("unchecked")
    private static <K> XOrderedMap.XOrderedKeySetView<K> locking(XOrderedMap.XOrderedKeySetView<K> c, LockingManager lockingManager) {
        if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
            return new LockingMAOrderedMapMAOrderedKeySetView<K, Object>(
                (MAOrderedMap.MAOrderedKeySetView<K, Object>)c, lockingManager);
        }
        return new LockingXOrderedMapXOrderedKeySetView<K>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(XList<E> lockedCollection, LockMode lockMode, Function<XList<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XList<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XList<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(XList<E> lockedCollection, LockMode lockMode, Consumer<XList<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XList<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XList<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    private static <E> XList<E> locking(XList<E> c, LockingManager lockingManager) {
        if (c instanceof Serializable) {
            if (c instanceof RandomAccess) {
                if (c instanceof MAList<?>) {
                    return new LockingMAListWithSerializableRandomAccess<E>(
                        (MAList<E>)c, lockingManager);
                }
                return new LockingXListWithSerializableRandomAccess<E>(c, lockingManager);
            }
            if (c instanceof MAList<?>) {
                return new LockingMAListWithSerializable<E>(
                    (MAList<E>)c, lockingManager);
            }
            return new LockingXListWithSerializable<E>(c, lockingManager);
        }
        if (c instanceof RandomAccess) {
            if (c instanceof MAList<?>) {
                if (c instanceof MAList.MAListView<?>) {
                    return new LockingMAListMAListViewWithRandomAccess<E>(
                        (MAList.MAListView<E>)c, lockingManager);
                }
                return new LockingMAListWithRandomAccess<E>(
                    (MAList<E>)c, lockingManager);
            }
            if (c instanceof XList.XListView<?>) {
                return new LockingXListXListViewWithRandomAccess<E>(
                    (XList.XListView<E>)c, lockingManager);
            }
            return new LockingXListWithRandomAccess<E>(c, lockingManager);
        }
        if (c instanceof MAList<?>) {
            if (c instanceof MAList.MAListView<?>) {
                return new LockingMAListMAListView<E>(
                    (MAList.MAListView<E>)c, lockingManager);
            }
            return new LockingMAList<E>(
                (MAList<E>)c, lockingManager);
        }
        if (c instanceof XList.XListView<?>) {
            return new LockingXListXListView<E>(
                (XList.XListView<E>)c, lockingManager);
        }
        return new LockingXList<E>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(XList.XListView<E> lockedCollection, LockMode lockMode, Function<XList.XListView<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XList.XListView<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XList.XListView<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(XList.XListView<E> lockedCollection, LockMode lockMode, Consumer<XList.XListView<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (XList.XListView<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (XList.XListView<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    private static <E> XList.XListView<E> locking(XList.XListView<E> c, LockingManager lockingManager) {
        if (c instanceof RandomAccess) {
            if (c instanceof MAList.MAListView<?>) {
                return new LockingMAListMAListViewWithRandomAccess<E>(
                    (MAList.MAListView<E>)c, lockingManager);
            }
            return new LockingXListXListViewWithRandomAccess<E>(c, lockingManager);
        }
        if (c instanceof MAList.MAListView<?>) {
            return new LockingMAListMAListView<E>(
                (MAList.MAListView<E>)c, lockingManager);
        }
        return new LockingXListXListView<E>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(MACollection<E> lockedCollection, LockMode lockMode, Function<MACollection<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MACollection<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MACollection<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(MACollection<E> lockedCollection, LockMode lockMode, Consumer<MACollection<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MACollection<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MACollection<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    private static <E> MACollection<E> locking(MACollection<E> c, LockingManager lockingManager) {
        if (c instanceof Serializable) {
            if (c instanceof MAList<?>) {
                return new LockingMAListWithSerializable<E>(
                    (MAList<E>)c, lockingManager);
            }
            if (c instanceof MASet<?>) {
                if (c instanceof MAOrderedSet<?>) {
                    return new LockingMAOrderedSetWithSerializable<E>(
                        (MAOrderedSet<E>)c, lockingManager);
                }
                if (c instanceof MASortedSet<?>) {
                    if (c instanceof MANavigableSet<?>) {
                        return new LockingMANavigableSetWithSerializable<E>(
                            (MANavigableSet<E>)c, lockingManager);
                    }
                    return new LockingMASortedSetWithSerializable<E>(
                        (MASortedSet<E>)c, lockingManager);
                }
                return new LockingMASetWithSerializable<E>(
                    (MASet<E>)c, lockingManager);
            }
            return new LockingMACollectionWithSerializable<E>(c, lockingManager);
        }
        if (c instanceof MAList<?>) {
            if (c instanceof MAList.MAListView<?>) {
                return new LockingMAListMAListView<E>(
                    (MAList.MAListView<E>)c, lockingManager);
            }
            return new LockingMAList<E>(
                (MAList<E>)c, lockingManager);
        }
        if (c instanceof MASet<?>) {
            if (c instanceof MAOrderedSet<?>) {
                if (c instanceof MAOrderedSet.MAOrderedSetView<?>) {
                    if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
                        return new LockingMAOrderedMapMAOrderedKeySetView<E, Object>(
                            (MAOrderedMap.MAOrderedKeySetView<E, Object>)c, lockingManager);
                    }
                    return new LockingMAOrderedSetMAOrderedSetView<E>(
                        (MAOrderedSet.MAOrderedSetView<E>)c, lockingManager);
                }
                return new LockingMAOrderedSet<E>(
                    (MAOrderedSet<E>)c, lockingManager);
            }
            if (c instanceof MASortedSet<?>) {
                if (c instanceof MANavigableSet<?>) {
                    if (c instanceof MANavigableSet.MANavigableSetView<?>) {
                        if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                            return new LockingMANavigableMapMANavigableKeySetView<E, Object>(
                                (MANavigableMap.MANavigableKeySetView<E, Object>)c, lockingManager);
                        }
                        return new LockingMANavigableSetMANavigableSetView<E>(
                            (MANavigableSet.MANavigableSetView<E>)c, lockingManager);
                    }
                    return new LockingMANavigableSet<E>(
                        (MANavigableSet<E>)c, lockingManager);
                }
                if (c instanceof MASortedSet.MASortedSetView<?>) {
                    if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
                        return new LockingMASortedMapMASortedKeySetView<E, Object>(
                            (MASortedMap.MASortedKeySetView<E, Object>)c, lockingManager);
                    }
                    return new LockingMASortedSetMASortedSetView<E>(
                        (MASortedSet.MASortedSetView<E>)c, lockingManager);
                }
                return new LockingMASortedSet<E>(
                    (MASortedSet<E>)c, lockingManager);
            }
            if (c instanceof MAMap.MAEntrySetView<?, ?>) {
                return new LockingMAMapMAEntrySetView(
                    (MAMap.MAEntrySetView)c, lockingManager);
            }
            if (c instanceof MAMap.MAKeySetView<?, ?>) {
                return new LockingMAMapMAKeySetView<E, Object>(
                    (MAMap.MAKeySetView<E, Object>)c, lockingManager);
            }
            return new LockingMASet<E>(
                (MASet<E>)c, lockingManager);
        }
        if (c instanceof MAMap.MAValuesView<?, ?>) {
            return new LockingMAMapMAValuesView<Object, E>(
                (MAMap.MAValuesView<Object, E>)c, lockingManager);
        }
        return new LockingMACollection<E>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(MASet<E> lockedCollection, LockMode lockMode, Function<MASet<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MASet<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MASet<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(MASet<E> lockedCollection, LockMode lockMode, Consumer<MASet<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MASet<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MASet<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    private static <E> MASet<E> locking(MASet<E> c, LockingManager lockingManager) {
        if (c instanceof Serializable) {
            if (c instanceof MAOrderedSet<?>) {
                return new LockingMAOrderedSetWithSerializable<E>(
                    (MAOrderedSet<E>)c, lockingManager);
            }
            if (c instanceof MASortedSet<?>) {
                if (c instanceof MANavigableSet<?>) {
                    return new LockingMANavigableSetWithSerializable<E>(
                        (MANavigableSet<E>)c, lockingManager);
                }
                return new LockingMASortedSetWithSerializable<E>(
                    (MASortedSet<E>)c, lockingManager);
            }
            return new LockingMASetWithSerializable<E>(c, lockingManager);
        }
        if (c instanceof MAOrderedSet<?>) {
            if (c instanceof MAOrderedSet.MAOrderedSetView<?>) {
                if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
                    return new LockingMAOrderedMapMAOrderedKeySetView<E, Object>(
                        (MAOrderedMap.MAOrderedKeySetView<E, Object>)c, lockingManager);
                }
                return new LockingMAOrderedSetMAOrderedSetView<E>(
                    (MAOrderedSet.MAOrderedSetView<E>)c, lockingManager);
            }
            return new LockingMAOrderedSet<E>(
                (MAOrderedSet<E>)c, lockingManager);
        }
        if (c instanceof MASortedSet<?>) {
            if (c instanceof MANavigableSet<?>) {
                if (c instanceof MANavigableSet.MANavigableSetView<?>) {
                    if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                        return new LockingMANavigableMapMANavigableKeySetView<E, Object>(
                            (MANavigableMap.MANavigableKeySetView<E, Object>)c, lockingManager);
                    }
                    return new LockingMANavigableSetMANavigableSetView<E>(
                        (MANavigableSet.MANavigableSetView<E>)c, lockingManager);
                }
                return new LockingMANavigableSet<E>(
                    (MANavigableSet<E>)c, lockingManager);
            }
            if (c instanceof MASortedSet.MASortedSetView<?>) {
                if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
                    return new LockingMASortedMapMASortedKeySetView<E, Object>(
                        (MASortedMap.MASortedKeySetView<E, Object>)c, lockingManager);
                }
                return new LockingMASortedSetMASortedSetView<E>(
                    (MASortedSet.MASortedSetView<E>)c, lockingManager);
            }
            return new LockingMASortedSet<E>(
                (MASortedSet<E>)c, lockingManager);
        }
        if (c instanceof MAMap.MAEntrySetView<?, ?>) {
            return new LockingMAMapMAEntrySetView(
                (MAMap.MAEntrySetView)c, lockingManager);
        }
        if (c instanceof MAMap.MAKeySetView<?, ?>) {
            return new LockingMAMapMAKeySetView<E, Object>(
                (MAMap.MAKeySetView<E, Object>)c, lockingManager);
        }
        return new LockingMASet<E>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(MAMap.MAKeySetView<K, V> lockedCollection, LockMode lockMode, Function<MAMap.MAKeySetView<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MAMap.MAKeySetView<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MAMap.MAKeySetView<K, V>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(MAMap.MAKeySetView<K, V> lockedCollection, LockMode lockMode, Consumer<MAMap.MAKeySetView<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MAMap.MAKeySetView<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MAMap.MAKeySetView<K, V>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    private static <K, V> MAMap.MAKeySetView<K, V> locking(MAMap.MAKeySetView<K, V> c, LockingManager lockingManager) {
        if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
            return new LockingMAOrderedMapMAOrderedKeySetView<K, V>(
                (MAOrderedMap.MAOrderedKeySetView<K, V>)c, lockingManager);
        }
        if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
            return new LockingMANavigableMapMANavigableKeySetView<K, V>(
                (MANavigableMap.MANavigableKeySetView<K, V>)c, lockingManager);
        }
        if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
            return new LockingMASortedMapMASortedKeySetView<K, V>(
                (MASortedMap.MASortedKeySetView<K, V>)c, lockingManager);
        }
        return new LockingMAMapMAKeySetView<K, V>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(MAMap.MAValuesView<K, V> lockedCollection, LockMode lockMode, Function<MAMap.MAValuesView<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MAMap.MAValuesView<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MAMap.MAValuesView<K, V>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(MAMap.MAValuesView<K, V> lockedCollection, LockMode lockMode, Consumer<MAMap.MAValuesView<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MAMap.MAValuesView<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MAMap.MAValuesView<K, V>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    private static <K, V> MAMap.MAValuesView<K, V> locking(MAMap.MAValuesView<K, V> c, LockingManager lockingManager) {
        return new LockingMAMapMAValuesView<K, V>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(MAMap.MAEntrySetView<K, V> lockedCollection, LockMode lockMode, Function<MAMap.MAEntrySetView<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MAMap.MAEntrySetView<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MAMap.MAEntrySetView<K, V>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(MAMap.MAEntrySetView<K, V> lockedCollection, LockMode lockMode, Consumer<MAMap.MAEntrySetView<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MAMap.MAEntrySetView<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MAMap.MAEntrySetView<K, V>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    private static <K, V> MAMap.MAEntrySetView<K, V> locking(MAMap.MAEntrySetView<K, V> c, LockingManager lockingManager) {
        return new LockingMAMapMAEntrySetView<K, V>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(MASortedSet<E> lockedCollection, LockMode lockMode, Function<MASortedSet<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MASortedSet<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MASortedSet<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(MASortedSet<E> lockedCollection, LockMode lockMode, Consumer<MASortedSet<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MASortedSet<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MASortedSet<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    @SuppressWarnings("unchecked")
    private static <E> MASortedSet<E> locking(MASortedSet<E> c, LockingManager lockingManager) {
        if (c instanceof Serializable) {
            if (c instanceof MANavigableSet<?>) {
                return new LockingMANavigableSetWithSerializable<E>(
                    (MANavigableSet<E>)c, lockingManager);
            }
            return new LockingMASortedSetWithSerializable<E>(c, lockingManager);
        }
        if (c instanceof MANavigableSet<?>) {
            if (c instanceof MANavigableSet.MANavigableSetView<?>) {
                if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                    return new LockingMANavigableMapMANavigableKeySetView<E, Object>(
                        (MANavigableMap.MANavigableKeySetView<E, Object>)c, lockingManager);
                }
                return new LockingMANavigableSetMANavigableSetView<E>(
                    (MANavigableSet.MANavigableSetView<E>)c, lockingManager);
            }
            return new LockingMANavigableSet<E>(
                (MANavigableSet<E>)c, lockingManager);
        }
        if (c instanceof MASortedSet.MASortedSetView<?>) {
            if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
                return new LockingMASortedMapMASortedKeySetView<E, Object>(
                    (MASortedMap.MASortedKeySetView<E, Object>)c, lockingManager);
            }
            return new LockingMASortedSetMASortedSetView<E>(
                (MASortedSet.MASortedSetView<E>)c, lockingManager);
        }
        return new LockingMASortedSet<E>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(MASortedSet.MASortedSetView<E> lockedCollection, LockMode lockMode, Function<MASortedSet.MASortedSetView<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MASortedSet.MASortedSetView<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MASortedSet.MASortedSetView<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(MASortedSet.MASortedSetView<E> lockedCollection, LockMode lockMode, Consumer<MASortedSet.MASortedSetView<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MASortedSet.MASortedSetView<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MASortedSet.MASortedSetView<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    @SuppressWarnings("unchecked")
    private static <E> MASortedSet.MASortedSetView<E> locking(MASortedSet.MASortedSetView<E> c, LockingManager lockingManager) {
        if (c instanceof MANavigableSet.MANavigableSetView<?>) {
            if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                return new LockingMANavigableMapMANavigableKeySetView<E, Object>(
                    (MANavigableMap.MANavigableKeySetView<E, Object>)c, lockingManager);
            }
            return new LockingMANavigableSetMANavigableSetView<E>(
                (MANavigableSet.MANavigableSetView<E>)c, lockingManager);
        }
        if (c instanceof MASortedMap.MASortedKeySetView<?, ?>) {
            return new LockingMASortedMapMASortedKeySetView<E, Object>(
                (MASortedMap.MASortedKeySetView<E, Object>)c, lockingManager);
        }
        return new LockingMASortedSetMASortedSetView<E>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(MASortedMap.MASortedKeySetView<K, V> lockedCollection, LockMode lockMode, Function<MASortedMap.MASortedKeySetView<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MASortedMap.MASortedKeySetView<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MASortedMap.MASortedKeySetView<K, V>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(MASortedMap.MASortedKeySetView<K, V> lockedCollection, LockMode lockMode, Consumer<MASortedMap.MASortedKeySetView<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MASortedMap.MASortedKeySetView<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MASortedMap.MASortedKeySetView<K, V>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    private static <K, V> MASortedMap.MASortedKeySetView<K, V> locking(MASortedMap.MASortedKeySetView<K, V> c, LockingManager lockingManager) {
        if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
            return new LockingMANavigableMapMANavigableKeySetView<K, V>(
                (MANavigableMap.MANavigableKeySetView<K, V>)c, lockingManager);
        }
        return new LockingMASortedMapMASortedKeySetView<K, V>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(MANavigableSet<E> lockedCollection, LockMode lockMode, Function<MANavigableSet<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MANavigableSet<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MANavigableSet<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(MANavigableSet<E> lockedCollection, LockMode lockMode, Consumer<MANavigableSet<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MANavigableSet<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MANavigableSet<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    @SuppressWarnings("unchecked")
    private static <E> MANavigableSet<E> locking(MANavigableSet<E> c, LockingManager lockingManager) {
        if (c instanceof Serializable) {
            return new LockingMANavigableSetWithSerializable<E>(c, lockingManager);
        }
        if (c instanceof MANavigableSet.MANavigableSetView<?>) {
            if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
                return new LockingMANavigableMapMANavigableKeySetView<E, Object>(
                    (MANavigableMap.MANavigableKeySetView<E, Object>)c, lockingManager);
            }
            return new LockingMANavigableSetMANavigableSetView<E>(
                (MANavigableSet.MANavigableSetView<E>)c, lockingManager);
        }
        return new LockingMANavigableSet<E>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(MANavigableSet.MANavigableSetView<E> lockedCollection, LockMode lockMode, Function<MANavigableSet.MANavigableSetView<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MANavigableSet.MANavigableSetView<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MANavigableSet.MANavigableSetView<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(MANavigableSet.MANavigableSetView<E> lockedCollection, LockMode lockMode, Consumer<MANavigableSet.MANavigableSetView<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MANavigableSet.MANavigableSetView<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MANavigableSet.MANavigableSetView<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    @SuppressWarnings("unchecked")
    private static <E> MANavigableSet.MANavigableSetView<E> locking(MANavigableSet.MANavigableSetView<E> c, LockingManager lockingManager) {
        if (c instanceof MANavigableMap.MANavigableKeySetView<?, ?>) {
            return new LockingMANavigableMapMANavigableKeySetView<E, Object>(
                (MANavigableMap.MANavigableKeySetView<E, Object>)c, lockingManager);
        }
        return new LockingMANavigableSetMANavigableSetView<E>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(MANavigableMap.MANavigableKeySetView<K, V> lockedCollection, LockMode lockMode, Function<MANavigableMap.MANavigableKeySetView<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MANavigableMap.MANavigableKeySetView<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MANavigableMap.MANavigableKeySetView<K, V>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(MANavigableMap.MANavigableKeySetView<K, V> lockedCollection, LockMode lockMode, Consumer<MANavigableMap.MANavigableKeySetView<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MANavigableMap.MANavigableKeySetView<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MANavigableMap.MANavigableKeySetView<K, V>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    private static <K, V> MANavigableMap.MANavigableKeySetView<K, V> locking(MANavigableMap.MANavigableKeySetView<K, V> c, LockingManager lockingManager) {
        return new LockingMANavigableMapMANavigableKeySetView<K, V>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(MAOrderedSet<E> lockedCollection, LockMode lockMode, Function<MAOrderedSet<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MAOrderedSet<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MAOrderedSet<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(MAOrderedSet<E> lockedCollection, LockMode lockMode, Consumer<MAOrderedSet<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MAOrderedSet<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MAOrderedSet<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    @SuppressWarnings("unchecked")
    private static <E> MAOrderedSet<E> locking(MAOrderedSet<E> c, LockingManager lockingManager) {
        if (c instanceof Serializable) {
            return new LockingMAOrderedSetWithSerializable<E>(c, lockingManager);
        }
        if (c instanceof MAOrderedSet.MAOrderedSetView<?>) {
            if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
                return new LockingMAOrderedMapMAOrderedKeySetView<E, Object>(
                    (MAOrderedMap.MAOrderedKeySetView<E, Object>)c, lockingManager);
            }
            return new LockingMAOrderedSetMAOrderedSetView<E>(
                (MAOrderedSet.MAOrderedSetView<E>)c, lockingManager);
        }
        return new LockingMAOrderedSet<E>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(MAOrderedSet.MAOrderedSetView<E> lockedCollection, LockMode lockMode, Function<MAOrderedSet.MAOrderedSetView<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MAOrderedSet.MAOrderedSetView<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MAOrderedSet.MAOrderedSetView<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(MAOrderedSet.MAOrderedSetView<E> lockedCollection, LockMode lockMode, Consumer<MAOrderedSet.MAOrderedSetView<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MAOrderedSet.MAOrderedSetView<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MAOrderedSet.MAOrderedSetView<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    @SuppressWarnings("unchecked")
    private static <E> MAOrderedSet.MAOrderedSetView<E> locking(MAOrderedSet.MAOrderedSetView<E> c, LockingManager lockingManager) {
        if (c instanceof MAOrderedMap.MAOrderedKeySetView<?, ?>) {
            return new LockingMAOrderedMapMAOrderedKeySetView<E, Object>(
                (MAOrderedMap.MAOrderedKeySetView<E, Object>)c, lockingManager);
        }
        return new LockingMAOrderedSetMAOrderedSetView<E>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(MAOrderedMap.MAOrderedKeySetView<K, V> lockedCollection, LockMode lockMode, Function<MAOrderedMap.MAOrderedKeySetView<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MAOrderedMap.MAOrderedKeySetView<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MAOrderedMap.MAOrderedKeySetView<K, V>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(MAOrderedMap.MAOrderedKeySetView<K, V> lockedCollection, LockMode lockMode, Consumer<MAOrderedMap.MAOrderedKeySetView<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MAOrderedMap.MAOrderedKeySetView<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MAOrderedMap.MAOrderedKeySetView<K, V>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    private static <K, V> MAOrderedMap.MAOrderedKeySetView<K, V> locking(MAOrderedMap.MAOrderedKeySetView<K, V> c, LockingManager lockingManager) {
        return new LockingMAOrderedMapMAOrderedKeySetView<K, V>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(MAList<E> lockedCollection, LockMode lockMode, Function<MAList<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MAList<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MAList<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(MAList<E> lockedCollection, LockMode lockMode, Consumer<MAList<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MAList<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MAList<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    private static <E> MAList<E> locking(MAList<E> c, LockingManager lockingManager) {
        if (c instanceof Serializable) {
            if (c instanceof RandomAccess) {
                return new LockingMAListWithSerializableRandomAccess<E>(c, lockingManager);
            }
            return new LockingMAListWithSerializable<E>(c, lockingManager);
        }
        if (c instanceof RandomAccess) {
            if (c instanceof MAList.MAListView<?>) {
                return new LockingMAListMAListViewWithRandomAccess<E>(
                    (MAList.MAListView<E>)c, lockingManager);
            }
            return new LockingMAListWithRandomAccess<E>(c, lockingManager);
        }
        if (c instanceof MAList.MAListView<?>) {
            return new LockingMAListMAListView<E>(
                (MAList.MAListView<E>)c, lockingManager);
        }
        return new LockingMAList<E>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(MAList.MAListView<E> lockedCollection, LockMode lockMode, Function<MAList.MAListView<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            return lockingFunction.apply(lockedCollection);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MAList.MAListView<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MAList.MAListView<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        return toppestProxy.locking(lockedCollection, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(MAList.MAListView<E> lockedCollection, LockMode lockMode, Consumer<MAList.MAListView<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedCollection", lockedCollection);
        if (!(lockedCollection instanceof Proxy)) {
            lockingConsumer.accept(lockedCollection);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedCollection;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedCollection = (MAList.MAListView<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedCollection = (MAList.MAListView<E>)proxy.recreate(lockedCollection);
            }
        }
        lockedCollection = locking(lockedCollection, lockingManager);
        toppestProxy.locking(lockedCollection, lockingManager.state, lockingConsumer);
    }

    private static <E> MAList.MAListView<E> locking(MAList.MAListView<E> c, LockingManager lockingManager) {
        if (c instanceof RandomAccess) {
            return new LockingMAListMAListViewWithRandomAccess<E>(c, lockingManager);
        }
        return new LockingMAListMAListView<E>(c, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(Iterator<E> lockedIterator, LockMode lockMode, Function<Iterator<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedIterator", lockedIterator);
        if (!(lockedIterator instanceof Proxy)) {
            return lockingFunction.apply(lockedIterator);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedIterator;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedIterator = (Iterator<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedIterator = (Iterator<E>)proxy.recreate(lockedIterator);
            }
        }
        lockedIterator = locking(lockedIterator, lockingManager);
        return toppestProxy.locking(lockedIterator, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(Iterator<E> lockedIterator, LockMode lockMode, Consumer<Iterator<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedIterator", lockedIterator);
        if (!(lockedIterator instanceof Proxy)) {
            lockingConsumer.accept(lockedIterator);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedIterator;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedIterator = (Iterator<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedIterator = (Iterator<E>)proxy.recreate(lockedIterator);
            }
        }
        lockedIterator = locking(lockedIterator, lockingManager);
        toppestProxy.locking(lockedIterator, lockingManager.state, lockingConsumer);
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    private static <E> Iterator<E> locking(Iterator<E> itr, LockingManager lockingManager) {
        if (itr instanceof Serializable) {
            if (itr instanceof StandardMap.EntrySet.EntryIterator<?, ?>) {
                return new LockingStandardMapEntrySetEntryIteratorWithSerializable(
                    (StandardMap.EntrySet.EntryIterator)itr, lockingManager);
            }
            if (itr instanceof ListIterator<?>) {
                return new LockingListIteratorWithSerializable<E>(
                    (ListIterator<E>)itr, lockingManager);
            }
            return new LockingIteratorWithSerializable<E>(itr, lockingManager);
        }
        if (itr instanceof XCollection.XIterator<?>) {
            if (itr instanceof MACollection.MAIterator<?>) {
                if (itr instanceof MAMap.MAValuesView.MAValuesIterator<?, ?>) {
                    return new LockingMAMapMAValuesViewMAValuesIterator<Object, E>(
                        (MAMap.MAValuesView.MAValuesIterator<Object, E>)itr, lockingManager);
                }
                if (itr instanceof MAMap.MAEntrySetView.MAEntrySetIterator<?, ?>) {
                    return new LockingMAMapMAEntrySetViewMAEntrySetIterator(
                        (MAMap.MAEntrySetView.MAEntrySetIterator)itr, lockingManager);
                }
                if (itr instanceof MAList.MAListIterator<?>) {
                    return new LockingMAListMAListIterator<E>(
                        (MAList.MAListIterator<E>)itr, lockingManager);
                }
                if (itr instanceof MAMap.MAKeySetView.MAKeySetIterator<?, ?>) {
                    return new LockingMAMapMAKeySetViewMAKeySetIterator<E, Object>(
                        (MAMap.MAKeySetView.MAKeySetIterator<E, Object>)itr, lockingManager);
                }
                return new LockingMACollectionMAIterator<E>(
                    (MACollection.MAIterator<E>)itr, lockingManager);
            }
            if (itr instanceof XList.XListIterator<?>) {
                return new LockingXListXListIterator<E>(
                    (XList.XListIterator<E>)itr, lockingManager);
            }
            if (itr instanceof XMap.XEntrySetView.XEntrySetIterator<?, ?>) {
                return new LockingXMapXEntrySetViewXEntrySetIterator(
                    (XMap.XEntrySetView.XEntrySetIterator)itr, lockingManager);
            }
            return new LockingXCollectionXIterator<E>(
                (XCollection.XIterator<E>)itr, lockingManager);
        }
        if (itr instanceof StandardMap.EntrySet.EntryIterator<?, ?>) {
            return new LockingStandardMapEntrySetEntryIterator(
                (StandardMap.EntrySet.EntryIterator)itr, lockingManager);
        }
        if (itr instanceof ListIterator<?>) {
            return new LockingListIterator<E>(
                (ListIterator<E>)itr, lockingManager);
        }
        return new LockingIterator<E>(itr, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(ListIterator<E> lockedIterator, LockMode lockMode, Function<ListIterator<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedIterator", lockedIterator);
        if (!(lockedIterator instanceof Proxy)) {
            return lockingFunction.apply(lockedIterator);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedIterator;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedIterator = (ListIterator<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedIterator = (ListIterator<E>)proxy.recreate(lockedIterator);
            }
        }
        lockedIterator = locking(lockedIterator, lockingManager);
        return toppestProxy.locking(lockedIterator, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(ListIterator<E> lockedIterator, LockMode lockMode, Consumer<ListIterator<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedIterator", lockedIterator);
        if (!(lockedIterator instanceof Proxy)) {
            lockingConsumer.accept(lockedIterator);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedIterator;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedIterator = (ListIterator<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedIterator = (ListIterator<E>)proxy.recreate(lockedIterator);
            }
        }
        lockedIterator = locking(lockedIterator, lockingManager);
        toppestProxy.locking(lockedIterator, lockingManager.state, lockingConsumer);
    }

    private static <E> ListIterator<E> locking(ListIterator<E> itr, LockingManager lockingManager) {
        if (itr instanceof Serializable) {
            return new LockingListIteratorWithSerializable<E>(itr, lockingManager);
        }
        if (itr instanceof MAList.MAListIterator<?>) {
            return new LockingMAListMAListIterator<E>(
                (MAList.MAListIterator<E>)itr, lockingManager);
        }
        if (itr instanceof XList.XListIterator<?>) {
            return new LockingXListXListIterator<E>(
                (XList.XListIterator<E>)itr, lockingManager);
        }
        return new LockingListIterator<E>(itr, lockingManager);
    }

    private static <K, V> StandardMap.EntrySet.EntryIterator<K, V> locking(StandardMap.EntrySet.EntryIterator<K, V> itr, LockingManager lockingManager) {
        if (itr instanceof Serializable) {
            return new LockingStandardMapEntrySetEntryIteratorWithSerializable<K, V>(itr, lockingManager);
        }
        return new LockingStandardMapEntrySetEntryIterator<K, V>(itr, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(XCollection.XIterator<E> lockedIterator, LockMode lockMode, Function<XCollection.XIterator<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedIterator", lockedIterator);
        if (!(lockedIterator instanceof Proxy)) {
            return lockingFunction.apply(lockedIterator);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedIterator;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedIterator = (XCollection.XIterator<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedIterator = (XCollection.XIterator<E>)proxy.recreate(lockedIterator);
            }
        }
        lockedIterator = locking(lockedIterator, lockingManager);
        return toppestProxy.locking(lockedIterator, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(XCollection.XIterator<E> lockedIterator, LockMode lockMode, Consumer<XCollection.XIterator<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedIterator", lockedIterator);
        if (!(lockedIterator instanceof Proxy)) {
            lockingConsumer.accept(lockedIterator);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedIterator;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedIterator = (XCollection.XIterator<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedIterator = (XCollection.XIterator<E>)proxy.recreate(lockedIterator);
            }
        }
        lockedIterator = locking(lockedIterator, lockingManager);
        toppestProxy.locking(lockedIterator, lockingManager.state, lockingConsumer);
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    private static <E> XCollection.XIterator<E> locking(XCollection.XIterator<E> itr, LockingManager lockingManager) {
        if (itr instanceof MACollection.MAIterator<?>) {
            if (itr instanceof MAMap.MAValuesView.MAValuesIterator<?, ?>) {
                return new LockingMAMapMAValuesViewMAValuesIterator<Object, E>(
                    (MAMap.MAValuesView.MAValuesIterator<Object, E>)itr, lockingManager);
            }
            if (itr instanceof MAMap.MAEntrySetView.MAEntrySetIterator<?, ?>) {
                return new LockingMAMapMAEntrySetViewMAEntrySetIterator(
                    (MAMap.MAEntrySetView.MAEntrySetIterator)itr, lockingManager);
            }
            if (itr instanceof MAList.MAListIterator<?>) {
                return new LockingMAListMAListIterator<E>(
                    (MAList.MAListIterator<E>)itr, lockingManager);
            }
            if (itr instanceof MAMap.MAKeySetView.MAKeySetIterator<?, ?>) {
                return new LockingMAMapMAKeySetViewMAKeySetIterator<E, Object>(
                    (MAMap.MAKeySetView.MAKeySetIterator<E, Object>)itr, lockingManager);
            }
            return new LockingMACollectionMAIterator<E>(
                (MACollection.MAIterator<E>)itr, lockingManager);
        }
        if (itr instanceof XList.XListIterator<?>) {
            return new LockingXListXListIterator<E>(
                (XList.XListIterator<E>)itr, lockingManager);
        }
        if (itr instanceof XMap.XEntrySetView.XEntrySetIterator<?, ?>) {
            return new LockingXMapXEntrySetViewXEntrySetIterator(
                (XMap.XEntrySetView.XEntrySetIterator)itr, lockingManager);
        }
        return new LockingXCollectionXIterator<E>(itr, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(XMap.XEntrySetView.XEntrySetIterator<K, V> lockedIterator, LockMode lockMode, Function<XMap.XEntrySetView.XEntrySetIterator<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedIterator", lockedIterator);
        if (!(lockedIterator instanceof Proxy)) {
            return lockingFunction.apply(lockedIterator);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedIterator;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedIterator = (XMap.XEntrySetView.XEntrySetIterator<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedIterator = (XMap.XEntrySetView.XEntrySetIterator<K, V>)proxy.recreate(lockedIterator);
            }
        }
        lockedIterator = locking(lockedIterator, lockingManager);
        return toppestProxy.locking(lockedIterator, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(XMap.XEntrySetView.XEntrySetIterator<K, V> lockedIterator, LockMode lockMode, Consumer<XMap.XEntrySetView.XEntrySetIterator<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedIterator", lockedIterator);
        if (!(lockedIterator instanceof Proxy)) {
            lockingConsumer.accept(lockedIterator);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedIterator;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedIterator = (XMap.XEntrySetView.XEntrySetIterator<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedIterator = (XMap.XEntrySetView.XEntrySetIterator<K, V>)proxy.recreate(lockedIterator);
            }
        }
        lockedIterator = locking(lockedIterator, lockingManager);
        toppestProxy.locking(lockedIterator, lockingManager.state, lockingConsumer);
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    private static <K, V> XMap.XEntrySetView.XEntrySetIterator<K, V> locking(XMap.XEntrySetView.XEntrySetIterator<K, V> itr, LockingManager lockingManager) {
        if (itr instanceof MAMap.MAEntrySetView.MAEntrySetIterator<?, ?>) {
            return new LockingMAMapMAEntrySetViewMAEntrySetIterator(
                (MAMap.MAEntrySetView.MAEntrySetIterator)itr, lockingManager);
        }
        return new LockingXMapXEntrySetViewXEntrySetIterator<K, V>(itr, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(XList.XListIterator<E> lockedIterator, LockMode lockMode, Function<XList.XListIterator<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedIterator", lockedIterator);
        if (!(lockedIterator instanceof Proxy)) {
            return lockingFunction.apply(lockedIterator);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedIterator;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedIterator = (XList.XListIterator<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedIterator = (XList.XListIterator<E>)proxy.recreate(lockedIterator);
            }
        }
        lockedIterator = locking(lockedIterator, lockingManager);
        return toppestProxy.locking(lockedIterator, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(XList.XListIterator<E> lockedIterator, LockMode lockMode, Consumer<XList.XListIterator<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedIterator", lockedIterator);
        if (!(lockedIterator instanceof Proxy)) {
            lockingConsumer.accept(lockedIterator);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedIterator;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedIterator = (XList.XListIterator<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedIterator = (XList.XListIterator<E>)proxy.recreate(lockedIterator);
            }
        }
        lockedIterator = locking(lockedIterator, lockingManager);
        toppestProxy.locking(lockedIterator, lockingManager.state, lockingConsumer);
    }

    private static <E> XList.XListIterator<E> locking(XList.XListIterator<E> itr, LockingManager lockingManager) {
        if (itr instanceof MAList.MAListIterator<?>) {
            return new LockingMAListMAListIterator<E>(
                (MAList.MAListIterator<E>)itr, lockingManager);
        }
        return new LockingXListXListIterator<E>(itr, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(MACollection.MAIterator<E> lockedIterator, LockMode lockMode, Function<MACollection.MAIterator<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedIterator", lockedIterator);
        if (!(lockedIterator instanceof Proxy)) {
            return lockingFunction.apply(lockedIterator);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedIterator;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedIterator = (MACollection.MAIterator<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedIterator = (MACollection.MAIterator<E>)proxy.recreate(lockedIterator);
            }
        }
        lockedIterator = locking(lockedIterator, lockingManager);
        return toppestProxy.locking(lockedIterator, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(MACollection.MAIterator<E> lockedIterator, LockMode lockMode, Consumer<MACollection.MAIterator<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedIterator", lockedIterator);
        if (!(lockedIterator instanceof Proxy)) {
            lockingConsumer.accept(lockedIterator);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedIterator;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedIterator = (MACollection.MAIterator<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedIterator = (MACollection.MAIterator<E>)proxy.recreate(lockedIterator);
            }
        }
        lockedIterator = locking(lockedIterator, lockingManager);
        toppestProxy.locking(lockedIterator, lockingManager.state, lockingConsumer);
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    private static <E> MACollection.MAIterator<E> locking(MACollection.MAIterator<E> itr, LockingManager lockingManager) {
        if (itr instanceof MAMap.MAValuesView.MAValuesIterator<?, ?>) {
            return new LockingMAMapMAValuesViewMAValuesIterator<Object, E>(
                (MAMap.MAValuesView.MAValuesIterator<Object, E>)itr, lockingManager);
        }
        if (itr instanceof MAMap.MAEntrySetView.MAEntrySetIterator<?, ?>) {
            return new LockingMAMapMAEntrySetViewMAEntrySetIterator(
                (MAMap.MAEntrySetView.MAEntrySetIterator)itr, lockingManager);
        }
        if (itr instanceof MAList.MAListIterator<?>) {
            return new LockingMAListMAListIterator<E>(
                (MAList.MAListIterator<E>)itr, lockingManager);
        }
        if (itr instanceof MAMap.MAKeySetView.MAKeySetIterator<?, ?>) {
            return new LockingMAMapMAKeySetViewMAKeySetIterator<E, Object>(
                (MAMap.MAKeySetView.MAKeySetIterator<E, Object>)itr, lockingManager);
        }
        return new LockingMACollectionMAIterator<E>(itr, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(MAMap.MAKeySetView.MAKeySetIterator<K, V> lockedIterator, LockMode lockMode, Function<MAMap.MAKeySetView.MAKeySetIterator<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedIterator", lockedIterator);
        if (!(lockedIterator instanceof Proxy)) {
            return lockingFunction.apply(lockedIterator);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedIterator;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedIterator = (MAMap.MAKeySetView.MAKeySetIterator<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedIterator = (MAMap.MAKeySetView.MAKeySetIterator<K, V>)proxy.recreate(lockedIterator);
            }
        }
        lockedIterator = locking(lockedIterator, lockingManager);
        return toppestProxy.locking(lockedIterator, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(MAMap.MAKeySetView.MAKeySetIterator<K, V> lockedIterator, LockMode lockMode, Consumer<MAMap.MAKeySetView.MAKeySetIterator<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedIterator", lockedIterator);
        if (!(lockedIterator instanceof Proxy)) {
            lockingConsumer.accept(lockedIterator);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedIterator;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedIterator = (MAMap.MAKeySetView.MAKeySetIterator<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedIterator = (MAMap.MAKeySetView.MAKeySetIterator<K, V>)proxy.recreate(lockedIterator);
            }
        }
        lockedIterator = locking(lockedIterator, lockingManager);
        toppestProxy.locking(lockedIterator, lockingManager.state, lockingConsumer);
    }

    private static <K, V> MAMap.MAKeySetView.MAKeySetIterator<K, V> locking(MAMap.MAKeySetView.MAKeySetIterator<K, V> itr, LockingManager lockingManager) {
        return new LockingMAMapMAKeySetViewMAKeySetIterator<K, V>(itr, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <E, R> R locking(MAList.MAListIterator<E> lockedIterator, LockMode lockMode, Function<MAList.MAListIterator<E>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedIterator", lockedIterator);
        if (!(lockedIterator instanceof Proxy)) {
            return lockingFunction.apply(lockedIterator);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedIterator;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedIterator = (MAList.MAListIterator<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedIterator = (MAList.MAListIterator<E>)proxy.recreate(lockedIterator);
            }
        }
        lockedIterator = locking(lockedIterator, lockingManager);
        return toppestProxy.locking(lockedIterator, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <E> void locking(MAList.MAListIterator<E> lockedIterator, LockMode lockMode, Consumer<MAList.MAListIterator<E>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedIterator", lockedIterator);
        if (!(lockedIterator instanceof Proxy)) {
            lockingConsumer.accept(lockedIterator);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedIterator;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedIterator = (MAList.MAListIterator<E>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedIterator = (MAList.MAListIterator<E>)proxy.recreate(lockedIterator);
            }
        }
        lockedIterator = locking(lockedIterator, lockingManager);
        toppestProxy.locking(lockedIterator, lockingManager.state, lockingConsumer);
    }

    private static <E> MAList.MAListIterator<E> locking(MAList.MAListIterator<E> itr, LockingManager lockingManager) {
        return new LockingMAListMAListIterator<E>(itr, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(MAMap.MAEntrySetView.MAEntrySetIterator<K, V> lockedIterator, LockMode lockMode, Function<MAMap.MAEntrySetView.MAEntrySetIterator<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedIterator", lockedIterator);
        if (!(lockedIterator instanceof Proxy)) {
            return lockingFunction.apply(lockedIterator);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedIterator;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedIterator = (MAMap.MAEntrySetView.MAEntrySetIterator<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedIterator = (MAMap.MAEntrySetView.MAEntrySetIterator<K, V>)proxy.recreate(lockedIterator);
            }
        }
        lockedIterator = locking(lockedIterator, lockingManager);
        return toppestProxy.locking(lockedIterator, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(MAMap.MAEntrySetView.MAEntrySetIterator<K, V> lockedIterator, LockMode lockMode, Consumer<MAMap.MAEntrySetView.MAEntrySetIterator<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedIterator", lockedIterator);
        if (!(lockedIterator instanceof Proxy)) {
            lockingConsumer.accept(lockedIterator);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedIterator;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedIterator = (MAMap.MAEntrySetView.MAEntrySetIterator<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedIterator = (MAMap.MAEntrySetView.MAEntrySetIterator<K, V>)proxy.recreate(lockedIterator);
            }
        }
        lockedIterator = locking(lockedIterator, lockingManager);
        toppestProxy.locking(lockedIterator, lockingManager.state, lockingConsumer);
    }

    private static <K, V> MAMap.MAEntrySetView.MAEntrySetIterator<K, V> locking(MAMap.MAEntrySetView.MAEntrySetIterator<K, V> itr, LockingManager lockingManager) {
        return new LockingMAMapMAEntrySetViewMAEntrySetIterator<K, V>(itr, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(MAMap.MAValuesView.MAValuesIterator<K, V> lockedIterator, LockMode lockMode, Function<MAMap.MAValuesView.MAValuesIterator<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedIterator", lockedIterator);
        if (!(lockedIterator instanceof Proxy)) {
            return lockingFunction.apply(lockedIterator);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedIterator;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedIterator = (MAMap.MAValuesView.MAValuesIterator<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedIterator = (MAMap.MAValuesView.MAValuesIterator<K, V>)proxy.recreate(lockedIterator);
            }
        }
        lockedIterator = locking(lockedIterator, lockingManager);
        return toppestProxy.locking(lockedIterator, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(MAMap.MAValuesView.MAValuesIterator<K, V> lockedIterator, LockMode lockMode, Consumer<MAMap.MAValuesView.MAValuesIterator<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedIterator", lockedIterator);
        if (!(lockedIterator instanceof Proxy)) {
            lockingConsumer.accept(lockedIterator);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedIterator;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedIterator = (MAMap.MAValuesView.MAValuesIterator<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedIterator = (MAMap.MAValuesView.MAValuesIterator<K, V>)proxy.recreate(lockedIterator);
            }
        }
        lockedIterator = locking(lockedIterator, lockingManager);
        toppestProxy.locking(lockedIterator, lockingManager.state, lockingConsumer);
    }

    private static <K, V> MAMap.MAValuesView.MAValuesIterator<K, V> locking(MAMap.MAValuesView.MAValuesIterator<K, V> itr, LockingManager lockingManager) {
        return new LockingMAMapMAValuesViewMAValuesIterator<K, V>(itr, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(Map.Entry<K, V> lockedEntry, LockMode lockMode, Function<Map.Entry<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedEntry", lockedEntry);
        if (!(lockedEntry instanceof Proxy)) {
            return lockingFunction.apply(lockedEntry);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedEntry;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedEntry = (Map.Entry<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedEntry = (Map.Entry<K, V>)proxy.recreate(lockedEntry);
            }
        }
        lockedEntry = locking(lockedEntry, lockingManager);
        return toppestProxy.locking(lockedEntry, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(Map.Entry<K, V> lockedEntry, LockMode lockMode, Consumer<Map.Entry<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedEntry", lockedEntry);
        if (!(lockedEntry instanceof Proxy)) {
            lockingConsumer.accept(lockedEntry);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedEntry;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedEntry = (Map.Entry<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedEntry = (Map.Entry<K, V>)proxy.recreate(lockedEntry);
            }
        }
        lockedEntry = locking(lockedEntry, lockingManager);
        toppestProxy.locking(lockedEntry, lockingManager.state, lockingConsumer);
    }

    private static <K, V> Map.Entry<K, V> locking(Map.Entry<K, V> e, LockingManager lockingManager) {
        if (e instanceof Serializable) {
            return new LockingMapEntryWithSerializable<K, V>(e, lockingManager);
        }
        if (e instanceof XMap.XEntry<?, ?>) {
            if (e instanceof MAMap.MAEntry<?, ?>) {
                return new LockingMAMapMAEntry<K, V>(
                    (MAMap.MAEntry<K, V>)e, lockingManager);
            }
            return new LockingXMapXEntry<K, V>(
                (XMap.XEntry<K, V>)e, lockingManager);
        }
        return new LockingMapEntry<K, V>(e, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(XMap.XEntry<K, V> lockedEntry, LockMode lockMode, Function<XMap.XEntry<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedEntry", lockedEntry);
        if (!(lockedEntry instanceof Proxy)) {
            return lockingFunction.apply(lockedEntry);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedEntry;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedEntry = (XMap.XEntry<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedEntry = (XMap.XEntry<K, V>)proxy.recreate(lockedEntry);
            }
        }
        lockedEntry = locking(lockedEntry, lockingManager);
        return toppestProxy.locking(lockedEntry, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(XMap.XEntry<K, V> lockedEntry, LockMode lockMode, Consumer<XMap.XEntry<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedEntry", lockedEntry);
        if (!(lockedEntry instanceof Proxy)) {
            lockingConsumer.accept(lockedEntry);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedEntry;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedEntry = (XMap.XEntry<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedEntry = (XMap.XEntry<K, V>)proxy.recreate(lockedEntry);
            }
        }
        lockedEntry = locking(lockedEntry, lockingManager);
        toppestProxy.locking(lockedEntry, lockingManager.state, lockingConsumer);
    }

    private static <K, V> XMap.XEntry<K, V> locking(XMap.XEntry<K, V> e, LockingManager lockingManager) {
        if (e instanceof MAMap.MAEntry<?, ?>) {
            return new LockingMAMapMAEntry<K, V>(
                (MAMap.MAEntry<K, V>)e, lockingManager);
        }
        return new LockingXMapXEntry<K, V>(e, lockingManager);
    }

    @SuppressWarnings("unchecked")
    public static <K, V, R> R locking(MAMap.MAEntry<K, V> lockedEntry, LockMode lockMode, Function<MAMap.MAEntry<K, V>, R> lockingFunction) {
        Arguments.mustNotBeNull("lockedEntry", lockedEntry);
        if (!(lockedEntry instanceof Proxy)) {
            return lockingFunction.apply(lockedEntry);
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedEntry;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedEntry = (MAMap.MAEntry<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedEntry = (MAMap.MAEntry<K, V>)proxy.recreate(lockedEntry);
            }
        }
        lockedEntry = locking(lockedEntry, lockingManager);
        return toppestProxy.locking(lockedEntry, lockingManager.state, lockingFunction);
    }

    @SuppressWarnings("unchecked")
    public static <K, V> void locking(MAMap.MAEntry<K, V> lockedEntry, LockMode lockMode, Consumer<MAMap.MAEntry<K, V>> lockingConsumer) {
        Arguments.mustNotBeNull("lockedEntry", lockedEntry);
        if (!(lockedEntry instanceof Proxy)) {
            lockingConsumer.accept(lockedEntry);
            return;
        }
        LockingManager lockingManager = new LockingManager(lockMode);
        Proxy toppestProxy = (Proxy)lockedEntry;
        Proxy[] proxies = toppestProxy.getProxies();
        lockedEntry = (MAMap.MAEntry<K, V>)toppestProxy.getRealObject();
        for (Proxy proxy : proxies) {
            if (!(proxy instanceof LockedProxy)) {
                lockedEntry = (MAMap.MAEntry<K, V>)proxy.recreate(lockedEntry);
            }
        }
        lockedEntry = locking(lockedEntry, lockingManager);
        toppestProxy.locking(lockedEntry, lockingManager.state, lockingConsumer);
    }

    private static <K, V> MAMap.MAEntry<K, V> locking(MAMap.MAEntry<K, V> e, LockingManager lockingManager) {
        return new LockingMAMapMAEntry<K, V>(e, lockingManager);
    }

    private static class UnmodifiableMAOrderedMapMAOrderedMapView<K, V> extends UnmodifiableMAOrderedMap<K, V> implements MAOrderedMap.MAOrderedMapView<K, V> {

        UnmodifiableMAOrderedMapMAOrderedMapView(MAOrderedMap.MAOrderedMapView<K, V> m) {
            super(m);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMAOrderedMapMAOrderedMapView<K, V>((MAOrderedMap.MAOrderedMapView<K, V>)obj);
        }

        @Override
        public ViewInfo viewInfo() {
            return ((MAOrderedMap.MAOrderedMapView<K, V>)this.m).viewInfo();
        }
    }

    private static class UnmodifiableMAOrderedMap<K, V> extends UnmodifiableMAMap<K, V> implements MAOrderedMap<K, V> {

        UnmodifiableMAOrderedMap(MAOrderedMap<K, V> m) {
            super(m);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        UnmodifiableMAOrderedMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMAOrderedMap<K, V>((MAOrderedMap<K, V>)obj);
        }

        @Override
        public Map.Entry<K, V> pollLastEntry() {
            throw new UnsupportedOperationException(
                unmodifable("java.util.Map.Entry<K, V> org.babyfish.collection.XOrderedMap<K, V>.pollLastEntry()")
            );
        }

        @Override
        public Map.Entry<K, V> pollFirstEntry() {
            throw new UnsupportedOperationException(
                unmodifable("java.util.Map.Entry<K, V> org.babyfish.collection.XOrderedMap<K, V>.pollFirstEntry()")
            );
        }

        @Override
        public K firstKey() {
            return ((MAOrderedMap<K, V>)this.m).firstKey();
        }

        @Override
        public MAOrderedMap.MAOrderedKeySetView<K, V> descendingKeySet() {
             return MACollections.unmodifiable(((MAOrderedMap<K, V>)this.m).descendingKeySet());
        }

        @Override
        public MAOrderedMap.MAOrderedMapView<K, V> descendingMap() {
             return MACollections.unmodifiable(((MAOrderedMap<K, V>)this.m).descendingMap());
        }

        @Override
        public MAOrderedMap.MAOrderedKeySetView<K, V> keySet() {
             return MACollections.unmodifiable(((MAOrderedMap<K, V>)this.m).keySet());
        }

        @Override
        public OrderAdjustMode replaceMode() {
            return ((MAOrderedMap<K, V>)this.m).replaceMode();
        }

        @Override
        public MAMap.MAEntry<K, V> firstEntry() {
             return MACollections.unmodifiable(((MAOrderedMap<K, V>)this.m).firstEntry());
        }

        @Override
        public K lastKey() {
            return ((MAOrderedMap<K, V>)this.m).lastKey();
        }

        @Override
        public MAMap.MAEntry<K, V> lastEntry() {
             return MACollections.unmodifiable(((MAOrderedMap<K, V>)this.m).lastEntry());
        }

        @Override
        public V access(K key) {
            throw new UnsupportedOperationException(
                unmodifable("V org.babyfish.collection.XOrderedMap<K, V>.access(K)")
            );
        }

        @Override
        public OrderAdjustMode accessMode() {
            return ((MAOrderedMap<K, V>)this.m).accessMode();
        }

        @Override
        public boolean headAppend() {
            return ((MAOrderedMap<K, V>)this.m).headAppend();
        }
    }

    private static class UnmodifiableMAOrderedMapWithSerializable<K, V> extends UnmodifiableMAOrderedMap<K, V> implements Serializable {

        private static final long serialVersionUID = -5884867910987256181L;

        UnmodifiableMAOrderedMapWithSerializable(MAOrderedMap<K, V> m) {
            super(m);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMAOrderedMapWithSerializable<K, V>((MAOrderedMap<K, V>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (MAOrderedMap<K, V>)in.readObject();
        }
    }

    private static class UnmodifiableMANavigableMapMANavigableMapView<K, V> extends UnmodifiableMANavigableMap<K, V> implements MANavigableMap.MANavigableMapView<K, V> {

        UnmodifiableMANavigableMapMANavigableMapView(MANavigableMap.MANavigableMapView<K, V> m) {
            super(m);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMANavigableMapMANavigableMapView<K, V>((MANavigableMap.MANavigableMapView<K, V>)obj);
        }

        @Override
        public ViewInfo viewInfo() {
            return ((MANavigableMap.MANavigableMapView<K, V>)this.m).viewInfo();
        }
    }

    private static class UnmodifiableMANavigableMap<K, V> extends UnmodifiableMASortedMap<K, V> implements MANavigableMap<K, V> {

        UnmodifiableMANavigableMap(MANavigableMap<K, V> m) {
            super(m);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        UnmodifiableMANavigableMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMANavigableMap<K, V>((MANavigableMap<K, V>)obj);
        }

        @Override
        public MANavigableMap.MANavigableKeySetView<K, V> descendingKeySet() {
             return MACollections.unmodifiable(((MANavigableMap<K, V>)this.m).descendingKeySet());
        }

        @Override
        public MAMap.MAEntry<K, V> lowerEntry(K key) {
             return MACollections.unmodifiable(((MANavigableMap<K, V>)this.m).lowerEntry(key));
        }

        @Override
        public MANavigableMap.MANavigableKeySetView<K, V> navigableKeySet() {
             return MACollections.unmodifiable(((MANavigableMap<K, V>)this.m).navigableKeySet());
        }

        @Override
        public K ceilingKey(K key) {
            return ((MANavigableMap<K, V>)this.m).ceilingKey(key);
        }

        @Override
        public MANavigableMap.MANavigableMapView<K, V> headMap(K toKey, boolean inclusive) {
             return MACollections.unmodifiable(((MANavigableMap<K, V>)this.m).headMap(toKey, inclusive));
        }

        @Override
        public MANavigableMap.MANavigableMapView<K, V> descendingMap() {
             return MACollections.unmodifiable(((MANavigableMap<K, V>)this.m).descendingMap());
        }

        @Override
        public K higherKey(K key) {
            return ((MANavigableMap<K, V>)this.m).higherKey(key);
        }

        @Override
        public MANavigableMap.MANavigableKeySetView<K, V> keySet() {
             return MACollections.unmodifiable(((MANavigableMap<K, V>)this.m).keySet());
        }

        @Override
        public Map.Entry<K, V> pollLastEntry() {
            throw new UnsupportedOperationException(
                unmodifable("java.util.Map.Entry<K, V> java.util.NavigableMap<K, V>.pollLastEntry()")
            );
        }

        @Override
        public Map.Entry<K, V> pollFirstEntry() {
            throw new UnsupportedOperationException(
                unmodifable("java.util.Map.Entry<K, V> java.util.NavigableMap<K, V>.pollFirstEntry()")
            );
        }

        @Override
        public MANavigableMap.MANavigableMapView<K, V> tailMap(K fromKey, boolean inclusive) {
             return MACollections.unmodifiable(((MANavigableMap<K, V>)this.m).tailMap(fromKey, inclusive));
        }

        @Override
        public MAMap.MAEntry<K, V> floorEntry(K key) {
             return MACollections.unmodifiable(((MANavigableMap<K, V>)this.m).floorEntry(key));
        }

        @Override
        public K lowerKey(K key) {
            return ((MANavigableMap<K, V>)this.m).lowerKey(key);
        }

        @Override
        public MAMap.MAEntry<K, V> ceilingEntry(K key) {
             return MACollections.unmodifiable(((MANavigableMap<K, V>)this.m).ceilingEntry(key));
        }

        @Override
        public MAMap.MAEntry<K, V> firstEntry() {
             return MACollections.unmodifiable(((MANavigableMap<K, V>)this.m).firstEntry());
        }

        @Override
        public MANavigableMap.MANavigableMapView<K, V> subMap(K fromKey, K toKey) {
             return MACollections.unmodifiable(((MANavigableMap<K, V>)this.m).subMap(fromKey, toKey));
        }

        @Override
        public MAMap.MAEntry<K, V> higherEntry(K key) {
             return MACollections.unmodifiable(((MANavigableMap<K, V>)this.m).higherEntry(key));
        }

        @Override
        public MAMap.MAEntry<K, V> lastEntry() {
             return MACollections.unmodifiable(((MANavigableMap<K, V>)this.m).lastEntry());
        }

        @Override
        public MANavigableMap.MANavigableMapView<K, V> headMap(K toKey) {
             return MACollections.unmodifiable(((MANavigableMap<K, V>)this.m).headMap(toKey));
        }

        @Override
        public MANavigableMap.MANavigableMapView<K, V> subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) {
             return MACollections.unmodifiable(((MANavigableMap<K, V>)this.m).subMap(fromKey, fromInclusive, toKey, toInclusive));
        }

        @Override
        public MANavigableMap.MANavigableMapView<K, V> tailMap(K fromKey) {
             return MACollections.unmodifiable(((MANavigableMap<K, V>)this.m).tailMap(fromKey));
        }

        @Override
        public K floorKey(K key) {
            return ((MANavigableMap<K, V>)this.m).floorKey(key);
        }
    }

    private static class UnmodifiableMANavigableMapWithSerializable<K, V> extends UnmodifiableMANavigableMap<K, V> implements Serializable {

        private static final long serialVersionUID = -1603939299L;

        UnmodifiableMANavigableMapWithSerializable(MANavigableMap<K, V> m) {
            super(m);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMANavigableMapWithSerializable<K, V>((MANavigableMap<K, V>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (MANavigableMap<K, V>)in.readObject();
        }
    }

    private static class UnmodifiableMASortedMapMASortedMapView<K, V> extends UnmodifiableMASortedMap<K, V> implements MASortedMap.MASortedMapView<K, V> {

        UnmodifiableMASortedMapMASortedMapView(MASortedMap.MASortedMapView<K, V> m) {
            super(m);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMASortedMapMASortedMapView<K, V>((MASortedMap.MASortedMapView<K, V>)obj);
        }

        @Override
        public ViewInfo viewInfo() {
            return ((MASortedMap.MASortedMapView<K, V>)this.m).viewInfo();
        }
    }

    private static class UnmodifiableMASortedMap<K, V> extends UnmodifiableMAMap<K, V> implements MASortedMap<K, V> {

        UnmodifiableMASortedMap(MASortedMap<K, V> m) {
            super(m);
        }

        @Deprecated //Only for deserialization
        UnmodifiableMASortedMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMASortedMap<K, V>((MASortedMap<K, V>)obj);
        }

        @Override
        public MASortedMap.MASortedMapView<K, V> subMap(K fromKey, K toKey) {
             return MACollections.unmodifiable(((MASortedMap<K, V>)this.m).subMap(fromKey, toKey));
        }

        @Override
        public K firstKey() {
            return ((MASortedMap<K, V>)this.m).firstKey();
        }

        @Override
        public MASortedMap.MASortedMapView<K, V> headMap(K toKey) {
             return MACollections.unmodifiable(((MASortedMap<K, V>)this.m).headMap(toKey));
        }

        @Override
        public K lastKey() {
            return ((MASortedMap<K, V>)this.m).lastKey();
        }

        @Override
        public MASortedMap.MASortedKeySetView<K, V> keySet() {
             return MACollections.unmodifiable(((MASortedMap<K, V>)this.m).keySet());
        }

        @Override
        public MASortedMap.MASortedMapView<K, V> tailMap(K fromKey) {
             return MACollections.unmodifiable(((MASortedMap<K, V>)this.m).tailMap(fromKey));
        }

        @Override
        public Comparator<? super K> comparator() {
            return ((MASortedMap<K, V>)this.m).comparator();
        }
    }

    private static class UnmodifiableMASortedMapWithSerializable<K, V> extends UnmodifiableMASortedMap<K, V> implements Serializable {

        private static final long serialVersionUID = -503772615L;

        UnmodifiableMASortedMapWithSerializable(MASortedMap<K, V> m) {
            super(m);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMASortedMapWithSerializable<K, V>((MASortedMap<K, V>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (MASortedMap<K, V>)in.readObject();
        }
    }

    private static class UnmodifiableMAMap<K, V> extends UnmodifiableXMap<K, V> implements MAMap<K, V> {

        UnmodifiableMAMap(MAMap<K, V> m) {
            super(m);
        }

        @Deprecated //Only for deserialization
        UnmodifiableMAMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMAMap<K, V>((MAMap<K, V>)obj);
        }

        @Override
        public void addMapElementListener(MapElementListener<? super K, ? super V> listener) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.MAMap<K, V>.addMapElementListener(org.babyfish.collection.event.MapElementListener<? super K, ? super V>)")
            );
        }

        @Override
        public MAMap.MAEntry<K, V> entryOfKey(K key) {
             return MACollections.unmodifiable(((MAMap<K, V>)this.m).entryOfKey(key));
        }
        
        @Override
        public MAMap.MAEntry<K, V> entryOfValue(V value) {
             return MACollections.unmodifiable(((MAMap<K, V>)this.m).entryOfValue(value));
        }

        @Override
        public void removeMapElementListener(MapElementListener<? super K, ? super V> listener) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.MAMap<K, V>.removeMapElementListener(org.babyfish.collection.event.MapElementListener<? super K, ? super V>)")
            );
        }

        @Override
        public MAMap.MAValuesView<K, V> values() {
             return MACollections.unmodifiable(((MAMap<K, V>)this.m).values());
        }

        @Override
        public MAMap.MAKeySetView<K, V> keySet() {
             return MACollections.unmodifiable(((MAMap<K, V>)this.m).keySet());
        }

        @Override
        public MAMap.MAEntrySetView<K, V> entrySet() {
             return MACollections.unmodifiable(((MAMap<K, V>)this.m).entrySet());
        }
    }

    private static class UnmodifiableMAMapWithSerializable<K, V> extends UnmodifiableMAMap<K, V> implements Serializable {

        private static final long serialVersionUID = -7162426570992166986L;

        UnmodifiableMAMapWithSerializable(MAMap<K, V> m) {
            super(m);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMAMapWithSerializable<K, V>((MAMap<K, V>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (MAMap<K, V>)in.readObject();
        }
    }

    private static class UnmodifiableXOrderedMapXOrderedMapView<K, V> extends UnmodifiableXOrderedMap<K, V> implements XOrderedMap.XOrderedMapView<K, V> {

        UnmodifiableXOrderedMapXOrderedMapView(XOrderedMap.XOrderedMapView<K, V> m) {
            super(m);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXOrderedMapXOrderedMapView<K, V>((XOrderedMap.XOrderedMapView<K, V>)obj);
        }

        @Override
        public ViewInfo viewInfo() {
            return ((XOrderedMap.XOrderedMapView<K, V>)this.m).viewInfo();
        }
    }

    private static class UnmodifiableXOrderedMap<K, V> extends UnmodifiableXMap<K, V> implements XOrderedMap<K, V> {

        UnmodifiableXOrderedMap(XOrderedMap<K, V> m) {
            super(m);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        UnmodifiableXOrderedMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXOrderedMap<K, V>((XOrderedMap<K, V>)obj);
        }

        @Override
        public XOrderedMap.XOrderedMapView<K, V> descendingMap() {
             return MACollections.unmodifiable(((XOrderedMap<K, V>)this.m).descendingMap());
        }

        @Override
        public V access(K key) {
            throw new UnsupportedOperationException(
                unmodifable("V org.babyfish.collection.XOrderedMap<K, V>.access(K)")
            );
        }

        @Override
        public Map.Entry<K, V> pollLastEntry() {
            throw new UnsupportedOperationException(
                unmodifable("java.util.Map.Entry<K, V> org.babyfish.collection.XOrderedMap<K, V>.pollLastEntry()")
            );
        }

        @Override
        public Map.Entry<K, V> pollFirstEntry() {
            throw new UnsupportedOperationException(
                unmodifable("java.util.Map.Entry<K, V> org.babyfish.collection.XOrderedMap<K, V>.pollFirstEntry()")
            );
        }

        @Override
        public XMap.XEntry<K, V> firstEntry() {
             return MACollections.unmodifiable(((XOrderedMap<K, V>)this.m).firstEntry());
        }

        @Override
        public K firstKey() {
            return ((XOrderedMap<K, V>)this.m).firstKey();
        }

        @Override
        public XOrderedMap.XOrderedKeySetView<K> keySet() {
             return MACollections.unmodifiable(((XOrderedMap<K, V>)this.m).keySet());
        }

        @Override
        public OrderAdjustMode accessMode() {
            return ((XOrderedMap<K, V>)this.m).accessMode();
        }

        @Override
        public OrderAdjustMode replaceMode() {
            return ((XOrderedMap<K, V>)this.m).replaceMode();
        }

        @Override
        public XOrderedMap.XOrderedKeySetView<K> descendingKeySet() {
             return MACollections.unmodifiable(((XOrderedMap<K, V>)this.m).descendingKeySet());
        }

        @Override
        public boolean headAppend() {
            return ((XOrderedMap<K, V>)this.m).headAppend();
        }

        @Override
        public XMap.XEntry<K, V> lastEntry() {
             return MACollections.unmodifiable(((XOrderedMap<K, V>)this.m).lastEntry());
        }

        @Override
        public K lastKey() {
            return ((XOrderedMap<K, V>)this.m).lastKey();
        }
    }

    private static class UnmodifiableXOrderedMapWithSerializable<K, V> extends UnmodifiableXOrderedMap<K, V> implements Serializable {

        private static final long serialVersionUID = -1338029259L;

        UnmodifiableXOrderedMapWithSerializable(XOrderedMap<K, V> m) {
            super(m);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXOrderedMapWithSerializable<K, V>((XOrderedMap<K, V>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (XOrderedMap<K, V>)in.readObject();
        }
    }

    private static class UnmodifiableXNavigableMapXNavigableMapView<K, V> extends UnmodifiableXNavigableMap<K, V> implements XNavigableMap.XNavigableMapView<K, V> {

        UnmodifiableXNavigableMapXNavigableMapView(XNavigableMap.XNavigableMapView<K, V> m) {
            super(m);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXNavigableMapXNavigableMapView<K, V>((XNavigableMap.XNavigableMapView<K, V>)obj);
        }

        @Override
        public ViewInfo viewInfo() {
            return ((XNavigableMap.XNavigableMapView<K, V>)this.m).viewInfo();
        }
    }

    private static class UnmodifiableXNavigableMap<K, V> extends UnmodifiableXSortedMap<K, V> implements XNavigableMap<K, V> {

        UnmodifiableXNavigableMap(XNavigableMap<K, V> m) {
            super(m);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        UnmodifiableXNavigableMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXNavigableMap<K, V>((XNavigableMap<K, V>)obj);
        }

        @Override
        public XNavigableMap.XNavigableKeySetView<K> descendingKeySet() {
             return MACollections.unmodifiable(((XNavigableMap<K, V>)this.m).descendingKeySet());
        }

        @Override
        public Map.Entry<K, V> pollLastEntry() {
            throw new UnsupportedOperationException(
                unmodifable("java.util.Map.Entry<K, V> java.util.NavigableMap<K, V>.pollLastEntry()")
            );
        }

        @Override
        public Map.Entry<K, V> pollFirstEntry() {
            throw new UnsupportedOperationException(
                unmodifable("java.util.Map.Entry<K, V> java.util.NavigableMap<K, V>.pollFirstEntry()")
            );
        }

        @Override
        public XMap.XEntry<K, V> firstEntry() {
             return MACollections.unmodifiable(((XNavigableMap<K, V>)this.m).firstEntry());
        }

        @Override
        public XMap.XEntry<K, V> ceilingEntry(K key) {
             return MACollections.unmodifiable(((XNavigableMap<K, V>)this.m).ceilingEntry(key));
        }

        @Override
        public K lowerKey(K key) {
            return ((XNavigableMap<K, V>)this.m).lowerKey(key);
        }

        @Override
        public XNavigableMap.XNavigableMapView<K, V> headMap(K toKey) {
             return MACollections.unmodifiable(((XNavigableMap<K, V>)this.m).headMap(toKey));
        }

        @Override
        public XNavigableMap.XNavigableMapView<K, V> descendingMap() {
             return MACollections.unmodifiable(((XNavigableMap<K, V>)this.m).descendingMap());
        }

        @Override
        public XNavigableMap.XNavigableMapView<K, V> tailMap(K fromKey, boolean inclusive) {
             return MACollections.unmodifiable(((XNavigableMap<K, V>)this.m).tailMap(fromKey, inclusive));
        }

        @Override
        public XNavigableMap.XNavigableMapView<K, V> subMap(K fromKey, K toKey) {
             return MACollections.unmodifiable(((XNavigableMap<K, V>)this.m).subMap(fromKey, toKey));
        }

        @Override
        public K ceilingKey(K key) {
            return ((XNavigableMap<K, V>)this.m).ceilingKey(key);
        }

        @Override
        public XMap.XEntry<K, V> lowerEntry(K key) {
             return MACollections.unmodifiable(((XNavigableMap<K, V>)this.m).lowerEntry(key));
        }

        @Override
        public XMap.XEntry<K, V> floorEntry(K key) {
             return MACollections.unmodifiable(((XNavigableMap<K, V>)this.m).floorEntry(key));
        }

        @Override
        public XNavigableMap.XNavigableKeySetView<K> navigableKeySet() {
             return MACollections.unmodifiable(((XNavigableMap<K, V>)this.m).navigableKeySet());
        }

        @Override
        public XMap.XEntry<K, V> higherEntry(K key) {
             return MACollections.unmodifiable(((XNavigableMap<K, V>)this.m).higherEntry(key));
        }

        @Override
        public XNavigableMap.XNavigableMapView<K, V> subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) {
             return MACollections.unmodifiable(((XNavigableMap<K, V>)this.m).subMap(fromKey, fromInclusive, toKey, toInclusive));
        }

        @Override
        public K floorKey(K key) {
            return ((XNavigableMap<K, V>)this.m).floorKey(key);
        }

        @Override
        public XNavigableMap.XNavigableKeySetView<K> keySet() {
             return MACollections.unmodifiable(((XNavigableMap<K, V>)this.m).keySet());
        }

        @Override
        public K higherKey(K key) {
            return ((XNavigableMap<K, V>)this.m).higherKey(key);
        }

        @Override
        public XNavigableMap.XNavigableMapView<K, V> tailMap(K fromKey) {
             return MACollections.unmodifiable(((XNavigableMap<K, V>)this.m).tailMap(fromKey));
        }

        @Override
        public XNavigableMap.XNavigableMapView<K, V> headMap(K toKey, boolean inclusive) {
             return MACollections.unmodifiable(((XNavigableMap<K, V>)this.m).headMap(toKey, inclusive));
        }

        @Override
        public XMap.XEntry<K, V> lastEntry() {
             return MACollections.unmodifiable(((XNavigableMap<K, V>)this.m).lastEntry());
        }
    }

    private static class UnmodifiableXNavigableMapWithSerializable<K, V> extends UnmodifiableXNavigableMap<K, V> implements Serializable {

        private static final long serialVersionUID = -1654772153L;

        UnmodifiableXNavigableMapWithSerializable(XNavigableMap<K, V> m) {
            super(m);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXNavigableMapWithSerializable<K, V>((XNavigableMap<K, V>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (XNavigableMap<K, V>)in.readObject();
        }
    }

    private static class UnmodifiableXSortedMapXSortedMapView<K, V> extends UnmodifiableXSortedMap<K, V> implements XSortedMap.XSortedMapView<K, V> {

        UnmodifiableXSortedMapXSortedMapView(XSortedMap.XSortedMapView<K, V> m) {
            super(m);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXSortedMapXSortedMapView<K, V>((XSortedMap.XSortedMapView<K, V>)obj);
        }

        @Override
        public ViewInfo viewInfo() {
            return ((XSortedMap.XSortedMapView<K, V>)this.m).viewInfo();
        }
    }

    private static class UnmodifiableXSortedMap<K, V> extends UnmodifiableXMap<K, V> implements XSortedMap<K, V> {

        UnmodifiableXSortedMap(XSortedMap<K, V> m) {
            super(m);
        }

        @Deprecated //Only for deserialization
        UnmodifiableXSortedMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXSortedMap<K, V>((XSortedMap<K, V>)obj);
        }

        @Override
        public K firstKey() {
            return ((XSortedMap<K, V>)this.m).firstKey();
        }

        @Override
        public XSortedMap.XSortedKeySetView<K> keySet() {
             return MACollections.unmodifiable(((XSortedMap<K, V>)this.m).keySet());
        }

        @Override
        public XSortedMap.XSortedMapView<K, V> headMap(K toKey) {
             return MACollections.unmodifiable(((XSortedMap<K, V>)this.m).headMap(toKey));
        }

        @Override
        public XSortedMap.XSortedMapView<K, V> subMap(K fromKey, K toKey) {
             return MACollections.unmodifiable(((XSortedMap<K, V>)this.m).subMap(fromKey, toKey));
        }

        @Override
        public XSortedMap.XSortedMapView<K, V> tailMap(K fromKey) {
             return MACollections.unmodifiable(((XSortedMap<K, V>)this.m).tailMap(fromKey));
        }

        @Override
        public Comparator<? super K> comparator() {
            return ((XSortedMap<K, V>)this.m).comparator();
        }

        @Override
        public K lastKey() {
            return ((XSortedMap<K, V>)this.m).lastKey();
        }
    }

    private static class UnmodifiableXSortedMapWithSerializable<K, V> extends UnmodifiableXSortedMap<K, V> implements Serializable {

        private static final long serialVersionUID = -1858539441L;

        UnmodifiableXSortedMapWithSerializable(XSortedMap<K, V> m) {
            super(m);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXSortedMapWithSerializable<K, V>((XSortedMap<K, V>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (XSortedMap<K, V>)in.readObject();
        }
    }

    private static class UnmodifiableXMap<K, V> extends UnmodifiableMap<K, V> implements XMap<K, V> {

        UnmodifiableXMap(XMap<K, V> m) {
            super(m);
        }

        @Deprecated //Only for deserialization
        UnmodifiableXMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXMap<K, V>((XMap<K, V>)obj);
        }

        @Override
        public void addValueValidator(Validator<V> validator) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.XMap<K, V>.addValueValidator(org.babyfish.validator.Validator<V>)")
            );
        }

        @Override
        public ReplacementRule keyReplacementRule() {
            return ((XMap<K, V>)this.m).keyReplacementRule();
        }

        @Override
        public UnifiedComparator<? super V> valueUnifiedComparator() {
            return ((XMap<K, V>)this.m).valueUnifiedComparator();
        }

        @Override
        public void removeValueValidator(Validator<V> validator) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.XMap<K, V>.removeValueValidator(org.babyfish.validator.Validator<V>)")
            );
        }

        @Override
        public boolean isReadWriteLockSupported() {
            return ((XMap<K, V>)this.m).isReadWriteLockSupported();
        }

        @Override
        public void addKeyValidator(Validator<K> validator) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.XMap<K, V>.addKeyValidator(org.babyfish.validator.Validator<K>)")
            );
        }

        @Override
        public UnifiedComparator<? super Map.Entry<K, V>> entryUnifiedComparator() {
            return ((XMap<K, V>)this.m).entryUnifiedComparator();
        }

        @Override
        public void removeKeyValidator(Validator<K> validator) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.XMap<K, V>.removeKeyValidator(org.babyfish.validator.Validator<K>)")
            );
        }

        @Override
        public XMap.XKeySetView<K> keySet() {
             return MACollections.unmodifiable(((XMap<K, V>)this.m).keySet());
        }

        @Override
        public BidiType bidiType() {
            return ((XMap<K, V>)this.m).bidiType();
        }

        @Override
        public XEntry<K, V> entryOfValue(V value) {
            return ((XMap<K, V>)this.m).entryOfValue(value);
        }

        @Override
        public XMap.XValuesView<V> values() {
             return MACollections.unmodifiable(((XMap<K, V>)this.m).values());
        }

        @Override
        public XMap.XEntrySetView<K, V> entrySet() {
             return MACollections.unmodifiable(((XMap<K, V>)this.m).entrySet());
        }

        @Override
        public UnifiedComparator<? super K> keyUnifiedComparator() {
            return ((XMap<K, V>)this.m).keyUnifiedComparator();
        }

        @Override
        public XMap.XEntry<K, V> entryOfKey(K key) {
             return MACollections.unmodifiable(((XMap<K, V>)this.m).entryOfKey(key));
        }

        @Override
        public void validateKey(K key) {
            ((XMap<K, V>)this.m).validateKey(key);
        }

        @Override
        public void validateValue(V value) {
            ((XMap<K, V>)this.m).validateValue(value);
        }
    }

    private static class UnmodifiableXMapWithSerializable<K, V> extends UnmodifiableXMap<K, V> implements Serializable {

        private static final long serialVersionUID = -662370740L;

        UnmodifiableXMapWithSerializable(XMap<K, V> m) {
            super(m);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXMapWithSerializable<K, V>((XMap<K, V>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (XMap<K, V>)in.readObject();
        }
    }

    private static class UnmodifiableStandardNavigableMap<K, V> extends UnmodifiableStandardSortedMap<K, V> implements StandardNavigableMap<K, V> {

        UnmodifiableStandardNavigableMap(StandardNavigableMap<K, V> m) {
            super(m);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        UnmodifiableStandardNavigableMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableStandardNavigableMap<K, V>((StandardNavigableMap<K, V>)obj);
        }

        @Override
        public StandardNavigableMap<K, V> tailMap(K fromKey) {
             return MACollections.unmodifiable(((StandardNavigableMap<K, V>)this.m).tailMap(fromKey));
        }

        @Override
        public Map.Entry<K, V> pollLastEntry() {
            throw new UnsupportedOperationException(
                unmodifable("java.util.Map.Entry<K, V> java.util.NavigableMap<K, V>.pollLastEntry()")
            );
        }

        @Override
        public Map.Entry<K, V> firstEntry() {
             return MACollections.unmodifiable(((StandardNavigableMap<K, V>)this.m).firstEntry());
        }

        @Override
        public Map.Entry<K, V> pollFirstEntry() {
            throw new UnsupportedOperationException(
                unmodifable("java.util.Map.Entry<K, V> java.util.NavigableMap<K, V>.pollFirstEntry()")
            );
        }

        @Override
        public K lowerKey(K key) {
            return ((StandardNavigableMap<K, V>)this.m).lowerKey(key);
        }

        @Override
        public StandardNavigableMap<K, V> tailMap(K fromKey, boolean inclusive) {
             return MACollections.unmodifiable(((StandardNavigableMap<K, V>)this.m).tailMap(fromKey, inclusive));
        }

        @Override
        public Map.Entry<K, V> lowerEntry(K key) {
             return MACollections.unmodifiable(((StandardNavigableMap<K, V>)this.m).lowerEntry(key));
        }

        @Override
        public K ceilingKey(K key) {
            return ((StandardNavigableMap<K, V>)this.m).ceilingKey(key);
        }

        @Override
        public StandardNavigableMap<K, V> descendingMap() {
             return MACollections.unmodifiable(((StandardNavigableMap<K, V>)this.m).descendingMap());
        }

        @Override
        public StandardNavigableMap<K, V> headMap(K toKey, boolean inclusive) {
             return MACollections.unmodifiable(((StandardNavigableMap<K, V>)this.m).headMap(toKey, inclusive));
        }

        @Override
        public StandardNavigableMap<K, V> subMap(K fromKey, K toKey) {
             return MACollections.unmodifiable(((StandardNavigableMap<K, V>)this.m).subMap(fromKey, toKey));
        }

        @Override
        public Map.Entry<K, V> ceilingEntry(K key) {
             return MACollections.unmodifiable(((StandardNavigableMap<K, V>)this.m).ceilingEntry(key));
        }

        @Override
        public Map.Entry<K, V> lastEntry() {
             return MACollections.unmodifiable(((StandardNavigableMap<K, V>)this.m).lastEntry());
        }

        @Override
        public Map.Entry<K, V> floorEntry(K key) {
             return MACollections.unmodifiable(((StandardNavigableMap<K, V>)this.m).floorEntry(key));
        }

        @Override
        public NavigableSet<K> descendingKeySet() {
             return MACollections.unmodifiable(((StandardNavigableMap<K, V>)this.m).descendingKeySet());
        }

        @Override
        public StandardNavigableMap<K, V> subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) {
             return MACollections.unmodifiable(((StandardNavigableMap<K, V>)this.m).subMap(fromKey, fromInclusive, toKey, toInclusive));
        }

        @Override
        public StandardNavigableMap<K, V> headMap(K toKey) {
             return MACollections.unmodifiable(((StandardNavigableMap<K, V>)this.m).headMap(toKey));
        }

        @Override
        public Map.Entry<K, V> higherEntry(K key) {
             return MACollections.unmodifiable(((StandardNavigableMap<K, V>)this.m).higherEntry(key));
        }

        @Override
        public K floorKey(K key) {
            return ((StandardNavigableMap<K, V>)this.m).floorKey(key);
        }

        @Override
        public NavigableSet<K> navigableKeySet() {
             return MACollections.unmodifiable(((StandardNavigableMap<K, V>)this.m).navigableKeySet());
        }

        @Override
        public K higherKey(K key) {
            return ((StandardNavigableMap<K, V>)this.m).higherKey(key);
        }
    }

    private static class UnmodifiableStandardNavigableMapWithSerializable<K, V> extends UnmodifiableStandardNavigableMap<K, V> implements Serializable {

        private static final long serialVersionUID = 355633373770955622L;

        UnmodifiableStandardNavigableMapWithSerializable(StandardNavigableMap<K, V> m) {
            super(m);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableStandardNavigableMapWithSerializable<K, V>((StandardNavigableMap<K, V>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (StandardNavigableMap<K, V>)in.readObject();
        }
    }

    private static class UnmodifiableStandardSortedMap<K, V> extends UnmodifiableStandardMap<K, V> implements StandardSortedMap<K, V> {

        UnmodifiableStandardSortedMap(StandardSortedMap<K, V> m) {
            super(m);
        }

        @Deprecated //Only for deserialization
        UnmodifiableStandardSortedMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableStandardSortedMap<K, V>((StandardSortedMap<K, V>)obj);
        }

        @Override
        public StandardSortedMap<K, V> headMap(K toKey) {
             return MACollections.unmodifiable(((StandardSortedMap<K, V>)this.m).headMap(toKey));
        }

        @Override
        public K firstKey() {
            return ((StandardSortedMap<K, V>)this.m).firstKey();
        }

        @Override
        public StandardSortedMap<K, V> subMap(K fromKey, K toKey) {
             return MACollections.unmodifiable(((StandardSortedMap<K, V>)this.m).subMap(fromKey, toKey));
        }

        @Override
        public StandardSortedMap<K, V> tailMap(K fromKey) {
             return MACollections.unmodifiable(((StandardSortedMap<K, V>)this.m).tailMap(fromKey));
        }

        @Override
        public Comparator<? super K> comparator() {
            return ((StandardSortedMap<K, V>)this.m).comparator();
        }

        @Override
        public K lastKey() {
            return ((StandardSortedMap<K, V>)this.m).lastKey();
        }
    }

    private static class UnmodifiableStandardSortedMapWithSerializable<K, V> extends UnmodifiableStandardSortedMap<K, V> implements Serializable {

        private static final long serialVersionUID = -192409712L;

        UnmodifiableStandardSortedMapWithSerializable(StandardSortedMap<K, V> m) {
            super(m);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableStandardSortedMapWithSerializable<K, V>((StandardSortedMap<K, V>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (StandardSortedMap<K, V>)in.readObject();
        }
    }

    private static class UnmodifiableStandardMap<K, V> extends UnmodifiableMap<K, V> implements StandardMap<K, V> {

        UnmodifiableStandardMap(StandardMap<K, V> m) {
            super(m);
        }

        @Deprecated //Only for deserialization
        UnmodifiableStandardMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableStandardMap<K, V>((StandardMap<K, V>)obj);
        }

        @Override
        public boolean isReadWriteLockSupported() {
            return ((StandardMap<K, V>)this.m).isReadWriteLockSupported();
        }

        @Override
        public StandardMap.EntrySet<K, V> entrySet() {
             return MACollections.unmodifiable(((StandardMap<K, V>)this.m).entrySet());
        }
    }

    private static class UnmodifiableStandardMapWithSerializable<K, V> extends UnmodifiableStandardMap<K, V> implements Serializable {

        private static final long serialVersionUID = -1335301555L;

        UnmodifiableStandardMapWithSerializable(StandardMap<K, V> m) {
            super(m);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableStandardMapWithSerializable<K, V>((StandardMap<K, V>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (StandardMap<K, V>)in.readObject();
        }
    }

    private static abstract class UnmodifiableMap<K, V> extends UnmodifiableProxy implements Map<K, V> {

        Map<K, V> m;

        UnmodifiableMap(Map<K, V> m) {
            this.m = m;
        }

        @Deprecated //Only for deserialization
        UnmodifiableMap() {
        }

        @Override
        Object getInnerObject() {
            return this.m;
        }

        @Override
        public String toString() {
            return this.m.toString();
        }

        @Override
        public boolean isEmpty() {
            return this.m.isEmpty();
        }

        @Override
        public V get(Object key) {
            return this.m.get(key);
        }

        /*
         * Don't implement 
         * java.util.Set entrySet()
         * here because the current class 
         * is neither "StandardMap" nor "XMap"
         */

        @Override
        public Set<K> keySet() {
             return MACollections.unmodifiable(this.m.keySet());
        }

        @Override
        public boolean containsKey(Object o) {
            return this.m.containsKey(o);
        }

        @Override
        public void clear() {
            throw new UnsupportedOperationException(
                unmodifable("void java.util.Map<K, V>.clear()")
            );
        }

        @Override
        public V put(K key, V value) {
            throw new UnsupportedOperationException(
                unmodifable("V java.util.Map<K, V>.put(K, V)")
            );
        }

        @Override
        public void putAll(Map<? extends K, ? extends V> m) {
            throw new UnsupportedOperationException(
                unmodifable("void java.util.Map<K, V>.putAll(java.util.Map<? extends K, ? extends V>)")
            );
        }

        @Override
        public int hashCode() {
            return this.m.hashCode();
        }

        @Override
        public Collection<V> values() {
             return MACollections.unmodifiable(this.m.values());
        }

        @Override
        public V remove(Object key) {
            throw new UnsupportedOperationException(
                unmodifable("V java.util.Map<K, V>.remove(java.lang.Object)")
            );
        }

        @Override
        public boolean equals(Object obj) {
            return this.m.equals(obj);
        }

        @Override
        public boolean containsValue(Object o) {
            return this.m.containsValue(o);
        }

        @Override
        public int size() {
            return this.m.size();
        }
    }

    /*
     * No derived class "UnmodifiableMapWithSerializable<K, V>"
     * for class "UnmodifiableMap<K, V>" because it is abstract.
     */

    private static class UnmodifiableMAListMAListView<E> extends UnmodifiableMAList<E> implements MAList.MAListView<E> {

        UnmodifiableMAListMAListView(MAList.MAListView<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMAListMAListView<E>((MAList.MAListView<E>)obj);
        }

        @Override
        public ViewInfo viewInfo() {
            return ((MAList.MAListView<E>)this.c).viewInfo();
        }
    }
    private static class UnmodifiableMAListMAListViewWithRandomAccess<E> extends UnmodifiableMAListMAListView<E> implements RandomAccess {

        UnmodifiableMAListMAListViewWithRandomAccess(MAList.MAListView<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMAListMAListViewWithRandomAccess<E>((MAList.MAListView<E>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (MAList.MAListView<E>)in.readObject();
        }
    }


    private static class UnmodifiableMAList<E> extends UnmodifiableMACollection<E> implements MAList<E> {

        UnmodifiableMAList(MAList<E> c) {
            super(c);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        UnmodifiableMAList() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMAList<E>((MAList<E>)obj);
        }

        @Override
        public void removeListElementListener(ListElementListener<? super E> listener) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.MAList<E>.removeListElementListener(org.babyfish.collection.event.ListElementListener<? super E>)")
            );
        }

        @Override
        public MAList.MAListIterator<E> iterator() {
             return MACollections.unmodifiable(((MAList<E>)this.c).iterator());
        }

        @Override
        public MAList.MAListIterator<E> listIterator() {
             return MACollections.unmodifiable(((MAList<E>)this.c).listIterator());
        }

        @Override
        public void addListElementListener(ListElementListener<? super E> listener) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.MAList<E>.addListElementListener(org.babyfish.collection.event.ListElementListener<? super E>)")
            );
        }

        @Override
        public MAList.MAListView<E> subList(int from, int to) {
             return MACollections.unmodifiable(((MAList<E>)this.c).subList(from, to));
        }

        @Override
        public E get(int index) {
            return ((MAList<E>)this.c).get(index);
        }

        @Override
        public MAList.MAListIterator<E> listIterator(int index) {
             return MACollections.unmodifiable(((MAList<E>)this.c).listIterator(index));
        }

        @Override
        public boolean addAll(int index, Collection<? extends E> c) {
            throw new UnsupportedOperationException(
                unmodifable("boolean java.util.List<E>.addAll(int, java.util.Collection<? extends E>)")
            );
        }

        @Override
        public BidiType bidiType() {
            return ((MAList<E>)this.c).bidiType();
        }

        @Override
        public int indexOf(Object o) {
            return ((MAList<E>)this.c).indexOf(o);
        }

        @Override
        public int lastIndexOf(Object o) {
            return ((MAList<E>)this.c).lastIndexOf(o);
        }

        @Override
        public E set(int index, E e) {
            throw new UnsupportedOperationException(
                unmodifable("E java.util.List<E>.set(int, E)")
            );
        }

        @Override
        public E remove(int index) {
            throw new UnsupportedOperationException(
                unmodifable("E java.util.List<E>.remove(int)")
            );
        }

        @Override
        public void add(int index, E e) {
            throw new UnsupportedOperationException(
                unmodifable("void java.util.List<E>.add(int, E)")
            );
        }
    }

    private static class UnmodifiableMAListWithSerializable<E> extends UnmodifiableMAList<E> implements Serializable {

        private static final long serialVersionUID = -442415002L;

        UnmodifiableMAListWithSerializable(MAList<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMAListWithSerializable<E>((MAList<E>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (MAList<E>)in.readObject();
        }
    }

    private static class UnmodifiableMAListWithRandomAccess<E> extends UnmodifiableMAList<E> implements RandomAccess {

        UnmodifiableMAListWithRandomAccess(MAList<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMAListWithRandomAccess<E>((MAList<E>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (MAList<E>)in.readObject();
        }
    }


    private static class UnmodifiableMAListWithSerializableRandomAccess<E> extends UnmodifiableMAList<E> implements Serializable, RandomAccess {

        private static final long serialVersionUID = -442415002L;

        UnmodifiableMAListWithSerializableRandomAccess(MAList<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMAListWithSerializableRandomAccess<E>((MAList<E>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (MAList<E>)in.readObject();
        }
    }

    private static class UnmodifiableMAOrderedMapMAOrderedKeySetView<K, V> extends UnmodifiableMAOrderedSetMAOrderedSetView<K> implements MAOrderedMap.MAOrderedKeySetView<K, V> {

        UnmodifiableMAOrderedMapMAOrderedKeySetView(MAOrderedMap.MAOrderedKeySetView<K, V> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMAOrderedMapMAOrderedKeySetView<K, V>((MAOrderedMap.MAOrderedKeySetView<K, V>)obj);
        }

        @SuppressWarnings("unchecked")
        @Override
        public MAMap.MAKeySetView.MAKeySetIterator<K, V> descendingIterator() {
             return MACollections.unmodifiable(((MAOrderedMap.MAOrderedKeySetView<K, V>)this.c).descendingIterator());
        }

        @Override
        public void removeKeySetElementListener(KeySetElementListener<? super K, ? super V> listener) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.removeKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
            );
        }

        @SuppressWarnings("unchecked")
        @Override
        public MAOrderedMap.MAOrderedKeySetView<K, V> descendingSet() {
             return MACollections.unmodifiable(((MAOrderedMap.MAOrderedKeySetView<K, V>)this.c).descendingSet());
        }

        @SuppressWarnings("unchecked")
        @Override
        public MAMap.MAKeySetView.MAKeySetIterator<K, V> iterator() {
             return MACollections.unmodifiable(((MAOrderedMap.MAOrderedKeySetView<K, V>)this.c).iterator());
        }

        @Override
        public void addKeySetElementListener(KeySetElementListener<? super K, ? super V> listener) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.addKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
            );
        }
    }

    private static class UnmodifiableMAOrderedSetMAOrderedSetView<E> extends UnmodifiableMAOrderedSet<E> implements MAOrderedSet.MAOrderedSetView<E> {

        UnmodifiableMAOrderedSetMAOrderedSetView(MAOrderedSet.MAOrderedSetView<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMAOrderedSetMAOrderedSetView<E>((MAOrderedSet.MAOrderedSetView<E>)obj);
        }

        @Override
        public ViewInfo viewInfo() {
            return ((MAOrderedSet.MAOrderedSetView<E>)this.c).viewInfo();
        }
    }

    private static class UnmodifiableMAOrderedSet<E> extends UnmodifiableMASet<E> implements MAOrderedSet<E> {

        UnmodifiableMAOrderedSet(MAOrderedSet<E> c) {
            super(c);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        UnmodifiableMAOrderedSet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMAOrderedSet<E>((MAOrderedSet<E>)obj);
        }

        @Override
        public OrderAdjustMode replaceMode() {
            return ((MAOrderedSet<E>)this.c).replaceMode();
        }

        @Override
        public boolean headAppend() {
            return ((MAOrderedSet<E>)this.c).headAppend();
        }

        @Override
        public E last() {
            return ((MAOrderedSet<E>)this.c).last();
        }

        @Override
        public MAOrderedSet.MAOrderedSetView<E> descendingSet() {
             return MACollections.unmodifiable(((MAOrderedSet<E>)this.c).descendingSet());
        }

        @Override
        public MACollection.MAIterator<E> descendingIterator() {
             return MACollections.unmodifiable(((MAOrderedSet<E>)this.c).descendingIterator());
        }

        @Override
        public E first() {
            return ((MAOrderedSet<E>)this.c).first();
        }

        @Override
        public E pollLast() {
            throw new UnsupportedOperationException(
                unmodifable("E org.babyfish.collection.XOrderedSet<E>.pollLast()")
            );
        }

        @Override
        public E pollFirst() {
            throw new UnsupportedOperationException(
                unmodifable("E org.babyfish.collection.XOrderedSet<E>.pollFirst()")
            );
        }
    }

    private static class UnmodifiableMAOrderedSetWithSerializable<E> extends UnmodifiableMAOrderedSet<E> implements Serializable {

        private static final long serialVersionUID = -192698961L;

        UnmodifiableMAOrderedSetWithSerializable(MAOrderedSet<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMAOrderedSetWithSerializable<E>((MAOrderedSet<E>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (MAOrderedSet<E>)in.readObject();
        }
    }

    private static class UnmodifiableMANavigableMapMANavigableKeySetView<K, V> extends UnmodifiableMANavigableSetMANavigableSetView<K> implements MANavigableMap.MANavigableKeySetView<K, V> {

        UnmodifiableMANavigableMapMANavigableKeySetView(MANavigableMap.MANavigableKeySetView<K, V> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMANavigableMapMANavigableKeySetView<K, V>((MANavigableMap.MANavigableKeySetView<K, V>)obj);
        }

        @SuppressWarnings("unchecked")
        @Override
        public MANavigableMap.MANavigableKeySetView<K, V> subSet(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) {
             return MACollections.unmodifiable(((MANavigableMap.MANavigableKeySetView<K, V>)this.c).subSet(fromKey, fromInclusive, toKey, toInclusive));
        }

        @SuppressWarnings("unchecked")
        @Override
        public MANavigableMap.MANavigableKeySetView<K, V> tailSet(K fromKey, boolean inclusive) {
             return MACollections.unmodifiable(((MANavigableMap.MANavigableKeySetView<K, V>)this.c).tailSet(fromKey, inclusive));
        }

        @SuppressWarnings("unchecked")
        @Override
        public MANavigableMap.MANavigableKeySetView<K, V> headSet(K toKey, boolean inclusive) {
             return MACollections.unmodifiable(((MANavigableMap.MANavigableKeySetView<K, V>)this.c).headSet(toKey, inclusive));
        }

        @SuppressWarnings("unchecked")
        @Override
        public MAMap.MAKeySetView.MAKeySetIterator<K, V> descendingIterator() {
             return MACollections.unmodifiable(((MANavigableMap.MANavigableKeySetView<K, V>)this.c).descendingIterator());
        }

        @Override
        public void removeKeySetElementListener(KeySetElementListener<? super K, ? super V> listener) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.removeKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
            );
        }

        @SuppressWarnings("unchecked")
        @Override
        public MAMap.MAKeySetView.MAKeySetIterator<K, V> iterator() {
             return MACollections.unmodifiable(((MANavigableMap.MANavigableKeySetView<K, V>)this.c).iterator());
        }

        @SuppressWarnings("unchecked")
        @Override
        public MANavigableMap.MANavigableKeySetView<K, V> headSet(K toKey) {
             return MACollections.unmodifiable(((MANavigableMap.MANavigableKeySetView<K, V>)this.c).headSet(toKey));
        }

        @SuppressWarnings("unchecked")
        @Override
        public MANavigableMap.MANavigableKeySetView<K, V> tailSet(K fromKey) {
             return MACollections.unmodifiable(((MANavigableMap.MANavigableKeySetView<K, V>)this.c).tailSet(fromKey));
        }

        @SuppressWarnings("unchecked")
        @Override
        public MANavigableMap.MANavigableKeySetView<K, V> descendingSet() {
             return MACollections.unmodifiable(((MANavigableMap.MANavigableKeySetView<K, V>)this.c).descendingSet());
        }

        @SuppressWarnings("unchecked")
        @Override
        public MANavigableMap.MANavigableKeySetView<K, V> subSet(K fromKey, K toKey) {
             return MACollections.unmodifiable(((MANavigableMap.MANavigableKeySetView<K, V>)this.c).subSet(fromKey, toKey));
        }

        @Override
        public void addKeySetElementListener(KeySetElementListener<? super K, ? super V> listener) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.addKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
            );
        }
    }

    private static class UnmodifiableMANavigableSetMANavigableSetView<E> extends UnmodifiableMANavigableSet<E> implements MANavigableSet.MANavigableSetView<E> {

        UnmodifiableMANavigableSetMANavigableSetView(MANavigableSet.MANavigableSetView<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMANavigableSetMANavigableSetView<E>((MANavigableSet.MANavigableSetView<E>)obj);
        }

        @Override
        public ViewInfo viewInfo() {
            return ((MANavigableSet.MANavigableSetView<E>)this.c).viewInfo();
        }
    }

    private static class UnmodifiableMANavigableSet<E> extends UnmodifiableMASortedSet<E> implements MANavigableSet<E> {

        UnmodifiableMANavigableSet(MANavigableSet<E> c) {
            super(c);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        UnmodifiableMANavigableSet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMANavigableSet<E>((MANavigableSet<E>)obj);
        }

        @Override
        public E higher(E e) {
            return ((MANavigableSet<E>)this.c).higher(e);
        }

        @Override
        public MACollection.MAIterator<E> descendingIterator() {
             return MACollections.unmodifiable(((MANavigableSet<E>)this.c).descendingIterator());
        }

        @Override
        public MANavigableSet.MANavigableSetView<E> tailSet(E fromElement) {
             return MACollections.unmodifiable(((MANavigableSet<E>)this.c).tailSet(fromElement));
        }

        @Override
        public E lower(E e) {
            return ((MANavigableSet<E>)this.c).lower(e);
        }

        @Override
        public MANavigableSet.MANavigableSetView<E> tailSet(E fromElement, boolean inclusive) {
             return MACollections.unmodifiable(((MANavigableSet<E>)this.c).tailSet(fromElement, inclusive));
        }

        @Override
        public MANavigableSet.MANavigableSetView<E> subSet(E fromElement, E toElement) {
             return MACollections.unmodifiable(((MANavigableSet<E>)this.c).subSet(fromElement, toElement));
        }

        @Override
        public MANavigableSet.MANavigableSetView<E> headSet(E toElement, boolean inclusive) {
             return MACollections.unmodifiable(((MANavigableSet<E>)this.c).headSet(toElement, inclusive));
        }

        @Override
        public E floor(E e) {
            return ((MANavigableSet<E>)this.c).floor(e);
        }

        @Override
        public E ceiling(E e) {
            return ((MANavigableSet<E>)this.c).ceiling(e);
        }

        @Override
        public MANavigableSet.MANavigableSetView<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {
             return MACollections.unmodifiable(((MANavigableSet<E>)this.c).subSet(fromElement, fromInclusive, toElement, toInclusive));
        }

        @Override
        public MANavigableSet.MANavigableSetView<E> descendingSet() {
             return MACollections.unmodifiable(((MANavigableSet<E>)this.c).descendingSet());
        }

        @Override
        public MANavigableSet.MANavigableSetView<E> headSet(E toElement) {
             return MACollections.unmodifiable(((MANavigableSet<E>)this.c).headSet(toElement));
        }

        @Override
        public E pollLast() {
            throw new UnsupportedOperationException(
                unmodifable("E java.util.NavigableSet<E>.pollLast()")
            );
        }

        @Override
        public E pollFirst() {
            throw new UnsupportedOperationException(
                unmodifable("E java.util.NavigableSet<E>.pollFirst()")
            );
        }
    }

    private static class UnmodifiableMANavigableSetWithSerializable<E> extends UnmodifiableMANavigableSet<E> implements Serializable {

        private static final long serialVersionUID = -65373859L;

        UnmodifiableMANavigableSetWithSerializable(MANavigableSet<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMANavigableSetWithSerializable<E>((MANavigableSet<E>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (MANavigableSet<E>)in.readObject();
        }
    }

    private static class UnmodifiableMASortedMapMASortedKeySetView<K, V> extends UnmodifiableMASortedSetMASortedSetView<K> implements MASortedMap.MASortedKeySetView<K, V> {

        UnmodifiableMASortedMapMASortedKeySetView(MASortedMap.MASortedKeySetView<K, V> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMASortedMapMASortedKeySetView<K, V>((MASortedMap.MASortedKeySetView<K, V>)obj);
        }

        @SuppressWarnings("unchecked")
        @Override
        public MASortedMap.MASortedKeySetView<K, V> tailSet(K fromKey) {
             return MACollections.unmodifiable(((MASortedMap.MASortedKeySetView<K, V>)this.c).tailSet(fromKey));
        }

        @Override
        public void removeKeySetElementListener(KeySetElementListener<? super K, ? super V> listener) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.removeKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
            );
        }

        @SuppressWarnings("unchecked")
        @Override
        public MAMap.MAKeySetView.MAKeySetIterator<K, V> iterator() {
             return MACollections.unmodifiable(((MASortedMap.MASortedKeySetView<K, V>)this.c).iterator());
        }

        @SuppressWarnings("unchecked")
        @Override
        public MASortedMap.MASortedKeySetView<K, V> subSet(K fromKey, K toKey) {
             return MACollections.unmodifiable(((MASortedMap.MASortedKeySetView<K, V>)this.c).subSet(fromKey, toKey));
        }

        @SuppressWarnings("unchecked")
        @Override
        public MASortedMap.MASortedKeySetView<K, V> headSet(K toKey) {
             return MACollections.unmodifiable(((MASortedMap.MASortedKeySetView<K, V>)this.c).headSet(toKey));
        }

        @Override
        public void addKeySetElementListener(KeySetElementListener<? super K, ? super V> listener) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.addKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
            );
        }
    }

    private static class UnmodifiableMASortedSetMASortedSetView<E> extends UnmodifiableMASortedSet<E> implements MASortedSet.MASortedSetView<E> {

        UnmodifiableMASortedSetMASortedSetView(MASortedSet.MASortedSetView<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMASortedSetMASortedSetView<E>((MASortedSet.MASortedSetView<E>)obj);
        }

        @Override
        public ViewInfo viewInfo() {
            return ((MASortedSet.MASortedSetView<E>)this.c).viewInfo();
        }
    }

    private static class UnmodifiableMASortedSet<E> extends UnmodifiableMASet<E> implements MASortedSet<E> {

        UnmodifiableMASortedSet(MASortedSet<E> c) {
            super(c);
        }

        @Deprecated //Only for deserialization
        UnmodifiableMASortedSet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMASortedSet<E>((MASortedSet<E>)obj);
        }

        @Override
        public MASortedSet.MASortedSetView<E> subSet(E fromElement, E toElement) {
             return MACollections.unmodifiable(((MASortedSet<E>)this.c).subSet(fromElement, toElement));
        }

        @Override
        public MASortedSet.MASortedSetView<E> tailSet(E fromElement) {
             return MACollections.unmodifiable(((MASortedSet<E>)this.c).tailSet(fromElement));
        }

        @Override
        public E last() {
            return ((MASortedSet<E>)this.c).last();
        }

        @Override
        public E first() {
            return ((MASortedSet<E>)this.c).first();
        }

        @Override
        public Comparator<? super E> comparator() {
            return ((MASortedSet<E>)this.c).comparator();
        }

        @Override
        public MASortedSet.MASortedSetView<E> headSet(E toElement) {
             return MACollections.unmodifiable(((MASortedSet<E>)this.c).headSet(toElement));
        }
    }

    private static class UnmodifiableMASortedSetWithSerializable<E> extends UnmodifiableMASortedSet<E> implements Serializable {

        private static final long serialVersionUID = -176924479L;

        UnmodifiableMASortedSetWithSerializable(MASortedSet<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMASortedSetWithSerializable<E>((MASortedSet<E>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (MASortedSet<E>)in.readObject();
        }
    }

    private static class UnmodifiableMAMapMAEntrySetView<K, V> extends UnmodifiableMASet<Map.Entry<K, V>> implements MAMap.MAEntrySetView<K, V> {

        UnmodifiableMAMapMAEntrySetView(MAMap.MAEntrySetView<K, V> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMAMapMAEntrySetView<K, V>((MAMap.MAEntrySetView<K, V>)obj);
        }

        @SuppressWarnings("unchecked")
        @Override
        public <T> T[] toArray(T[] a) {
            Object[] arr = this.c.toArray(a.length==0 ? a : (Object[])Array.newInstance(a.getClass().getComponentType(), 0));
            for (int i = arr.length - 1; i >= 0; i--) {
                arr[i] = MACollections.unmodifiable((MAMap.MAEntry<K, V>)arr[i]);
            }
            if (arr.length > a.length) {
                return (T[])arr;
            }
            System.arraycopy(arr, 0, a, 0, arr.length);
            if (a.length > arr.length) {
                a[arr.length] = null;
            }
            return a;
        }

        @Deprecated
        @Override
        public boolean add(Map.Entry<K, V> entry) {
            throw new UnsupportedOperationException(
                notSupported("boolean org.babyfish.collection.MAMap.MAEntrySetView<K, V>.add(java.util.Map.Entry<K, V>)")
            );
        }

        @SuppressWarnings("unchecked")
        @Override
        public ViewInfo viewInfo() {
            return ((MAMap.MAEntrySetView<K, V>)this.c).viewInfo();
        }

        @SuppressWarnings("unchecked")
        @Override
        public Object[] toArray() {
            Object[] arr = this.c.toArray();
            for (int i = arr.length - 1; i >= 0; i--) {
                arr[i] = MACollections.unmodifiable((MAMap.MAEntry<K, V>)arr[i]);
            }
            return arr;
        }

        @SuppressWarnings("unchecked")
        @Override
        public MAMap.MAEntrySetView.MAEntrySetIterator<K, V> iterator() {
             return MACollections.unmodifiable(((MAMap.MAEntrySetView<K, V>)this.c).iterator());
        }
    }

    private static class UnmodifiableMAMapMAValuesView<K, V> extends UnmodifiableMACollection<V> implements MAMap.MAValuesView<K, V> {

        UnmodifiableMAMapMAValuesView(MAMap.MAValuesView<K, V> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMAMapMAValuesView<K, V>((MAMap.MAValuesView<K, V>)obj);
        }

        @Override
        public void addValuesElementListener(ValuesElementListener<? super K, ? super V> listener) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.event.ValuesElementModificationAware<K, V>.addValuesElementListener(org.babyfish.collection.event.ValuesElementListener<? super K, ? super V>)")
            );
        }

        @Override
        public void removeValuesElementListener(ValuesElementListener<? super K, ? super V> listener) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.event.ValuesElementModificationAware<K, V>.removeValuesElementListener(org.babyfish.collection.event.ValuesElementListener<? super K, ? super V>)")
            );
        }

        @SuppressWarnings("unchecked")
        @Override
        public MAMap.MAValuesView.MAValuesIterator<K, V> iterator() {
             return MACollections.unmodifiable(((MAMap.MAValuesView<K, V>)this.c).iterator());
        }

        @SuppressWarnings("unchecked")
        @Override
        public ViewInfo viewInfo() {
            return ((MAMap.MAValuesView<K, V>)this.c).viewInfo();
        }
    }

    private static class UnmodifiableMAMapMAKeySetView<K, V> extends UnmodifiableMASet<K> implements MAMap.MAKeySetView<K, V> {

        UnmodifiableMAMapMAKeySetView(MAMap.MAKeySetView<K, V> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMAMapMAKeySetView<K, V>((MAMap.MAKeySetView<K, V>)obj);
        }

        @Override
        public void removeKeySetElementListener(KeySetElementListener<? super K, ? super V> listener) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.removeKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
            );
        }

        @SuppressWarnings("unchecked")
        @Override
        public MAMap.MAKeySetView.MAKeySetIterator<K, V> iterator() {
             return MACollections.unmodifiable(((MAMap.MAKeySetView<K, V>)this.c).iterator());
        }

        @SuppressWarnings("unchecked")
        @Override
        public ViewInfo viewInfo() {
            return ((MAMap.MAKeySetView<K, V>)this.c).viewInfo();
        }

        @Override
        public void addKeySetElementListener(KeySetElementListener<? super K, ? super V> listener) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.addKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
            );
        }
    }

    private static class UnmodifiableMASet<E> extends UnmodifiableMACollection<E> implements MASet<E> {

        UnmodifiableMASet(MASet<E> c) {
            super(c);
        }

        @Deprecated //Only for deserialization
        UnmodifiableMASet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMASet<E>((MASet<E>)obj);
        }

        @Override
        public ReplacementRule replacementRule() {
            return ((MASet<E>)this.c).replacementRule();
        }
    }

    private static class UnmodifiableMASetWithSerializable<E> extends UnmodifiableMASet<E> implements Serializable {

        private static final long serialVersionUID = -9181076850502646684L;

        UnmodifiableMASetWithSerializable(MASet<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMASetWithSerializable<E>((MASet<E>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (MASet<E>)in.readObject();
        }
    }

    private static class UnmodifiableMACollection<E> extends UnmodifiableXCollection<E> implements MACollection<E> {

        UnmodifiableMACollection(MACollection<E> c) {
            super(c);
        }

        @Deprecated //Only for deserialization
        UnmodifiableMACollection() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMACollection<E>((MACollection<E>)obj);
        }

        @Override
        public MACollection.MAIterator<E> iterator() {
             return MACollections.unmodifiable(((MACollection<E>)this.c).iterator());
        }

        @Override
        public void removeElementListener(ElementListener<? super E> listener) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.event.ElementModificationAware<E>.removeElementListener(org.babyfish.collection.event.ElementListener<? super E>)")
            );
        }

        @Override
        public void addElementListener(ElementListener<? super E> listener) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.event.ElementModificationAware<E>.addElementListener(org.babyfish.collection.event.ElementListener<? super E>)")
            );
        }
    }

    private static class UnmodifiableMACollectionWithSerializable<E> extends UnmodifiableMACollection<E> implements Serializable {

        private static final long serialVersionUID = -767628436118267098L;

        UnmodifiableMACollectionWithSerializable(MACollection<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMACollectionWithSerializable<E>((MACollection<E>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (MACollection<E>)in.readObject();
        }
    }

    private static class UnmodifiableXListXListView<E> extends UnmodifiableXList<E> implements XList.XListView<E> {

        UnmodifiableXListXListView(XList.XListView<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXListXListView<E>((XList.XListView<E>)obj);
        }

        @Override
        public ViewInfo viewInfo() {
            return ((XList.XListView<E>)this.c).viewInfo();
        }
    }
    private static class UnmodifiableXListXListViewWithRandomAccess<E> extends UnmodifiableXListXListView<E> implements RandomAccess {

        UnmodifiableXListXListViewWithRandomAccess(XList.XListView<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXListXListViewWithRandomAccess<E>((XList.XListView<E>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (XList.XListView<E>)in.readObject();
        }
    }


    private static class UnmodifiableXList<E> extends UnmodifiableXCollection<E> implements XList<E> {

        UnmodifiableXList(XList<E> c) {
            super(c);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        UnmodifiableXList() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXList<E>((XList<E>)obj);
        }

        @Override
        public BidiType bidiType() {
            return ((XList<E>)this.c).bidiType();
        }

        @Override
        public int indexOf(Object o) {
            return ((XList<E>)this.c).indexOf(o);
        }

        @Override
        public int lastIndexOf(Object o) {
            return ((XList<E>)this.c).lastIndexOf(o);
        }

        @Override
        public E set(int index, E e) {
            throw new UnsupportedOperationException(
                unmodifable("E java.util.List<E>.set(int, E)")
            );
        }

        @Override
        public XList.XListIterator<E> listIterator() {
             return MACollections.unmodifiable(((XList<E>)this.c).listIterator());
        }

        @Override
        public E get(int index) {
            return ((XList<E>)this.c).get(index);
        }

        @Override
        public XList.XListIterator<E> listIterator(int index) {
             return MACollections.unmodifiable(((XList<E>)this.c).listIterator(index));
        }

        @Override
        public XList.XListIterator<E> iterator() {
             return MACollections.unmodifiable(((XList<E>)this.c).iterator());
        }

        @Override
        public XList.XListView<E> subList(int from, int to) {
             return MACollections.unmodifiable(((XList<E>)this.c).subList(from, to));
        }

        @Override
        public E remove(int index) {
            throw new UnsupportedOperationException(
                unmodifable("E java.util.List<E>.remove(int)")
            );
        }

        @Override
        public void add(int index, E e) {
            throw new UnsupportedOperationException(
                unmodifable("void java.util.List<E>.add(int, E)")
            );
        }

        @Override
        public boolean addAll(int index, Collection<? extends E> c) {
            throw new UnsupportedOperationException(
                unmodifable("boolean java.util.List<E>.addAll(int, java.util.Collection<? extends E>)")
            );
        }
    }

    private static class UnmodifiableXListWithSerializable<E> extends UnmodifiableXList<E> implements Serializable {

        private static final long serialVersionUID = -4277166927100795780L;

        UnmodifiableXListWithSerializable(XList<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXListWithSerializable<E>((XList<E>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (XList<E>)in.readObject();
        }
    }

    private static class UnmodifiableXListWithRandomAccess<E> extends UnmodifiableXList<E> implements RandomAccess {

        UnmodifiableXListWithRandomAccess(XList<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXListWithRandomAccess<E>((XList<E>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (XList<E>)in.readObject();
        }
    }


    private static class UnmodifiableXListWithSerializableRandomAccess<E> extends UnmodifiableXList<E> implements Serializable, RandomAccess {

        private static final long serialVersionUID = -8360511799923334020L;

        UnmodifiableXListWithSerializableRandomAccess(XList<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXListWithSerializableRandomAccess<E>((XList<E>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (XList<E>)in.readObject();
        }
    }

    private static class UnmodifiableXOrderedMapXOrderedKeySetView<K> extends UnmodifiableXOrderedSetXOrderedSetView<K> implements XOrderedMap.XOrderedKeySetView<K> {

        UnmodifiableXOrderedMapXOrderedKeySetView(XOrderedMap.XOrderedKeySetView<K> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXOrderedMapXOrderedKeySetView<K>((XOrderedMap.XOrderedKeySetView<K>)obj);
        }

        @Override
        public XOrderedMap.XOrderedKeySetView<K> descendingSet() {
             return MACollections.unmodifiable(((XOrderedMap.XOrderedKeySetView<K>)this.c).descendingSet());
        }
    }

    private static class UnmodifiableXOrderedSetXOrderedSetView<E> extends UnmodifiableXOrderedSet<E> implements XOrderedSet.XOrderedSetView<E> {

        UnmodifiableXOrderedSetXOrderedSetView(XOrderedSet.XOrderedSetView<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXOrderedSetXOrderedSetView<E>((XOrderedSet.XOrderedSetView<E>)obj);
        }

        @Override
        public ViewInfo viewInfo() {
            return ((XOrderedSet.XOrderedSetView<E>)this.c).viewInfo();
        }
    }

    private static class UnmodifiableXOrderedSet<E> extends UnmodifiableXSet<E> implements XOrderedSet<E> {

        UnmodifiableXOrderedSet(XOrderedSet<E> c) {
            super(c);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        UnmodifiableXOrderedSet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXOrderedSet<E>((XOrderedSet<E>)obj);
        }

        @Override
        public XCollection.XIterator<E> descendingIterator() {
             return MACollections.unmodifiable(((XOrderedSet<E>)this.c).descendingIterator());
        }

        @Override
        public XOrderedSet.XOrderedSetView<E> descendingSet() {
             return MACollections.unmodifiable(((XOrderedSet<E>)this.c).descendingSet());
        }

        @Override
        public OrderAdjustMode replaceMode() {
            return ((XOrderedSet<E>)this.c).replaceMode();
        }

        @Override
        public boolean headAppend() {
            return ((XOrderedSet<E>)this.c).headAppend();
        }

        @Override
        public E last() {
            return ((XOrderedSet<E>)this.c).last();
        }

        @Override
        public E first() {
            return ((XOrderedSet<E>)this.c).first();
        }

        @Override
        public E pollLast() {
            throw new UnsupportedOperationException(
                unmodifable("E org.babyfish.collection.XOrderedSet<E>.pollLast()")
            );
        }

        @Override
        public E pollFirst() {
            throw new UnsupportedOperationException(
                unmodifable("E org.babyfish.collection.XOrderedSet<E>.pollFirst()")
            );
        }
    }

    private static class UnmodifiableXOrderedSetWithSerializable<E> extends UnmodifiableXOrderedSet<E> implements Serializable {

        private static final long serialVersionUID = -1382934203L;

        UnmodifiableXOrderedSetWithSerializable(XOrderedSet<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXOrderedSetWithSerializable<E>((XOrderedSet<E>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (XOrderedSet<E>)in.readObject();
        }
    }

    private static class UnmodifiableXNavigableMapXNavigableKeySetView<K> extends UnmodifiableXNavigableSetXNavigableSetView<K> implements XNavigableMap.XNavigableKeySetView<K> {

        UnmodifiableXNavigableMapXNavigableKeySetView(XNavigableMap.XNavigableKeySetView<K> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXNavigableMapXNavigableKeySetView<K>((XNavigableMap.XNavigableKeySetView<K>)obj);
        }

        @Override
        public XNavigableMap.XNavigableKeySetView<K> headSet(K toKey) {
             return MACollections.unmodifiable(((XNavigableMap.XNavigableKeySetView<K>)this.c).headSet(toKey));
        }

        @Override
        public XNavigableMap.XNavigableKeySetView<K> headSet(K toKey, boolean inclusive) {
             return MACollections.unmodifiable(((XNavigableMap.XNavigableKeySetView<K>)this.c).headSet(toKey, inclusive));
        }

        @Override
        public XNavigableMap.XNavigableKeySetView<K> tailSet(K fromKey) {
             return MACollections.unmodifiable(((XNavigableMap.XNavigableKeySetView<K>)this.c).tailSet(fromKey));
        }

        @Override
        public XNavigableMap.XNavigableKeySetView<K> tailSet(K fromKey, boolean inclusive) {
             return MACollections.unmodifiable(((XNavigableMap.XNavigableKeySetView<K>)this.c).tailSet(fromKey, inclusive));
        }

        @Override
        public XNavigableMap.XNavigableKeySetView<K> subSet(K fromKey, K toKey) {
             return MACollections.unmodifiable(((XNavigableMap.XNavigableKeySetView<K>)this.c).subSet(fromKey, toKey));
        }

        @Override
        public XNavigableMap.XNavigableKeySetView<K> descendingSet() {
             return MACollections.unmodifiable(((XNavigableMap.XNavigableKeySetView<K>)this.c).descendingSet());
        }

        @Override
        public XNavigableMap.XNavigableKeySetView<K> subSet(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) {
             return MACollections.unmodifiable(((XNavigableMap.XNavigableKeySetView<K>)this.c).subSet(fromKey, fromInclusive, toKey, toInclusive));
        }
    }

    private static class UnmodifiableXNavigableSetXNavigableSetView<E> extends UnmodifiableXNavigableSet<E> implements XNavigableSet.XNavigableSetView<E> {

        UnmodifiableXNavigableSetXNavigableSetView(XNavigableSet.XNavigableSetView<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXNavigableSetXNavigableSetView<E>((XNavigableSet.XNavigableSetView<E>)obj);
        }

        @Override
        public ViewInfo viewInfo() {
            return ((XNavigableSet.XNavigableSetView<E>)this.c).viewInfo();
        }
    }

    private static class UnmodifiableXNavigableSet<E> extends UnmodifiableXSortedSet<E> implements XNavigableSet<E> {

        UnmodifiableXNavigableSet(XNavigableSet<E> c) {
            super(c);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        UnmodifiableXNavigableSet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXNavigableSet<E>((XNavigableSet<E>)obj);
        }

        @Override
        public XNavigableSet.XNavigableSetView<E> subSet(E fromElement, E toElement) {
             return MACollections.unmodifiable(((XNavigableSet<E>)this.c).subSet(fromElement, toElement));
        }

        @Override
        public E higher(E e) {
            return ((XNavigableSet<E>)this.c).higher(e);
        }

        @Override
        public XNavigableSet.XNavigableSetView<E> headSet(E toElement) {
             return MACollections.unmodifiable(((XNavigableSet<E>)this.c).headSet(toElement));
        }

        @Override
        public E lower(E e) {
            return ((XNavigableSet<E>)this.c).lower(e);
        }

        @Override
        public XCollection.XIterator<E> descendingIterator() {
             return MACollections.unmodifiable(((XNavigableSet<E>)this.c).descendingIterator());
        }

        @Override
        public XNavigableSet.XNavigableSetView<E> tailSet(E fromElement) {
             return MACollections.unmodifiable(((XNavigableSet<E>)this.c).tailSet(fromElement));
        }

        @Override
        public E floor(E e) {
            return ((XNavigableSet<E>)this.c).floor(e);
        }

        @Override
        public XNavigableSet.XNavigableSetView<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {
             return MACollections.unmodifiable(((XNavigableSet<E>)this.c).subSet(fromElement, fromInclusive, toElement, toInclusive));
        }

        @Override
        public XNavigableSet.XNavigableSetView<E> descendingSet() {
             return MACollections.unmodifiable(((XNavigableSet<E>)this.c).descendingSet());
        }

        @Override
        public E ceiling(E e) {
            return ((XNavigableSet<E>)this.c).ceiling(e);
        }

        @Override
        public XNavigableSet.XNavigableSetView<E> tailSet(E fromElement, boolean inclusive) {
             return MACollections.unmodifiable(((XNavigableSet<E>)this.c).tailSet(fromElement, inclusive));
        }

        @Override
        public XNavigableSet.XNavigableSetView<E> headSet(E toElement, boolean inclusive) {
             return MACollections.unmodifiable(((XNavigableSet<E>)this.c).headSet(toElement, inclusive));
        }

        @Override
        public E pollLast() {
            throw new UnsupportedOperationException(
                unmodifable("E java.util.NavigableSet<E>.pollLast()")
            );
        }

        @Override
        public E pollFirst() {
            throw new UnsupportedOperationException(
                unmodifable("E java.util.NavigableSet<E>.pollFirst()")
            );
        }
    }

    private static class UnmodifiableXNavigableSetWithSerializable<E> extends UnmodifiableXNavigableSet<E> implements Serializable {

        private static final long serialVersionUID = -1420140685L;

        UnmodifiableXNavigableSetWithSerializable(XNavigableSet<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXNavigableSetWithSerializable<E>((XNavigableSet<E>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (XNavigableSet<E>)in.readObject();
        }
    }

    private static class UnmodifiableXSortedMapXSortedKeySetView<K> extends UnmodifiableXSortedSetXSortedSetView<K> implements XSortedMap.XSortedKeySetView<K> {

        UnmodifiableXSortedMapXSortedKeySetView(XSortedMap.XSortedKeySetView<K> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXSortedMapXSortedKeySetView<K>((XSortedMap.XSortedKeySetView<K>)obj);
        }

        @Override
        public XSortedMap.XSortedKeySetView<K> subSet(K fromKey, K toKey) {
             return MACollections.unmodifiable(((XSortedMap.XSortedKeySetView<K>)this.c).subSet(fromKey, toKey));
        }

        @Override
        public XSortedMap.XSortedKeySetView<K> headSet(K toKey) {
             return MACollections.unmodifiable(((XSortedMap.XSortedKeySetView<K>)this.c).headSet(toKey));
        }

        @Override
        public XSortedMap.XSortedKeySetView<K> tailSet(K fromKey) {
             return MACollections.unmodifiable(((XSortedMap.XSortedKeySetView<K>)this.c).tailSet(fromKey));
        }
    }

    private static class UnmodifiableXSortedSetXSortedSetView<E> extends UnmodifiableXSortedSet<E> implements XSortedSet.XSortedSetView<E> {

        UnmodifiableXSortedSetXSortedSetView(XSortedSet.XSortedSetView<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXSortedSetXSortedSetView<E>((XSortedSet.XSortedSetView<E>)obj);
        }

        @Override
        public ViewInfo viewInfo() {
            return ((XSortedSet.XSortedSetView<E>)this.c).viewInfo();
        }
    }

    private static class UnmodifiableXSortedSet<E> extends UnmodifiableXSet<E> implements XSortedSet<E> {

        UnmodifiableXSortedSet(XSortedSet<E> c) {
            super(c);
        }

        @Deprecated //Only for deserialization
        UnmodifiableXSortedSet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXSortedSet<E>((XSortedSet<E>)obj);
        }

        @Override
        public XSortedSet.XSortedSetView<E> tailSet(E fromElement) {
             return MACollections.unmodifiable(((XSortedSet<E>)this.c).tailSet(fromElement));
        }

        @Override
        public XSortedSet.XSortedSetView<E> subSet(E fromElement, E toElement) {
             return MACollections.unmodifiable(((XSortedSet<E>)this.c).subSet(fromElement, toElement));
        }

        @Override
        public E last() {
            return ((XSortedSet<E>)this.c).last();
        }

        @Override
        public E first() {
            return ((XSortedSet<E>)this.c).first();
        }

        @Override
        public Comparator<? super E> comparator() {
            return ((XSortedSet<E>)this.c).comparator();
        }

        @Override
        public XSortedSet.XSortedSetView<E> headSet(E toElement) {
             return MACollections.unmodifiable(((XSortedSet<E>)this.c).headSet(toElement));
        }
    }

    private static class UnmodifiableXSortedSetWithSerializable<E> extends UnmodifiableXSortedSet<E> implements Serializable {

        private static final long serialVersionUID = -1046603157L;

        UnmodifiableXSortedSetWithSerializable(XSortedSet<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXSortedSetWithSerializable<E>((XSortedSet<E>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (XSortedSet<E>)in.readObject();
        }
    }

    private static class UnmodifiableXMapXKeySetView<K> extends UnmodifiableXSet<K> implements XMap.XKeySetView<K> {

        UnmodifiableXMapXKeySetView(XMap.XKeySetView<K> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXMapXKeySetView<K>((XMap.XKeySetView<K>)obj);
        }

        @Override
        public ViewInfo viewInfo() {
            return ((XMap.XKeySetView<K>)this.c).viewInfo();
        }
    }

    private static class UnmodifiableXMapXEntrySetView<K, V> extends UnmodifiableXSet<Map.Entry<K, V>> implements XMap.XEntrySetView<K, V> {

        UnmodifiableXMapXEntrySetView(XMap.XEntrySetView<K, V> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXMapXEntrySetView<K, V>((XMap.XEntrySetView<K, V>)obj);
        }

        @SuppressWarnings("unchecked")
        @Override
        public <T> T[] toArray(T[] a) {
            Object[] arr = this.c.toArray(a.length==0 ? a : (Object[])Array.newInstance(a.getClass().getComponentType(), 0));
            for (int i = arr.length - 1; i >= 0; i--) {
                arr[i] = MACollections.unmodifiable((XMap.XEntry<K, V>)arr[i]);
            }
            if (arr.length > a.length) {
                return (T[])arr;
            }
            System.arraycopy(arr, 0, a, 0, arr.length);
            if (a.length > arr.length) {
                a[arr.length] = null;
            }
            return a;
        }

        @Deprecated
        @Override
        public boolean add(Map.Entry<K, V> entry) {
            throw new UnsupportedOperationException(
                notSupported("boolean org.babyfish.collection.XMap.XEntrySetView<K, V>.add(java.util.Map.Entry<K, V>)")
            );
        }

        @SuppressWarnings("unchecked")
        @Override
        public ViewInfo viewInfo() {
            return ((XMap.XEntrySetView<K, V>)this.c).viewInfo();
        }

        @SuppressWarnings("unchecked")
        @Override
        public Object[] toArray() {
            Object[] arr = this.c.toArray();
            for (int i = arr.length - 1; i >= 0; i--) {
                arr[i] = MACollections.unmodifiable((XMap.XEntry<K, V>)arr[i]);
            }
            return arr;
        }

        @SuppressWarnings("unchecked")
        @Override
        public XMap.XEntrySetView.XEntrySetIterator<K, V> iterator() {
             return MACollections.unmodifiable(((XMap.XEntrySetView<K, V>)this.c).iterator());
        }
    }

    private static class UnmodifiableXSet<E> extends UnmodifiableXCollection<E> implements XSet<E> {

        UnmodifiableXSet(XSet<E> c) {
            super(c);
        }

        @Deprecated //Only for deserialization
        UnmodifiableXSet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXSet<E>((XSet<E>)obj);
        }

        @Override
        public ReplacementRule replacementRule() {
            return ((XSet<E>)this.c).replacementRule();
        }
    }

    private static class UnmodifiableXSetWithSerializable<E> extends UnmodifiableXSet<E> implements Serializable {

        private static final long serialVersionUID = 4044646332967226766L;

        UnmodifiableXSetWithSerializable(XSet<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXSetWithSerializable<E>((XSet<E>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (XSet<E>)in.readObject();
        }
    }

    private static class UnmodifiableXMapXValuesView<V> extends UnmodifiableXCollection<V> implements XMap.XValuesView<V> {

        UnmodifiableXMapXValuesView(XMap.XValuesView<V> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXMapXValuesView<V>((XMap.XValuesView<V>)obj);
        }

        @Override
        public ViewInfo viewInfo() {
            return ((XMap.XValuesView<V>)this.c).viewInfo();
        }
    }

    private static class UnmodifiableXCollection<E> extends UnmodifiableCollection<E> implements XCollection<E> {

        UnmodifiableXCollection(XCollection<E> c) {
            super(c);
        }

        @Deprecated //Only for deserialization
        UnmodifiableXCollection() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXCollection<E>((XCollection<E>)obj);
        }

        @Override
        public XCollection.XIterator<E> iterator() {
             return MACollections.unmodifiable(((XCollection<E>)this.c).iterator());
        }

        @Override
        public UnifiedComparator<? super E> unifiedComparator() {
            return ((XCollection<E>)this.c).unifiedComparator();
        }

        @Override
        public boolean isReadWriteLockSupported() {
            return ((XCollection<E>)this.c).isReadWriteLockSupported();
        }

        @Override
        public void validate(E e) {
            ((XCollection<E>)this.c).validate(e);
        }

        @Override
        public void removeValidator(Validator<E> validator) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.XCollection<E>.removeValidator(org.babyfish.validator.Validator<E>)")
            );
        }

        @Override
        public void addValidator(Validator<E> validator) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.XCollection<E>.addValidator(org.babyfish.validator.Validator<E>)")
            );
        }
    }

    private static class UnmodifiableXCollectionWithSerializable<E> extends UnmodifiableXCollection<E> implements Serializable {

        private static final long serialVersionUID = -625144132L;

        UnmodifiableXCollectionWithSerializable(XCollection<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXCollectionWithSerializable<E>((XCollection<E>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (XCollection<E>)in.readObject();
        }
    }

    private static class UnmodifiableStandardMapEntrySet<K, V> extends UnmodifiableSet<Map.Entry<K, V>> implements StandardMap.EntrySet<K, V> {

        UnmodifiableStandardMapEntrySet(StandardMap.EntrySet<K, V> c) {
            super(c);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        UnmodifiableStandardMapEntrySet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableStandardMapEntrySet<K, V>((StandardMap.EntrySet<K, V>)obj);
        }

        @SuppressWarnings("unchecked")
        @Override
        public Object[] toArray() {
            Object[] arr = this.c.toArray();
            for (int i = arr.length - 1; i >= 0; i--) {
                arr[i] = MACollections.unmodifiable((Map.Entry<K, V>)arr[i]);
            }
            return arr;
        }

        @SuppressWarnings("unchecked")
        @Override
        public <T> T[] toArray(T[] a) {
            Object[] arr = this.c.toArray(a.length==0 ? a : (Object[])Array.newInstance(a.getClass().getComponentType(), 0));
            for (int i = arr.length - 1; i >= 0; i--) {
                arr[i] = MACollections.unmodifiable((Map.Entry<K, V>)arr[i]);
            }
            if (arr.length > a.length) {
                return (T[])arr;
            }
            System.arraycopy(arr, 0, a, 0, arr.length);
            if (a.length > arr.length) {
                a[arr.length] = null;
            }
            return a;
        }

        @SuppressWarnings("unchecked")
        @Override
        public StandardMap.EntrySet.EntryIterator<K, V> iterator() {
             return MACollections.unmodifiable(((StandardMap.EntrySet<K, V>)this.c).iterator());
        }
    }

    private static class UnmodifiableStandardMapEntrySetWithSerializable<K, V> extends UnmodifiableStandardMapEntrySet<K, V> implements Serializable {

        private static final long serialVersionUID = -4002991698622064899L;

        UnmodifiableStandardMapEntrySetWithSerializable(StandardMap.EntrySet<K, V> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableStandardMapEntrySetWithSerializable<K, V>((StandardMap.EntrySet<K, V>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (StandardMap.EntrySet<K, V>)in.readObject();
        }
    }

    private static class UnmodifiableList<E> extends UnmodifiableCollection<E> implements List<E> {

        UnmodifiableList(List<E> c) {
            super(c);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        UnmodifiableList() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableList<E>((List<E>)obj);
        }

        @Override
        public int indexOf(Object o) {
            return ((List<E>)this.c).indexOf(o);
        }

        @Override
        public int lastIndexOf(Object o) {
            return ((List<E>)this.c).lastIndexOf(o);
        }

        @Override
        public List<E> subList(int from, int to) {
             return MACollections.unmodifiable(((List<E>)this.c).subList(from, to));
        }

        @Override
        public E set(int index, E e) {
            throw new UnsupportedOperationException(
                unmodifable("E java.util.List<E>.set(int, E)")
            );
        }

        @Override
        public ListIterator<E> listIterator() {
             return MACollections.unmodifiable(((List<E>)this.c).listIterator());
        }

        @Override
        public E get(int index) {
            return ((List<E>)this.c).get(index);
        }

        @Override
        public ListIterator<E> listIterator(int index) {
             return MACollections.unmodifiable(((List<E>)this.c).listIterator(index));
        }

        @Override
        public E remove(int index) {
            throw new UnsupportedOperationException(
                unmodifable("E java.util.List<E>.remove(int)")
            );
        }

        @Override
        public void add(int index, E e) {
            throw new UnsupportedOperationException(
                unmodifable("void java.util.List<E>.add(int, E)")
            );
        }

        @Override
        public boolean addAll(int index, Collection<? extends E> c) {
            throw new UnsupportedOperationException(
                unmodifable("boolean java.util.List<E>.addAll(int, java.util.Collection<? extends E>)")
            );
        }
    }

    private static class UnmodifiableListWithSerializable<E> extends UnmodifiableList<E> implements Serializable {

        private static final long serialVersionUID = -1172427462L;

        UnmodifiableListWithSerializable(List<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableListWithSerializable<E>((List<E>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (List<E>)in.readObject();
        }
    }

    private static class UnmodifiableListWithRandomAccess<E> extends UnmodifiableList<E> implements RandomAccess {

        UnmodifiableListWithRandomAccess(List<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableListWithRandomAccess<E>((List<E>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (List<E>)in.readObject();
        }
    }


    private static class UnmodifiableListWithSerializableRandomAccess<E> extends UnmodifiableList<E> implements Serializable, RandomAccess {

        private static final long serialVersionUID = -1172427462L;

        UnmodifiableListWithSerializableRandomAccess(List<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableListWithSerializableRandomAccess<E>((List<E>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (List<E>)in.readObject();
        }
    }

    private static class UnmodifiableNavigableSet<E> extends UnmodifiableSortedSet<E> implements NavigableSet<E> {

        UnmodifiableNavigableSet(NavigableSet<E> c) {
            super(c);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        UnmodifiableNavigableSet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableNavigableSet<E>((NavigableSet<E>)obj);
        }

        @Override
        public NavigableSet<E> tailSet(E fromElement, boolean inclusive) {
             return MACollections.unmodifiable(((NavigableSet<E>)this.c).tailSet(fromElement, inclusive));
        }

        @Override
        public E floor(E e) {
            return ((NavigableSet<E>)this.c).floor(e);
        }

        @Override
        public E ceiling(E e) {
            return ((NavigableSet<E>)this.c).ceiling(e);
        }

        @Override
        public E higher(E e) {
            return ((NavigableSet<E>)this.c).higher(e);
        }

        @Override
        public NavigableSet<E> headSet(E toElement, boolean inclusive) {
             return MACollections.unmodifiable(((NavigableSet<E>)this.c).headSet(toElement, inclusive));
        }

        @Override
        public Iterator<E> descendingIterator() {
             return MACollections.unmodifiable(((NavigableSet<E>)this.c).descendingIterator());
        }

        @Override
        public NavigableSet<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {
             return MACollections.unmodifiable(((NavigableSet<E>)this.c).subSet(fromElement, fromInclusive, toElement, toInclusive));
        }

        @Override
        public E lower(E e) {
            return ((NavigableSet<E>)this.c).lower(e);
        }

        @Override
        public E pollLast() {
            throw new UnsupportedOperationException(
                unmodifable("E java.util.NavigableSet<E>.pollLast()")
            );
        }

        @Override
        public NavigableSet<E> descendingSet() {
             return MACollections.unmodifiable(((NavigableSet<E>)this.c).descendingSet());
        }

        @Override
        public E pollFirst() {
            throw new UnsupportedOperationException(
                unmodifable("E java.util.NavigableSet<E>.pollFirst()")
            );
        }
    }

    private static class UnmodifiableNavigableSetWithSerializable<E> extends UnmodifiableNavigableSet<E> implements Serializable {

        private static final long serialVersionUID = -2749431026951435727L;

        UnmodifiableNavigableSetWithSerializable(NavigableSet<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableNavigableSetWithSerializable<E>((NavigableSet<E>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (NavigableSet<E>)in.readObject();
        }
    }

    private static class UnmodifiableSortedSet<E> extends UnmodifiableSet<E> implements SortedSet<E> {

        UnmodifiableSortedSet(SortedSet<E> c) {
            super(c);
        }

        @Deprecated //Only for deserialization
        UnmodifiableSortedSet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableSortedSet<E>((SortedSet<E>)obj);
        }

        @Override
        public SortedSet<E> tailSet(E fromElement) {
             return MACollections.unmodifiable(((SortedSet<E>)this.c).tailSet(fromElement));
        }

        @Override
        public SortedSet<E> subSet(E fromElement, E toElement) {
             return MACollections.unmodifiable(((SortedSet<E>)this.c).subSet(fromElement, toElement));
        }

        @Override
        public E last() {
            return ((SortedSet<E>)this.c).last();
        }

        @Override
        public E first() {
            return ((SortedSet<E>)this.c).first();
        }

        @Override
        public Comparator<? super E> comparator() {
            return ((SortedSet<E>)this.c).comparator();
        }

        @Override
        public SortedSet<E> headSet(E toElement) {
             return MACollections.unmodifiable(((SortedSet<E>)this.c).headSet(toElement));
        }
    }

    private static class UnmodifiableSortedSetWithSerializable<E> extends UnmodifiableSortedSet<E> implements Serializable {

        private static final long serialVersionUID = 8130727168585586797L;

        UnmodifiableSortedSetWithSerializable(SortedSet<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableSortedSetWithSerializable<E>((SortedSet<E>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (SortedSet<E>)in.readObject();
        }
    }

    private static class UnmodifiableSet<E> extends UnmodifiableCollection<E> implements Set<E> {

        UnmodifiableSet(Set<E> c) {
            super(c);
        }

        @Deprecated //Only for deserialization
        UnmodifiableSet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableSet<E>((Set<E>)obj);
        }
    }

    private static class UnmodifiableSetWithSerializable<E> extends UnmodifiableSet<E> implements Serializable {

        private static final long serialVersionUID = -1226607344L;

        UnmodifiableSetWithSerializable(Set<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableSetWithSerializable<E>((Set<E>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (Set<E>)in.readObject();
        }
    }

    private static class UnmodifiableCollection<E> extends UnmodifiableProxy implements Collection<E> {

        Collection<E> c;

        UnmodifiableCollection(Collection<E> c) {
            this.c = c;
        }

        @Deprecated //Only for deserialization
        UnmodifiableCollection() {
        }

        @Override
        Object getInnerObject() {
            return this.c;
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableCollection<E>((Collection<E>)obj);
        }

        @Override
        public String toString() {
            return this.c.toString();
        }

        @Override
        public boolean isEmpty() {
            return this.c.isEmpty();
        }

        @Override
        public boolean retainAll(Collection<? extends Object> c) {
            throw new UnsupportedOperationException(
                unmodifable("boolean java.util.Collection<E>.retainAll(java.util.Collection<?>)")
            );
        }

        @Override
        public boolean remove(Object o) {
            throw new UnsupportedOperationException(
                unmodifable("boolean java.util.Collection<E>.remove(java.lang.Object)")
            );
        }

        @Override
        public void clear() {
            throw new UnsupportedOperationException(
                unmodifable("void java.util.Collection<E>.clear()")
            );
        }

        @Override
        public boolean contains(Object o) {
            return this.c.contains(o);
        }

        @Override
        public Iterator<E> iterator() {
             return MACollections.unmodifiable(this.c.iterator());
        }

        @Override
        public boolean removeAll(Collection<? extends Object> c) {
            throw new UnsupportedOperationException(
                unmodifable("boolean java.util.Collection<E>.removeAll(java.util.Collection<?>)")
            );
        }

        @Override
        public boolean addAll(Collection<? extends E> c) {
            throw new UnsupportedOperationException(
                unmodifable("boolean java.util.Collection<E>.addAll(java.util.Collection<? extends E>)")
            );
        }

        @Override
        public Object[] toArray() {
            return this.c.toArray();
        }

        @Override
        public boolean add(E e) {
            throw new UnsupportedOperationException(
                unmodifable("boolean java.util.Collection<E>.add(E)")
            );
        }

        @Override
        public int hashCode() {
            return this.c.hashCode();
        }

        @Override
        public <T> T[] toArray(T[] a) {
            return this.c.toArray(a);
        }

        @Override
        public boolean equals(Object obj) {
            return this.c.equals(obj);
        }

        @Override
        public int size() {
            return this.c.size();
        }

        @Override
        public boolean containsAll(Collection<? extends Object> c) {
            return this.c.containsAll(c);
        }
    }

    private static class UnmodifiableCollectionWithSerializable<E> extends UnmodifiableCollection<E> implements Serializable {

        private static final long serialVersionUID = -2070310662L;

        UnmodifiableCollectionWithSerializable(Collection<E> c) {
            super(c);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableCollectionWithSerializable<E>((Collection<E>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (Collection<E>)in.readObject();
        }
    }

    private static class UnmodifiableMAMapMAValuesViewMAValuesIterator<K, V> extends UnmodifiableMACollectionMAIterator<V> implements MAMap.MAValuesView.MAValuesIterator<K, V> {

        UnmodifiableMAMapMAValuesViewMAValuesIterator(MAMap.MAValuesView.MAValuesIterator<K, V> itr) {
            super(itr);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMAMapMAValuesViewMAValuesIterator<K, V>((MAMap.MAValuesView.MAValuesIterator<K, V>)obj);
        }

        @Override
        public void addValuesElementListener(ValuesElementListener<? super K, ? super V> listener) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.event.ValuesElementModificationAware<K, V>.addValuesElementListener(org.babyfish.collection.event.ValuesElementListener<? super K, ? super V>)")
            );
        }

        @Override
        public void removeValuesElementListener(ValuesElementListener<? super K, ? super V> listener) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.event.ValuesElementModificationAware<K, V>.removeValuesElementListener(org.babyfish.collection.event.ValuesElementListener<? super K, ? super V>)")
            );
        }
    }

    private static class UnmodifiableMAMapMAEntrySetViewMAEntrySetIterator<K, V> extends UnmodifiableMACollectionMAIterator<Map.Entry<K, V>> implements MAMap.MAEntrySetView.MAEntrySetIterator<K, V> {

        UnmodifiableMAMapMAEntrySetViewMAEntrySetIterator(MAMap.MAEntrySetView.MAEntrySetIterator<K, V> itr) {
            super(itr);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMAMapMAEntrySetViewMAEntrySetIterator<K, V>((MAMap.MAEntrySetView.MAEntrySetIterator<K, V>)obj);
        }

        @SuppressWarnings("unchecked")
        @Override
        public MAMap.MAEntry<K, V> next() {
             return MACollections.unmodifiable(((MAMap.MAEntrySetView.MAEntrySetIterator<K, V>)this.itr).next());
        }
    }

    private static class UnmodifiableMAListMAListIterator<E> extends UnmodifiableMACollectionMAIterator<E> implements MAList.MAListIterator<E> {

        UnmodifiableMAListMAListIterator(MAList.MAListIterator<E> itr) {
            super(itr);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMAListMAListIterator<E>((MAList.MAListIterator<E>)obj);
        }

        @Override
        public void removeListElementListener(ListElementListener<? super E> listener) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.MAList.MAListIterator<E>.removeListElementListener(org.babyfish.collection.event.ListElementListener<? super E>)")
            );
        }

        @Override
        public void add(E e) {
            throw new UnsupportedOperationException(
                unmodifable("void java.util.ListIterator<E>.add(E)")
            );
        }

        @Override
        public boolean hasPrevious() {
            return ((MAList.MAListIterator<E>)this.itr).hasPrevious();
        }

        @Override
        public int previousIndex() {
            return ((MAList.MAListIterator<E>)this.itr).previousIndex();
        }

        @Override
        public void addListElementListener(ListElementListener<? super E> listener) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.MAList.MAListIterator<E>.addListElementListener(org.babyfish.collection.event.ListElementListener<? super E>)")
            );
        }

        @Override
        public E previous() {
            return ((MAList.MAListIterator<E>)this.itr).previous();
        }

        @Override
        public int nextIndex() {
            return ((MAList.MAListIterator<E>)this.itr).nextIndex();
        }

        @Override
        public void set(E e) {
            throw new UnsupportedOperationException(
                unmodifable("void java.util.ListIterator<E>.set(E)")
            );
        }
    }

    private static class UnmodifiableMAMapMAKeySetViewMAKeySetIterator<K, V> extends UnmodifiableMACollectionMAIterator<K> implements MAMap.MAKeySetView.MAKeySetIterator<K, V> {

        UnmodifiableMAMapMAKeySetViewMAKeySetIterator(MAMap.MAKeySetView.MAKeySetIterator<K, V> itr) {
            super(itr);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMAMapMAKeySetViewMAKeySetIterator<K, V>((MAMap.MAKeySetView.MAKeySetIterator<K, V>)obj);
        }

        @Override
        public void removeKeySetElementListener(KeySetElementListener<? super K, ? super V> listener) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.removeKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
            );
        }

        @Override
        public void addKeySetElementListener(KeySetElementListener<? super K, ? super V> listener) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.addKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
            );
        }
    }

    private static class UnmodifiableMACollectionMAIterator<E> extends UnmodifiableXCollectionXIterator<E> implements MACollection.MAIterator<E> {

        UnmodifiableMACollectionMAIterator(MACollection.MAIterator<E> itr) {
            super(itr);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMACollectionMAIterator<E>((MACollection.MAIterator<E>)obj);
        }

        @Override
        public void addElementListener(ElementListener<? super E> listener) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.MACollection.MAIterator<E>.addElementListener(org.babyfish.collection.event.ElementListener<? super E>)")
            );
        }

        @Override
        public void removeElementListener(ElementListener<? super E> listener) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.MACollection.MAIterator<E>.removeElementListener(org.babyfish.collection.event.ElementListener<? super E>)")
            );
        }
    }

    private static class UnmodifiableXListXListIterator<E> extends UnmodifiableXCollectionXIterator<E> implements XList.XListIterator<E> {

        UnmodifiableXListXListIterator(XList.XListIterator<E> itr) {
            super(itr);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXListXListIterator<E>((XList.XListIterator<E>)obj);
        }

        @Override
        public void add(E e) {
            throw new UnsupportedOperationException(
                unmodifable("void java.util.ListIterator<E>.add(E)")
            );
        }

        @Override
        public boolean hasPrevious() {
            return ((XList.XListIterator<E>)this.itr).hasPrevious();
        }

        @Override
        public E previous() {
            return ((XList.XListIterator<E>)this.itr).previous();
        }

        @Override
        public int previousIndex() {
            return ((XList.XListIterator<E>)this.itr).previousIndex();
        }

        @Override
        public int nextIndex() {
            return ((XList.XListIterator<E>)this.itr).nextIndex();
        }

        @Override
        public void set(E e) {
            throw new UnsupportedOperationException(
                unmodifable("void java.util.ListIterator<E>.set(E)")
            );
        }
    }

    private static class UnmodifiableXMapXEntrySetViewXEntrySetIterator<K, V> extends UnmodifiableXCollectionXIterator<Map.Entry<K, V>> implements XMap.XEntrySetView.XEntrySetIterator<K, V> {

        UnmodifiableXMapXEntrySetViewXEntrySetIterator(XMap.XEntrySetView.XEntrySetIterator<K, V> itr) {
            super(itr);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXMapXEntrySetViewXEntrySetIterator<K, V>((XMap.XEntrySetView.XEntrySetIterator<K, V>)obj);
        }

        @SuppressWarnings("unchecked")
        @Override
        public XMap.XEntry<K, V> next() {
             return MACollections.unmodifiable(((XMap.XEntrySetView.XEntrySetIterator<K, V>)this.itr).next());
        }
    }

    private static class UnmodifiableXCollectionXIterator<E> extends UnmodifiableIterator<E> implements XCollection.XIterator<E> {

        UnmodifiableXCollectionXIterator(XCollection.XIterator<E> itr) {
            super(itr);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXCollectionXIterator<E>((XCollection.XIterator<E>)obj);
        }

        @Override
        public UnifiedComparator<? super E> unifiedComparator() {
            return ((XCollection.XIterator<E>)this.itr).unifiedComparator();
        }

        @Override
        public ViewInfo viewInfo() {
            return ((XCollection.XIterator<E>)this.itr).viewInfo();
        }

        @Override
        public boolean isReadWriteLockSupported() {
            return ((XCollection.XIterator<E>)this.itr).isReadWriteLockSupported();
        }
    }

    private static class UnmodifiableStandardMapEntrySetEntryIterator<K, V> extends UnmodifiableIterator<Map.Entry<K, V>> implements StandardMap.EntrySet.EntryIterator<K, V> {

        UnmodifiableStandardMapEntrySetEntryIterator(StandardMap.EntrySet.EntryIterator<K, V> itr) {
            super(itr);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        UnmodifiableStandardMapEntrySetEntryIterator() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableStandardMapEntrySetEntryIterator<K, V>((StandardMap.EntrySet.EntryIterator<K, V>)obj);
        }

        @SuppressWarnings("unchecked")
        @Override
        public Map.Entry<K, V> next() {
             return MACollections.unmodifiable(((StandardMap.EntrySet.EntryIterator<K, V>)this.itr).next());
        }
    }

    private static class UnmodifiableStandardMapEntrySetEntryIteratorWithSerializable<K, V> extends UnmodifiableStandardMapEntrySetEntryIterator<K, V> implements Serializable {

        private static final long serialVersionUID = 655665988181340025L;

        UnmodifiableStandardMapEntrySetEntryIteratorWithSerializable(StandardMap.EntrySet.EntryIterator<K, V> itr) {
            super(itr);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableStandardMapEntrySetEntryIteratorWithSerializable<K, V>((StandardMap.EntrySet.EntryIterator<K, V>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.itr);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.itr = (StandardMap.EntrySet.EntryIterator<K, V>)in.readObject();
        }
    }

    private static class UnmodifiableListIterator<E> extends UnmodifiableIterator<E> implements ListIterator<E> {

        UnmodifiableListIterator(ListIterator<E> itr) {
            super(itr);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        UnmodifiableListIterator() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableListIterator<E>((ListIterator<E>)obj);
        }

        @Override
        public void add(E e) {
            throw new UnsupportedOperationException(
                unmodifable("void java.util.ListIterator<E>.add(E)")
            );
        }

        @Override
        public boolean hasPrevious() {
            return ((ListIterator<E>)this.itr).hasPrevious();
        }

        @Override
        public E previous() {
            return ((ListIterator<E>)this.itr).previous();
        }

        @Override
        public int previousIndex() {
            return ((ListIterator<E>)this.itr).previousIndex();
        }

        @Override
        public int nextIndex() {
            return ((ListIterator<E>)this.itr).nextIndex();
        }

        @Override
        public void set(E e) {
            throw new UnsupportedOperationException(
                unmodifable("void java.util.ListIterator<E>.set(E)")
            );
        }
    }

    private static class UnmodifiableListIteratorWithSerializable<E> extends UnmodifiableListIterator<E> implements Serializable {

        private static final long serialVersionUID = 5755468139524364524L;

        UnmodifiableListIteratorWithSerializable(ListIterator<E> itr) {
            super(itr);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableListIteratorWithSerializable<E>((ListIterator<E>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.itr);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.itr = (ListIterator<E>)in.readObject();
        }
    }

    private static class UnmodifiableIterator<E> extends UnmodifiableProxy implements Iterator<E> {

        Iterator<E> itr;

        UnmodifiableIterator(Iterator<E> itr) {
            this.itr = itr;
        }

        @Deprecated //Only for deserialization
        UnmodifiableIterator() {
        }

        @Override
        Object getInnerObject() {
            return this.itr;
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableIterator<E>((Iterator<E>)obj);
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException(
                unmodifable("void java.util.Iterator<E>.remove()")
            );
        }

        @Override
        public boolean hasNext() {
            return this.itr.hasNext();
        }

        @Override
        public E next() {
            return this.itr.next();
        }
    }

    private static class UnmodifiableIteratorWithSerializable<E> extends UnmodifiableIterator<E> implements Serializable {

        private static final long serialVersionUID = -976492054L;

        UnmodifiableIteratorWithSerializable(Iterator<E> itr) {
            super(itr);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableIteratorWithSerializable<E>((Iterator<E>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.itr);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.itr = (Iterator<E>)in.readObject();
        }
    }

    private static class UnmodifiableMAMapMAEntry<K, V> extends UnmodifiableXMapXEntry<K, V> implements MAMap.MAEntry<K, V> {

        UnmodifiableMAMapMAEntry(MAMap.MAEntry<K, V> e) {
            super(e);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMAMapMAEntry<K, V>((MAMap.MAEntry<K, V>)obj);
        }

        @Override
        public void removeElementListener(ElementListener<? super V> listener) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.event.ElementModificationAware<V>.removeElementListener(org.babyfish.collection.event.ElementListener<? super V>)")
            );
        }

        @Override
        public void addEntryElementListener(EntryElementListener<? super K, ? super V> listener) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.event.EntryElementModificationAware<K, V>.addEntryElementListener(org.babyfish.collection.event.EntryElementListener<? super K, ? super V>)")
            );
        }

        @Override
        public void addElementListener(ElementListener<? super V> listener) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.event.ElementModificationAware<V>.addElementListener(org.babyfish.collection.event.ElementListener<? super V>)")
            );
        }

        @Override
        public void removeEntryElementListener(EntryElementListener<? super K, ? super V> listener) {
            throw new UnsupportedOperationException(
                unmodifable("void org.babyfish.collection.event.EntryElementModificationAware<K, V>.removeEntryElementListener(org.babyfish.collection.event.EntryElementListener<? super K, ? super V>)")
            );
        }
    }

    private static class UnmodifiableXMapXEntry<K, V> extends UnmodifiableMapEntry<K, V> implements XMap.XEntry<K, V> {

        UnmodifiableXMapXEntry(XMap.XEntry<K, V> e) {
            super(e);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableXMapXEntry<K, V>((XMap.XEntry<K, V>)obj);
        }

        @Override
        public UnifiedComparator<? super K> keyUnifiedComparator() {
            return ((XMap.XEntry<K, V>)this.e).keyUnifiedComparator();
        }

        @Override
        public UnifiedComparator<? super Map.Entry<K, V>> unifiedComparator() {
            return ((XMap.XEntry<K, V>)this.e).unifiedComparator();
        }

        @Override
        public ViewInfo viewInfo() {
            return ((XMap.XEntry<K, V>)this.e).viewInfo();
        }

        @Override
        public boolean isAlive() {
            return ((XMap.XEntry<K, V>)this.e).isAlive();
        }

        @Override
        public UnifiedComparator<? super V> valueUnifiedComparator() {
            return ((XMap.XEntry<K, V>)this.e).valueUnifiedComparator();
        }

        @Override
        public boolean isReadWriteLockSupported() {
            return ((XMap.XEntry<K, V>)this.e).isReadWriteLockSupported();
        }
    }

    private static class UnmodifiableMapEntry<K, V> extends UnmodifiableProxy implements Map.Entry<K, V> {

        Map.Entry<K, V> e;

        UnmodifiableMapEntry(Map.Entry<K, V> e) {
            this.e = e;
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        UnmodifiableMapEntry() {
        }

        @Override
        Object getInnerObject() {
            return this.e;
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMapEntry<K, V>((Map.Entry<K, V>)obj);
        }

        @Override
        public String toString() {
            return this.e.toString();
        }

        @Override
        public int hashCode() {
            return this.e.hashCode();
        }

        @Override
        public K getKey() {
            return this.e.getKey();
        }

        @Override
        public V getValue() {
            return this.e.getValue();
        }

        @Override
        public boolean equals(Object obj) {
            return this.e.equals(obj);
        }

        @Override
        public V setValue(V value) {
            throw new UnsupportedOperationException(
                unmodifable("V java.util.Map.Entry<K, V>.setValue(V)")
            );
        }
    }

    private static class UnmodifiableMapEntryWithSerializable<K, V> extends UnmodifiableMapEntry<K, V> implements Serializable {

        private static final long serialVersionUID = -624102146L;

        UnmodifiableMapEntryWithSerializable(Map.Entry<K, V> e) {
            super(e);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new UnmodifiableMapEntryWithSerializable<K, V>((Map.Entry<K, V>)obj);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.e);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.e = (Map.Entry<K, V>)in.readObject();
        }
    }

    private static class LockedMAOrderedMapMAOrderedMapView<K, V> extends LockedMAOrderedMap<K, V> implements MAOrderedMap.MAOrderedMapView<K, V> {

        LockedMAOrderedMapMAOrderedMapView(MAOrderedMap.MAOrderedMapView<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(m, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMAOrderedMapMAOrderedMapView<K, V>((MAOrderedMap.MAOrderedMapView<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public ViewInfo viewInfo() {
            Lock lock;
            if (((MAOrderedMap.MAOrderedMapView<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MAOrderedMap.MAOrderedMapView<K, V>)this.m).viewInfo();
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedMAOrderedMap<K, V> extends LockedMAMap<K, V> implements MAOrderedMap<K, V> {

        LockedMAOrderedMap(MAOrderedMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(m, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockedMAOrderedMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMAOrderedMap<K, V>((MAOrderedMap<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public Map.Entry<K, V> pollLastEntry() {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((MAOrderedMap<K, V>)this.m).pollLastEntry();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public Map.Entry<K, V> pollFirstEntry() {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((MAOrderedMap<K, V>)this.m).pollFirstEntry();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public K firstKey() {
            Lock lock;
            if (((MAOrderedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MAOrderedMap<K, V>)this.m).firstKey();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MAOrderedMap.MAOrderedKeySetView<K, V> descendingKeySet() {
            Lock lock;
            if (((MAOrderedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MAOrderedMap<K, V>)this.m).descendingKeySet(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MAOrderedMap.MAOrderedMapView<K, V> descendingMap() {
            Lock lock;
            if (((MAOrderedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MAOrderedMap<K, V>)this.m).descendingMap(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MAOrderedMap.MAOrderedKeySetView<K, V> keySet() {
            Lock lock;
            if (((MAOrderedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MAOrderedMap<K, V>)this.m).keySet(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public OrderAdjustMode replaceMode() {
            Lock lock;
            if (((MAOrderedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MAOrderedMap<K, V>)this.m).replaceMode();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MAMap.MAEntry<K, V> firstEntry() {
            Lock lock;
            if (((MAOrderedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MAOrderedMap<K, V>)this.m).firstEntry(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public K lastKey() {
            Lock lock;
            if (((MAOrderedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MAOrderedMap<K, V>)this.m).lastKey();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MAMap.MAEntry<K, V> lastEntry() {
            Lock lock;
            if (((MAOrderedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MAOrderedMap<K, V>)this.m).lastEntry(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public V access(K key) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((MAOrderedMap<K, V>)this.m).access(key);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public OrderAdjustMode accessMode() {
            Lock lock;
            if (((MAOrderedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MAOrderedMap<K, V>)this.m).accessMode();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public boolean headAppend() {
            Lock lock;
            if (((MAOrderedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MAOrderedMap<K, V>)this.m).headAppend();
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedMAOrderedMapWithSerializable<K, V> extends LockedMAOrderedMap<K, V> implements Serializable {

        private static final long serialVersionUID = -1437287432L;

        LockedMAOrderedMapWithSerializable(MAOrderedMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(m, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMAOrderedMapWithSerializable<K, V>((MAOrderedMap<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (MAOrderedMap<K, V>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedMANavigableMapMANavigableMapView<K, V> extends LockedMANavigableMap<K, V> implements MANavigableMap.MANavigableMapView<K, V> {

        LockedMANavigableMapMANavigableMapView(MANavigableMap.MANavigableMapView<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(m, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMANavigableMapMANavigableMapView<K, V>((MANavigableMap.MANavigableMapView<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public ViewInfo viewInfo() {
            Lock lock;
            if (((MANavigableMap.MANavigableMapView<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MANavigableMap.MANavigableMapView<K, V>)this.m).viewInfo();
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedMANavigableMap<K, V> extends LockedMASortedMap<K, V> implements MANavigableMap<K, V> {

        LockedMANavigableMap(MANavigableMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(m, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockedMANavigableMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMANavigableMap<K, V>((MANavigableMap<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public MANavigableMap.MANavigableKeySetView<K, V> descendingKeySet() {
            Lock lock;
            if (((MANavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableMap<K, V>)this.m).descendingKeySet(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MAMap.MAEntry<K, V> lowerEntry(K key) {
            Lock lock;
            if (((MANavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableMap<K, V>)this.m).lowerEntry(key), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MANavigableMap.MANavigableKeySetView<K, V> navigableKeySet() {
            Lock lock;
            if (((MANavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableMap<K, V>)this.m).navigableKeySet(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public K ceilingKey(K key) {
            Lock lock;
            if (((MANavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MANavigableMap<K, V>)this.m).ceilingKey(key);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MANavigableMap.MANavigableMapView<K, V> headMap(K toKey, boolean inclusive) {
            Lock lock;
            if (((MANavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableMap<K, V>)this.m).headMap(toKey, inclusive), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MANavigableMap.MANavigableMapView<K, V> descendingMap() {
            Lock lock;
            if (((MANavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableMap<K, V>)this.m).descendingMap(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public K higherKey(K key) {
            Lock lock;
            if (((MANavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MANavigableMap<K, V>)this.m).higherKey(key);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MANavigableMap.MANavigableKeySetView<K, V> keySet() {
            Lock lock;
            if (((MANavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableMap<K, V>)this.m).keySet(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public Map.Entry<K, V> pollLastEntry() {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((MANavigableMap<K, V>)this.m).pollLastEntry();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public Map.Entry<K, V> pollFirstEntry() {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((MANavigableMap<K, V>)this.m).pollFirstEntry();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MANavigableMap.MANavigableMapView<K, V> tailMap(K fromKey, boolean inclusive) {
            Lock lock;
            if (((MANavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableMap<K, V>)this.m).tailMap(fromKey, inclusive), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MAMap.MAEntry<K, V> floorEntry(K key) {
            Lock lock;
            if (((MANavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableMap<K, V>)this.m).floorEntry(key), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public K lowerKey(K key) {
            Lock lock;
            if (((MANavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MANavigableMap<K, V>)this.m).lowerKey(key);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MAMap.MAEntry<K, V> ceilingEntry(K key) {
            Lock lock;
            if (((MANavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableMap<K, V>)this.m).ceilingEntry(key), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MAMap.MAEntry<K, V> firstEntry() {
            Lock lock;
            if (((MANavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableMap<K, V>)this.m).firstEntry(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MANavigableMap.MANavigableMapView<K, V> subMap(K fromKey, K toKey) {
            Lock lock;
            if (((MANavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableMap<K, V>)this.m).subMap(fromKey, toKey), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MAMap.MAEntry<K, V> higherEntry(K key) {
            Lock lock;
            if (((MANavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableMap<K, V>)this.m).higherEntry(key), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MAMap.MAEntry<K, V> lastEntry() {
            Lock lock;
            if (((MANavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableMap<K, V>)this.m).lastEntry(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MANavigableMap.MANavigableMapView<K, V> headMap(K toKey) {
            Lock lock;
            if (((MANavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableMap<K, V>)this.m).headMap(toKey), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MANavigableMap.MANavigableMapView<K, V> subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) {
            Lock lock;
            if (((MANavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableMap<K, V>)this.m).subMap(fromKey, fromInclusive, toKey, toInclusive), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MANavigableMap.MANavigableMapView<K, V> tailMap(K fromKey) {
            Lock lock;
            if (((MANavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableMap<K, V>)this.m).tailMap(fromKey), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public K floorKey(K key) {
            Lock lock;
            if (((MANavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MANavigableMap<K, V>)this.m).floorKey(key);
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedMANavigableMapWithSerializable<K, V> extends LockedMANavigableMap<K, V> implements Serializable {

        private static final long serialVersionUID = 7634566256013245002L;

        LockedMANavigableMapWithSerializable(MANavigableMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(m, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMANavigableMapWithSerializable<K, V>((MANavigableMap<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (MANavigableMap<K, V>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedMASortedMapMASortedMapView<K, V> extends LockedMASortedMap<K, V> implements MASortedMap.MASortedMapView<K, V> {

        LockedMASortedMapMASortedMapView(MASortedMap.MASortedMapView<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(m, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMASortedMapMASortedMapView<K, V>((MASortedMap.MASortedMapView<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public ViewInfo viewInfo() {
            Lock lock;
            if (((MASortedMap.MASortedMapView<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MASortedMap.MASortedMapView<K, V>)this.m).viewInfo();
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedMASortedMap<K, V> extends LockedMAMap<K, V> implements MASortedMap<K, V> {

        LockedMASortedMap(MASortedMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(m, readWriteLock, usingInternalLock);
        }

        @Deprecated //Only for deserialization
        LockedMASortedMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMASortedMap<K, V>((MASortedMap<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public MASortedMap.MASortedMapView<K, V> subMap(K fromKey, K toKey) {
            Lock lock;
            if (((MASortedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MASortedMap<K, V>)this.m).subMap(fromKey, toKey), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public K firstKey() {
            Lock lock;
            if (((MASortedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MASortedMap<K, V>)this.m).firstKey();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MASortedMap.MASortedMapView<K, V> headMap(K toKey) {
            Lock lock;
            if (((MASortedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MASortedMap<K, V>)this.m).headMap(toKey), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public K lastKey() {
            Lock lock;
            if (((MASortedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MASortedMap<K, V>)this.m).lastKey();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MASortedMap.MASortedKeySetView<K, V> keySet() {
            Lock lock;
            if (((MASortedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MASortedMap<K, V>)this.m).keySet(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MASortedMap.MASortedMapView<K, V> tailMap(K fromKey) {
            Lock lock;
            if (((MASortedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MASortedMap<K, V>)this.m).tailMap(fromKey), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public Comparator<? super K> comparator() {
            Lock lock;
            if (((MASortedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MASortedMap<K, V>)this.m).comparator();
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedMASortedMapWithSerializable<K, V> extends LockedMASortedMap<K, V> implements Serializable {

        private static final long serialVersionUID = -199173332L;

        LockedMASortedMapWithSerializable(MASortedMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(m, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMASortedMapWithSerializable<K, V>((MASortedMap<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (MASortedMap<K, V>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedMAMap<K, V> extends LockedXMap<K, V> implements MAMap<K, V> {

        LockedMAMap(MAMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(m, readWriteLock, usingInternalLock);
        }

        @Deprecated //Only for deserialization
        LockedMAMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMAMap<K, V>((MAMap<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public void addMapElementListener(MapElementListener<? super K, ? super V> listener) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                ((MAMap<K, V>)this.m).addMapElementListener(listener);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MAMap.MAEntry<K, V> entryOfKey(K key) {
            Lock lock;
            if (((MAMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MAMap<K, V>)this.m).entryOfKey(key), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }
        
        @Override
        public MAMap.MAEntry<K, V> entryOfValue(V value) {
            Lock lock;
            if (((MAMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MAMap<K, V>)this.m).entryOfValue(value), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public void removeMapElementListener(MapElementListener<? super K, ? super V> listener) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                ((MAMap<K, V>)this.m).removeMapElementListener(listener);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MAMap.MAValuesView<K, V> values() {
            Lock lock;
            if (((MAMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MAMap<K, V>)this.m).values(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MAMap.MAKeySetView<K, V> keySet() {
            Lock lock;
            if (((MAMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MAMap<K, V>)this.m).keySet(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MAMap.MAEntrySetView<K, V> entrySet() {
            Lock lock;
            if (((MAMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MAMap<K, V>)this.m).entrySet(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedMAMapWithSerializable<K, V> extends LockedMAMap<K, V> implements Serializable {

        private static final long serialVersionUID = -8046964764850939159L;

        LockedMAMapWithSerializable(MAMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(m, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMAMapWithSerializable<K, V>((MAMap<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (MAMap<K, V>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedXOrderedMapXOrderedMapView<K, V> extends LockedXOrderedMap<K, V> implements XOrderedMap.XOrderedMapView<K, V> {

        LockedXOrderedMapXOrderedMapView(XOrderedMap.XOrderedMapView<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(m, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXOrderedMapXOrderedMapView<K, V>((XOrderedMap.XOrderedMapView<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public ViewInfo viewInfo() {
            Lock lock;
            if (((XOrderedMap.XOrderedMapView<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XOrderedMap.XOrderedMapView<K, V>)this.m).viewInfo();
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedXOrderedMap<K, V> extends LockedXMap<K, V> implements XOrderedMap<K, V> {

        LockedXOrderedMap(XOrderedMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(m, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockedXOrderedMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXOrderedMap<K, V>((XOrderedMap<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public XOrderedMap.XOrderedMapView<K, V> descendingMap() {
            Lock lock;
            if (((XOrderedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XOrderedMap<K, V>)this.m).descendingMap(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public V access(K key) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((XOrderedMap<K, V>)this.m).access(key);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public Map.Entry<K, V> pollLastEntry() {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((XOrderedMap<K, V>)this.m).pollLastEntry();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public Map.Entry<K, V> pollFirstEntry() {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((XOrderedMap<K, V>)this.m).pollFirstEntry();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XMap.XEntry<K, V> firstEntry() {
            Lock lock;
            if (((XOrderedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XOrderedMap<K, V>)this.m).firstEntry(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public K firstKey() {
            Lock lock;
            if (((XOrderedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XOrderedMap<K, V>)this.m).firstKey();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XOrderedMap.XOrderedKeySetView<K> keySet() {
            Lock lock;
            if (((XOrderedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XOrderedMap<K, V>)this.m).keySet(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public OrderAdjustMode accessMode() {
            Lock lock;
            if (((XOrderedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XOrderedMap<K, V>)this.m).accessMode();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public OrderAdjustMode replaceMode() {
            Lock lock;
            if (((XOrderedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XOrderedMap<K, V>)this.m).replaceMode();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XOrderedMap.XOrderedKeySetView<K> descendingKeySet() {
            Lock lock;
            if (((XOrderedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XOrderedMap<K, V>)this.m).descendingKeySet(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public boolean headAppend() {
            Lock lock;
            if (((XOrderedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XOrderedMap<K, V>)this.m).headAppend();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XMap.XEntry<K, V> lastEntry() {
            Lock lock;
            if (((XOrderedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XOrderedMap<K, V>)this.m).lastEntry(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public K lastKey() {
            Lock lock;
            if (((XOrderedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XOrderedMap<K, V>)this.m).lastKey();
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedXOrderedMapWithSerializable<K, V> extends LockedXOrderedMap<K, V> implements Serializable {

        private static final long serialVersionUID = -1033429976L;

        LockedXOrderedMapWithSerializable(XOrderedMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(m, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXOrderedMapWithSerializable<K, V>((XOrderedMap<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (XOrderedMap<K, V>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedXNavigableMapXNavigableMapView<K, V> extends LockedXNavigableMap<K, V> implements XNavigableMap.XNavigableMapView<K, V> {

        LockedXNavigableMapXNavigableMapView(XNavigableMap.XNavigableMapView<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(m, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXNavigableMapXNavigableMapView<K, V>((XNavigableMap.XNavigableMapView<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public ViewInfo viewInfo() {
            Lock lock;
            if (((XNavigableMap.XNavigableMapView<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XNavigableMap.XNavigableMapView<K, V>)this.m).viewInfo();
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedXNavigableMap<K, V> extends LockedXSortedMap<K, V> implements XNavigableMap<K, V> {

        LockedXNavigableMap(XNavigableMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(m, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockedXNavigableMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXNavigableMap<K, V>((XNavigableMap<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public XNavigableMap.XNavigableKeySetView<K> descendingKeySet() {
            Lock lock;
            if (((XNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableMap<K, V>)this.m).descendingKeySet(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public Map.Entry<K, V> pollLastEntry() {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((XNavigableMap<K, V>)this.m).pollLastEntry();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public Map.Entry<K, V> pollFirstEntry() {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((XNavigableMap<K, V>)this.m).pollFirstEntry();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XMap.XEntry<K, V> firstEntry() {
            Lock lock;
            if (((XNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableMap<K, V>)this.m).firstEntry(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XMap.XEntry<K, V> ceilingEntry(K key) {
            Lock lock;
            if (((XNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableMap<K, V>)this.m).ceilingEntry(key), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public K lowerKey(K key) {
            Lock lock;
            if (((XNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XNavigableMap<K, V>)this.m).lowerKey(key);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XNavigableMap.XNavigableMapView<K, V> headMap(K toKey) {
            Lock lock;
            if (((XNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableMap<K, V>)this.m).headMap(toKey), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XNavigableMap.XNavigableMapView<K, V> descendingMap() {
            Lock lock;
            if (((XNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableMap<K, V>)this.m).descendingMap(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XNavigableMap.XNavigableMapView<K, V> tailMap(K fromKey, boolean inclusive) {
            Lock lock;
            if (((XNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableMap<K, V>)this.m).tailMap(fromKey, inclusive), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XNavigableMap.XNavigableMapView<K, V> subMap(K fromKey, K toKey) {
            Lock lock;
            if (((XNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableMap<K, V>)this.m).subMap(fromKey, toKey), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public K ceilingKey(K key) {
            Lock lock;
            if (((XNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XNavigableMap<K, V>)this.m).ceilingKey(key);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XMap.XEntry<K, V> lowerEntry(K key) {
            Lock lock;
            if (((XNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableMap<K, V>)this.m).lowerEntry(key), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XMap.XEntry<K, V> floorEntry(K key) {
            Lock lock;
            if (((XNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableMap<K, V>)this.m).floorEntry(key), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XNavigableMap.XNavigableKeySetView<K> navigableKeySet() {
            Lock lock;
            if (((XNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableMap<K, V>)this.m).navigableKeySet(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XMap.XEntry<K, V> higherEntry(K key) {
            Lock lock;
            if (((XNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableMap<K, V>)this.m).higherEntry(key), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XNavigableMap.XNavigableMapView<K, V> subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) {
            Lock lock;
            if (((XNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableMap<K, V>)this.m).subMap(fromKey, fromInclusive, toKey, toInclusive), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public K floorKey(K key) {
            Lock lock;
            if (((XNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XNavigableMap<K, V>)this.m).floorKey(key);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XNavigableMap.XNavigableKeySetView<K> keySet() {
            Lock lock;
            if (((XNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableMap<K, V>)this.m).keySet(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public K higherKey(K key) {
            Lock lock;
            if (((XNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XNavigableMap<K, V>)this.m).higherKey(key);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XNavigableMap.XNavigableMapView<K, V> tailMap(K fromKey) {
            Lock lock;
            if (((XNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableMap<K, V>)this.m).tailMap(fromKey), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XNavigableMap.XNavigableMapView<K, V> headMap(K toKey, boolean inclusive) {
            Lock lock;
            if (((XNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableMap<K, V>)this.m).headMap(toKey, inclusive), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XMap.XEntry<K, V> lastEntry() {
            Lock lock;
            if (((XNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableMap<K, V>)this.m).lastEntry(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedXNavigableMapWithSerializable<K, V> extends LockedXNavigableMap<K, V> implements Serializable {

        private static final long serialVersionUID = -992637318L;

        LockedXNavigableMapWithSerializable(XNavigableMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(m, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXNavigableMapWithSerializable<K, V>((XNavigableMap<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (XNavigableMap<K, V>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedXSortedMapXSortedMapView<K, V> extends LockedXSortedMap<K, V> implements XSortedMap.XSortedMapView<K, V> {

        LockedXSortedMapXSortedMapView(XSortedMap.XSortedMapView<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(m, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXSortedMapXSortedMapView<K, V>((XSortedMap.XSortedMapView<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public ViewInfo viewInfo() {
            Lock lock;
            if (((XSortedMap.XSortedMapView<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XSortedMap.XSortedMapView<K, V>)this.m).viewInfo();
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedXSortedMap<K, V> extends LockedXMap<K, V> implements XSortedMap<K, V> {

        LockedXSortedMap(XSortedMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(m, readWriteLock, usingInternalLock);
        }

        @Deprecated //Only for deserialization
        LockedXSortedMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXSortedMap<K, V>((XSortedMap<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public K firstKey() {
            Lock lock;
            if (((XSortedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XSortedMap<K, V>)this.m).firstKey();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XSortedMap.XSortedKeySetView<K> keySet() {
            Lock lock;
            if (((XSortedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XSortedMap<K, V>)this.m).keySet(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XSortedMap.XSortedMapView<K, V> headMap(K toKey) {
            Lock lock;
            if (((XSortedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XSortedMap<K, V>)this.m).headMap(toKey), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XSortedMap.XSortedMapView<K, V> subMap(K fromKey, K toKey) {
            Lock lock;
            if (((XSortedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XSortedMap<K, V>)this.m).subMap(fromKey, toKey), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XSortedMap.XSortedMapView<K, V> tailMap(K fromKey) {
            Lock lock;
            if (((XSortedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XSortedMap<K, V>)this.m).tailMap(fromKey), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public Comparator<? super K> comparator() {
            Lock lock;
            if (((XSortedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XSortedMap<K, V>)this.m).comparator();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public K lastKey() {
            Lock lock;
            if (((XSortedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XSortedMap<K, V>)this.m).lastKey();
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedXSortedMapWithSerializable<K, V> extends LockedXSortedMap<K, V> implements Serializable {

        private static final long serialVersionUID = -47598340L;

        LockedXSortedMapWithSerializable(XSortedMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(m, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXSortedMapWithSerializable<K, V>((XSortedMap<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (XSortedMap<K, V>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedXMap<K, V> extends LockedMap<K, V> implements XMap<K, V> {

        LockedXMap(XMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(m, readWriteLock, usingInternalLock);
        }

        @Deprecated //Only for deserialization
        LockedXMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXMap<K, V>((XMap<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public void addValueValidator(Validator<V> validator) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                ((XMap<K, V>)this.m).addValueValidator(validator);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public ReplacementRule keyReplacementRule() {
            Lock lock;
            if (((XMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XMap<K, V>)this.m).keyReplacementRule();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public UnifiedComparator<? super V> valueUnifiedComparator() {
            Lock lock;
            if (((XMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XMap<K, V>)this.m).valueUnifiedComparator();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public void removeValueValidator(Validator<V> validator) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                ((XMap<K, V>)this.m).removeValueValidator(validator);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public boolean isReadWriteLockSupported() {
            return ((XMap<K, V>)this.m).isReadWriteLockSupported();
        }

        @Override
        public void addKeyValidator(Validator<K> validator) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                ((XMap<K, V>)this.m).addKeyValidator(validator);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public UnifiedComparator<? super Map.Entry<K, V>> entryUnifiedComparator() {
            Lock lock;
            if (((XMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XMap<K, V>)this.m).entryUnifiedComparator();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public void removeKeyValidator(Validator<K> validator) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                ((XMap<K, V>)this.m).removeKeyValidator(validator);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XMap.XKeySetView<K> keySet() {
            Lock lock;
            if (((XMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XMap<K, V>)this.m).keySet(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public BidiType bidiType() {
            Lock lock;
            if (((XMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XMap<K, V>)this.m).bidiType();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XEntry<K, V> entryOfValue(V value) {
            Lock lock;
            if (((XMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XMap<K, V>)this.m).entryOfValue(value);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XMap.XValuesView<V> values() {
            Lock lock;
            if (((XMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XMap<K, V>)this.m).values(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XMap.XEntrySetView<K, V> entrySet() {
            Lock lock;
            if (((XMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XMap<K, V>)this.m).entrySet(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public UnifiedComparator<? super K> keyUnifiedComparator() {
            Lock lock;
            if (((XMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XMap<K, V>)this.m).keyUnifiedComparator();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XMap.XEntry<K, V> entryOfKey(K key) {
            Lock lock;
            if (((XMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XMap<K, V>)this.m).entryOfKey(key), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public void validateKey(K key) {
            Lock lock;
            if (((XMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                ((XMap<K, V>)this.m).validateKey(key);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public void validateValue(V value) {
            Lock lock;
            if (((XMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                ((XMap<K, V>)this.m).validateValue(value);
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedXMapWithSerializable<K, V> extends LockedXMap<K, V> implements Serializable {

        private static final long serialVersionUID = -1495396167L;

        LockedXMapWithSerializable(XMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(m, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXMapWithSerializable<K, V>((XMap<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (XMap<K, V>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedStandardNavigableMap<K, V> extends LockedStandardSortedMap<K, V> implements StandardNavigableMap<K, V> {

        LockedStandardNavigableMap(StandardNavigableMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(m, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockedStandardNavigableMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedStandardNavigableMap<K, V>((StandardNavigableMap<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public StandardNavigableMap<K, V> tailMap(K fromKey) {
            Lock lock;
            if (((StandardNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((StandardNavigableMap<K, V>)this.m).tailMap(fromKey), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public Map.Entry<K, V> pollLastEntry() {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((StandardNavigableMap<K, V>)this.m).pollLastEntry();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public Map.Entry<K, V> firstEntry() {
            Lock lock;
            if (((StandardNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((StandardNavigableMap<K, V>)this.m).firstEntry(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public Map.Entry<K, V> pollFirstEntry() {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((StandardNavigableMap<K, V>)this.m).pollFirstEntry();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public K lowerKey(K key) {
            Lock lock;
            if (((StandardNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((StandardNavigableMap<K, V>)this.m).lowerKey(key);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public StandardNavigableMap<K, V> tailMap(K fromKey, boolean inclusive) {
            Lock lock;
            if (((StandardNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((StandardNavigableMap<K, V>)this.m).tailMap(fromKey, inclusive), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public Map.Entry<K, V> lowerEntry(K key) {
            Lock lock;
            if (((StandardNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((StandardNavigableMap<K, V>)this.m).lowerEntry(key), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public K ceilingKey(K key) {
            Lock lock;
            if (((StandardNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((StandardNavigableMap<K, V>)this.m).ceilingKey(key);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public StandardNavigableMap<K, V> descendingMap() {
            Lock lock;
            if (((StandardNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((StandardNavigableMap<K, V>)this.m).descendingMap(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public StandardNavigableMap<K, V> headMap(K toKey, boolean inclusive) {
            Lock lock;
            if (((StandardNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((StandardNavigableMap<K, V>)this.m).headMap(toKey, inclusive), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public StandardNavigableMap<K, V> subMap(K fromKey, K toKey) {
            Lock lock;
            if (((StandardNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((StandardNavigableMap<K, V>)this.m).subMap(fromKey, toKey), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public Map.Entry<K, V> ceilingEntry(K key) {
            Lock lock;
            if (((StandardNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((StandardNavigableMap<K, V>)this.m).ceilingEntry(key), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public Map.Entry<K, V> lastEntry() {
            Lock lock;
            if (((StandardNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((StandardNavigableMap<K, V>)this.m).lastEntry(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public Map.Entry<K, V> floorEntry(K key) {
            Lock lock;
            if (((StandardNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((StandardNavigableMap<K, V>)this.m).floorEntry(key), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public NavigableSet<K> descendingKeySet() {
            Lock lock;
            if (((StandardNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((StandardNavigableMap<K, V>)this.m).descendingKeySet(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public StandardNavigableMap<K, V> subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) {
            Lock lock;
            if (((StandardNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((StandardNavigableMap<K, V>)this.m).subMap(fromKey, fromInclusive, toKey, toInclusive), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public StandardNavigableMap<K, V> headMap(K toKey) {
            Lock lock;
            if (((StandardNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((StandardNavigableMap<K, V>)this.m).headMap(toKey), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public Map.Entry<K, V> higherEntry(K key) {
            Lock lock;
            if (((StandardNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((StandardNavigableMap<K, V>)this.m).higherEntry(key), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public K floorKey(K key) {
            Lock lock;
            if (((StandardNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((StandardNavigableMap<K, V>)this.m).floorKey(key);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public NavigableSet<K> navigableKeySet() {
            Lock lock;
            if (((StandardNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((StandardNavigableMap<K, V>)this.m).navigableKeySet(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public K higherKey(K key) {
            Lock lock;
            if (((StandardNavigableMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((StandardNavigableMap<K, V>)this.m).higherKey(key);
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedStandardNavigableMapWithSerializable<K, V> extends LockedStandardNavigableMap<K, V> implements Serializable {

        private static final long serialVersionUID = 3565598665441332179L;

        LockedStandardNavigableMapWithSerializable(StandardNavigableMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(m, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedStandardNavigableMapWithSerializable<K, V>((StandardNavigableMap<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (StandardNavigableMap<K, V>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedStandardSortedMap<K, V> extends LockedStandardMap<K, V> implements StandardSortedMap<K, V> {

        LockedStandardSortedMap(StandardSortedMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(m, readWriteLock, usingInternalLock);
        }

        @Deprecated //Only for deserialization
        LockedStandardSortedMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedStandardSortedMap<K, V>((StandardSortedMap<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public StandardSortedMap<K, V> headMap(K toKey) {
            Lock lock;
            if (((StandardSortedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((StandardSortedMap<K, V>)this.m).headMap(toKey), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public K firstKey() {
            Lock lock;
            if (((StandardSortedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((StandardSortedMap<K, V>)this.m).firstKey();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public StandardSortedMap<K, V> subMap(K fromKey, K toKey) {
            Lock lock;
            if (((StandardSortedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((StandardSortedMap<K, V>)this.m).subMap(fromKey, toKey), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public StandardSortedMap<K, V> tailMap(K fromKey) {
            Lock lock;
            if (((StandardSortedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((StandardSortedMap<K, V>)this.m).tailMap(fromKey), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public Comparator<? super K> comparator() {
            Lock lock;
            if (((StandardSortedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((StandardSortedMap<K, V>)this.m).comparator();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public K lastKey() {
            Lock lock;
            if (((StandardSortedMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((StandardSortedMap<K, V>)this.m).lastKey();
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedStandardSortedMapWithSerializable<K, V> extends LockedStandardSortedMap<K, V> implements Serializable {

        private static final long serialVersionUID = -736223677L;

        LockedStandardSortedMapWithSerializable(StandardSortedMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(m, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedStandardSortedMapWithSerializable<K, V>((StandardSortedMap<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (StandardSortedMap<K, V>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedStandardMap<K, V> extends LockedMap<K, V> implements StandardMap<K, V> {

        LockedStandardMap(StandardMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(m, readWriteLock, usingInternalLock);
        }

        @Deprecated //Only for deserialization
        LockedStandardMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedStandardMap<K, V>((StandardMap<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public boolean isReadWriteLockSupported() {
            return ((StandardMap<K, V>)this.m).isReadWriteLockSupported();
        }

        @Override
        public StandardMap.EntrySet<K, V> entrySet() {
            Lock lock;
            if (((StandardMap<K, V>)this.m).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((StandardMap<K, V>)this.m).entrySet(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedStandardMapWithSerializable<K, V> extends LockedStandardMap<K, V> implements Serializable {

        private static final long serialVersionUID = -1030702272L;

        LockedStandardMapWithSerializable(StandardMap<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(m, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedStandardMapWithSerializable<K, V>((StandardMap<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (StandardMap<K, V>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static abstract class LockedMap<K, V> extends LockedProxy implements Map<K, V> {

        Map<K, V> m;

        LockedMap(Map<K, V> m, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(readWriteLock, usingInternalLock);
            this.m = m;
        }

        @Deprecated //Only for deserialization
        LockedMap() {
        }

        @Override
        Object getInnerObject() {
            return this.m;
        }

        @Override
        public String toString() {
            return this.m.toString();
        }

        @Override
        public boolean isEmpty() {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.m)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return this.m.isEmpty();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public V get(Object key) {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.m)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return this.m.get(key);
            } finally {
                lock.unlock();
            }
        }

        /*
         * Don't implement 
         * java.util.Set entrySet()
         * here because the current class 
         * is neither "StandardMap" nor "XMap"
         */

        @Override
        public Set<K> keySet() {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.m)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(this.m.keySet(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public boolean containsKey(Object o) {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.m)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return this.m.containsKey(o);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public void clear() {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                this.m.clear();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public V put(K key, V value) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return this.m.put(key, value);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public void putAll(Map<? extends K, ? extends V> m) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                this.m.putAll(m);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public int hashCode() {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.m)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return this.m.hashCode();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public Collection<V> values() {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.m)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(this.m.values(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public V remove(Object key) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return this.m.remove(key);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public boolean equals(Object obj) {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.m)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return this.m.equals(obj);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public boolean containsValue(Object o) {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.m)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return this.m.containsValue(o);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public int size() {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.m)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return this.m.size();
            } finally {
                lock.unlock();
            }
        }
    }

    /*
     * No derived class "LockedMapWithSerializable<K, V>"
     * for class "LockedMap<K, V>" because it is abstract.
     */

    private static class LockedMAListMAListView<E> extends LockedMAList<E> implements MAList.MAListView<E> {

        LockedMAListMAListView(MAList.MAListView<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMAListMAListView<E>((MAList.MAListView<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public ViewInfo viewInfo() {
            Lock lock;
            if (((MAList.MAListView<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MAList.MAListView<E>)this.c).viewInfo();
            } finally {
                lock.unlock();
            }
        }
    }
    private static class LockedMAListMAListViewWithRandomAccess<E> extends LockedMAListMAListView<E> implements RandomAccess {

        LockedMAListMAListViewWithRandomAccess(MAList.MAListView<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMAListMAListViewWithRandomAccess<E>((MAList.MAListView<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (MAList.MAListView<E>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }


    private static class LockedMAList<E> extends LockedMACollection<E> implements MAList<E> {

        LockedMAList(MAList<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockedMAList() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMAList<E>((MAList<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public void removeListElementListener(ListElementListener<? super E> listener) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                ((MAList<E>)this.c).removeListElementListener(listener);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MAList.MAListIterator<E> iterator() {
            Lock lock;
            if (((MAList<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MAList<E>)this.c).iterator(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MAList.MAListIterator<E> listIterator() {
            Lock lock;
            if (((MAList<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MAList<E>)this.c).listIterator(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public void addListElementListener(ListElementListener<? super E> listener) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                ((MAList<E>)this.c).addListElementListener(listener);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MAList.MAListView<E> subList(int from, int to) {
            Lock lock;
            if (((MAList<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MAList<E>)this.c).subList(from, to), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E get(int index) {
            Lock lock;
            if (((MAList<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MAList<E>)this.c).get(index);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MAList.MAListIterator<E> listIterator(int index) {
            Lock lock;
            if (((MAList<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MAList<E>)this.c).listIterator(index), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public boolean addAll(int index, Collection<? extends E> c) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((MAList<E>)this.c).addAll(index, c);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public BidiType bidiType() {
            Lock lock;
            if (((MAList<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MAList<E>)this.c).bidiType();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public int indexOf(Object o) {
            Lock lock;
            if (((MAList<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MAList<E>)this.c).indexOf(o);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public int lastIndexOf(Object o) {
            Lock lock;
            if (((MAList<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MAList<E>)this.c).lastIndexOf(o);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E set(int index, E e) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((MAList<E>)this.c).set(index, e);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E remove(int index) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((MAList<E>)this.c).remove(index);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public void add(int index, E e) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                ((MAList<E>)this.c).add(index, e);
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedMAListWithSerializable<E> extends LockedMAList<E> implements Serializable {

        private static final long serialVersionUID = -1577665447L;

        LockedMAListWithSerializable(MAList<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMAListWithSerializable<E>((MAList<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (MAList<E>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedMAListWithRandomAccess<E> extends LockedMAList<E> implements RandomAccess {

        LockedMAListWithRandomAccess(MAList<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMAListWithRandomAccess<E>((MAList<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (MAList<E>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }


    private static class LockedMAListWithSerializableRandomAccess<E> extends LockedMAList<E> implements Serializable, RandomAccess {

        private static final long serialVersionUID = -1577665447L;

        LockedMAListWithSerializableRandomAccess(MAList<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMAListWithSerializableRandomAccess<E>((MAList<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (MAList<E>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedMAOrderedMapMAOrderedKeySetView<K, V> extends LockedMAOrderedSetMAOrderedSetView<K> implements MAOrderedMap.MAOrderedKeySetView<K, V> {

        LockedMAOrderedMapMAOrderedKeySetView(MAOrderedMap.MAOrderedKeySetView<K, V> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMAOrderedMapMAOrderedKeySetView<K, V>((MAOrderedMap.MAOrderedKeySetView<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        public MAMap.MAKeySetView.MAKeySetIterator<K, V> descendingIterator() {
            Lock lock;
            if (((MAOrderedMap.MAOrderedKeySetView<K, V>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MAOrderedMap.MAOrderedKeySetView<K, V>)this.c).descendingIterator(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public void removeKeySetElementListener(KeySetElementListener<? super K, ? super V> listener) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                ((MAOrderedMap.MAOrderedKeySetView<K, V>)this.c).removeKeySetElementListener(listener);
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public MAOrderedMap.MAOrderedKeySetView<K, V> descendingSet() {
            Lock lock;
            if (((MAOrderedMap.MAOrderedKeySetView<K, V>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MAOrderedMap.MAOrderedKeySetView<K, V>)this.c).descendingSet(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public MAMap.MAKeySetView.MAKeySetIterator<K, V> iterator() {
            Lock lock;
            if (((MAOrderedMap.MAOrderedKeySetView<K, V>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MAOrderedMap.MAOrderedKeySetView<K, V>)this.c).iterator(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public void addKeySetElementListener(KeySetElementListener<? super K, ? super V> listener) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                ((MAOrderedMap.MAOrderedKeySetView<K, V>)this.c).addKeySetElementListener(listener);
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedMAOrderedSetMAOrderedSetView<E> extends LockedMAOrderedSet<E> implements MAOrderedSet.MAOrderedSetView<E> {

        LockedMAOrderedSetMAOrderedSetView(MAOrderedSet.MAOrderedSetView<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMAOrderedSetMAOrderedSetView<E>((MAOrderedSet.MAOrderedSetView<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public ViewInfo viewInfo() {
            Lock lock;
            if (((MAOrderedSet.MAOrderedSetView<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MAOrderedSet.MAOrderedSetView<E>)this.c).viewInfo();
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedMAOrderedSet<E> extends LockedMASet<E> implements MAOrderedSet<E> {

        LockedMAOrderedSet(MAOrderedSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockedMAOrderedSet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMAOrderedSet<E>((MAOrderedSet<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public OrderAdjustMode replaceMode() {
            Lock lock;
            if (((MAOrderedSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MAOrderedSet<E>)this.c).replaceMode();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public boolean headAppend() {
            Lock lock;
            if (((MAOrderedSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MAOrderedSet<E>)this.c).headAppend();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E last() {
            Lock lock;
            if (((MAOrderedSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MAOrderedSet<E>)this.c).last();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MAOrderedSet.MAOrderedSetView<E> descendingSet() {
            Lock lock;
            if (((MAOrderedSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MAOrderedSet<E>)this.c).descendingSet(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MACollection.MAIterator<E> descendingIterator() {
            Lock lock;
            if (((MAOrderedSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MAOrderedSet<E>)this.c).descendingIterator(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E first() {
            Lock lock;
            if (((MAOrderedSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MAOrderedSet<E>)this.c).first();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E pollLast() {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((MAOrderedSet<E>)this.c).pollLast();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E pollFirst() {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((MAOrderedSet<E>)this.c).pollFirst();
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedMAOrderedSetWithSerializable<E> extends LockedMAOrderedSet<E> implements Serializable {

        private static final long serialVersionUID = -6970628580195625118L;

        LockedMAOrderedSetWithSerializable(MAOrderedSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMAOrderedSetWithSerializable<E>((MAOrderedSet<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (MAOrderedSet<E>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedMANavigableMapMANavigableKeySetView<K, V> extends LockedMANavigableSetMANavigableSetView<K> implements MANavigableMap.MANavigableKeySetView<K, V> {

        LockedMANavigableMapMANavigableKeySetView(MANavigableMap.MANavigableKeySetView<K, V> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMANavigableMapMANavigableKeySetView<K, V>((MANavigableMap.MANavigableKeySetView<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        public MANavigableMap.MANavigableKeySetView<K, V> subSet(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) {
            Lock lock;
            if (((MANavigableMap.MANavigableKeySetView<K, V>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableMap.MANavigableKeySetView<K, V>)this.c).subSet(fromKey, fromInclusive, toKey, toInclusive), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public MANavigableMap.MANavigableKeySetView<K, V> tailSet(K fromKey, boolean inclusive) {
            Lock lock;
            if (((MANavigableMap.MANavigableKeySetView<K, V>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableMap.MANavigableKeySetView<K, V>)this.c).tailSet(fromKey, inclusive), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public MANavigableMap.MANavigableKeySetView<K, V> headSet(K toKey, boolean inclusive) {
            Lock lock;
            if (((MANavigableMap.MANavigableKeySetView<K, V>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableMap.MANavigableKeySetView<K, V>)this.c).headSet(toKey, inclusive), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public MAMap.MAKeySetView.MAKeySetIterator<K, V> descendingIterator() {
            Lock lock;
            if (((MANavigableMap.MANavigableKeySetView<K, V>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableMap.MANavigableKeySetView<K, V>)this.c).descendingIterator(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public void removeKeySetElementListener(KeySetElementListener<? super K, ? super V> listener) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                ((MANavigableMap.MANavigableKeySetView<K, V>)this.c).removeKeySetElementListener(listener);
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public MAMap.MAKeySetView.MAKeySetIterator<K, V> iterator() {
            Lock lock;
            if (((MANavigableMap.MANavigableKeySetView<K, V>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableMap.MANavigableKeySetView<K, V>)this.c).iterator(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public MANavigableMap.MANavigableKeySetView<K, V> headSet(K toKey) {
            Lock lock;
            if (((MANavigableMap.MANavigableKeySetView<K, V>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableMap.MANavigableKeySetView<K, V>)this.c).headSet(toKey), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public MANavigableMap.MANavigableKeySetView<K, V> tailSet(K fromKey) {
            Lock lock;
            if (((MANavigableMap.MANavigableKeySetView<K, V>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableMap.MANavigableKeySetView<K, V>)this.c).tailSet(fromKey), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public MANavigableMap.MANavigableKeySetView<K, V> descendingSet() {
            Lock lock;
            if (((MANavigableMap.MANavigableKeySetView<K, V>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableMap.MANavigableKeySetView<K, V>)this.c).descendingSet(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public MANavigableMap.MANavigableKeySetView<K, V> subSet(K fromKey, K toKey) {
            Lock lock;
            if (((MANavigableMap.MANavigableKeySetView<K, V>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableMap.MANavigableKeySetView<K, V>)this.c).subSet(fromKey, toKey), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public void addKeySetElementListener(KeySetElementListener<? super K, ? super V> listener) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                ((MANavigableMap.MANavigableKeySetView<K, V>)this.c).addKeySetElementListener(listener);
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedMANavigableSetMANavigableSetView<E> extends LockedMANavigableSet<E> implements MANavigableSet.MANavigableSetView<E> {

        LockedMANavigableSetMANavigableSetView(MANavigableSet.MANavigableSetView<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMANavigableSetMANavigableSetView<E>((MANavigableSet.MANavigableSetView<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public ViewInfo viewInfo() {
            Lock lock;
            if (((MANavigableSet.MANavigableSetView<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MANavigableSet.MANavigableSetView<E>)this.c).viewInfo();
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedMANavigableSet<E> extends LockedMASortedSet<E> implements MANavigableSet<E> {

        LockedMANavigableSet(MANavigableSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockedMANavigableSet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMANavigableSet<E>((MANavigableSet<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public E higher(E e) {
            Lock lock;
            if (((MANavigableSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MANavigableSet<E>)this.c).higher(e);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MACollection.MAIterator<E> descendingIterator() {
            Lock lock;
            if (((MANavigableSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableSet<E>)this.c).descendingIterator(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MANavigableSet.MANavigableSetView<E> tailSet(E fromElement) {
            Lock lock;
            if (((MANavigableSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableSet<E>)this.c).tailSet(fromElement), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E lower(E e) {
            Lock lock;
            if (((MANavigableSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MANavigableSet<E>)this.c).lower(e);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MANavigableSet.MANavigableSetView<E> tailSet(E fromElement, boolean inclusive) {
            Lock lock;
            if (((MANavigableSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableSet<E>)this.c).tailSet(fromElement, inclusive), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MANavigableSet.MANavigableSetView<E> subSet(E fromElement, E toElement) {
            Lock lock;
            if (((MANavigableSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableSet<E>)this.c).subSet(fromElement, toElement), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MANavigableSet.MANavigableSetView<E> headSet(E toElement, boolean inclusive) {
            Lock lock;
            if (((MANavigableSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableSet<E>)this.c).headSet(toElement, inclusive), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E floor(E e) {
            Lock lock;
            if (((MANavigableSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MANavigableSet<E>)this.c).floor(e);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E ceiling(E e) {
            Lock lock;
            if (((MANavigableSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MANavigableSet<E>)this.c).ceiling(e);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MANavigableSet.MANavigableSetView<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {
            Lock lock;
            if (((MANavigableSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableSet<E>)this.c).subSet(fromElement, fromInclusive, toElement, toInclusive), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MANavigableSet.MANavigableSetView<E> descendingSet() {
            Lock lock;
            if (((MANavigableSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableSet<E>)this.c).descendingSet(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MANavigableSet.MANavigableSetView<E> headSet(E toElement) {
            Lock lock;
            if (((MANavigableSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MANavigableSet<E>)this.c).headSet(toElement), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E pollLast() {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((MANavigableSet<E>)this.c).pollLast();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E pollFirst() {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((MANavigableSet<E>)this.c).pollFirst();
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedMANavigableSetWithSerializable<E> extends LockedMANavigableSet<E> implements Serializable {

        private static final long serialVersionUID = -5292590294842062256L;

        LockedMANavigableSetWithSerializable(MANavigableSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMANavigableSetWithSerializable<E>((MANavigableSet<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (MANavigableSet<E>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedMASortedMapMASortedKeySetView<K, V> extends LockedMASortedSetMASortedSetView<K> implements MASortedMap.MASortedKeySetView<K, V> {

        LockedMASortedMapMASortedKeySetView(MASortedMap.MASortedKeySetView<K, V> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMASortedMapMASortedKeySetView<K, V>((MASortedMap.MASortedKeySetView<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        public MASortedMap.MASortedKeySetView<K, V> tailSet(K fromKey) {
            Lock lock;
            if (((MASortedMap.MASortedKeySetView<K, V>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MASortedMap.MASortedKeySetView<K, V>)this.c).tailSet(fromKey), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public void removeKeySetElementListener(KeySetElementListener<? super K, ? super V> listener) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                ((MASortedMap.MASortedKeySetView<K, V>)this.c).removeKeySetElementListener(listener);
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public MAMap.MAKeySetView.MAKeySetIterator<K, V> iterator() {
            Lock lock;
            if (((MASortedMap.MASortedKeySetView<K, V>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MASortedMap.MASortedKeySetView<K, V>)this.c).iterator(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public MASortedMap.MASortedKeySetView<K, V> subSet(K fromKey, K toKey) {
            Lock lock;
            if (((MASortedMap.MASortedKeySetView<K, V>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MASortedMap.MASortedKeySetView<K, V>)this.c).subSet(fromKey, toKey), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public MASortedMap.MASortedKeySetView<K, V> headSet(K toKey) {
            Lock lock;
            if (((MASortedMap.MASortedKeySetView<K, V>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MASortedMap.MASortedKeySetView<K, V>)this.c).headSet(toKey), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public void addKeySetElementListener(KeySetElementListener<? super K, ? super V> listener) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                ((MASortedMap.MASortedKeySetView<K, V>)this.c).addKeySetElementListener(listener);
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedMASortedSetMASortedSetView<E> extends LockedMASortedSet<E> implements MASortedSet.MASortedSetView<E> {

        LockedMASortedSetMASortedSetView(MASortedSet.MASortedSetView<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMASortedSetMASortedSetView<E>((MASortedSet.MASortedSetView<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public ViewInfo viewInfo() {
            Lock lock;
            if (((MASortedSet.MASortedSetView<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MASortedSet.MASortedSetView<E>)this.c).viewInfo();
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedMASortedSet<E> extends LockedMASet<E> implements MASortedSet<E> {

        LockedMASortedSet(MASortedSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @Deprecated //Only for deserialization
        LockedMASortedSet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMASortedSet<E>((MASortedSet<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public MASortedSet.MASortedSetView<E> subSet(E fromElement, E toElement) {
            Lock lock;
            if (((MASortedSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MASortedSet<E>)this.c).subSet(fromElement, toElement), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MASortedSet.MASortedSetView<E> tailSet(E fromElement) {
            Lock lock;
            if (((MASortedSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MASortedSet<E>)this.c).tailSet(fromElement), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E last() {
            Lock lock;
            if (((MASortedSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MASortedSet<E>)this.c).last();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E first() {
            Lock lock;
            if (((MASortedSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MASortedSet<E>)this.c).first();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public Comparator<? super E> comparator() {
            Lock lock;
            if (((MASortedSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MASortedSet<E>)this.c).comparator();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public MASortedSet.MASortedSetView<E> headSet(E toElement) {
            Lock lock;
            if (((MASortedSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MASortedSet<E>)this.c).headSet(toElement), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedMASortedSetWithSerializable<E> extends LockedMASortedSet<E> implements Serializable {

        private static final long serialVersionUID = -2110233426L;

        LockedMASortedSetWithSerializable(MASortedSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMASortedSetWithSerializable<E>((MASortedSet<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (MASortedSet<E>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedMAMapMAEntrySetView<K, V> extends LockedMASet<Map.Entry<K, V>> implements MAMap.MAEntrySetView<K, V> {

        LockedMAMapMAEntrySetView(MAMap.MAEntrySetView<K, V> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMAMapMAEntrySetView<K, V>((MAMap.MAEntrySetView<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        public <T> T[] toArray(T[] a) {
            Lock lock;
            if (((MAMap.MAEntrySetView<K, V>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                Object[] arr = this.c.toArray(a.length==0 ? a : (Object[])Array.newInstance(a.getClass().getComponentType(), 0));
                for (int i = arr.length - 1; i >= 0; i--) {
                    arr[i] = MACollections.locked((MAMap.MAEntry<K, V>)arr[i], readWriteLock, usingInternalLock);
                }
                if (arr.length > a.length) {
                    return (T[])arr;
                }
                System.arraycopy(arr, 0, a, 0, arr.length);
                if (a.length > arr.length) {
                    a[arr.length] = null;
                }
                return a;
            } finally {
                lock.unlock();
            }
        }

        @Deprecated
        @Override
        public boolean add(Map.Entry<K, V> entry) {
            throw new UnsupportedOperationException(
                notSupported("boolean org.babyfish.collection.MAMap.MAEntrySetView<K, V>.add(java.util.Map.Entry<K, V>)")
            );
        }

        @SuppressWarnings("unchecked")
        @Override
        public ViewInfo viewInfo() {
            Lock lock;
            if (((MAMap.MAEntrySetView<K, V>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MAMap.MAEntrySetView<K, V>)this.c).viewInfo();
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public Object[] toArray() {
            Lock lock;
            if (((MAMap.MAEntrySetView<K, V>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                Object[] arr = this.c.toArray();
                for (int i = arr.length - 1; i >= 0; i--) {
                    arr[i] = MACollections.locked((MAMap.MAEntry<K, V>)arr[i], readWriteLock, usingInternalLock);
                }
                return arr;
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public MAMap.MAEntrySetView.MAEntrySetIterator<K, V> iterator() {
            Lock lock;
            if (((MAMap.MAEntrySetView<K, V>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MAMap.MAEntrySetView<K, V>)this.c).iterator(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedMAMapMAValuesView<K, V> extends LockedMACollection<V> implements MAMap.MAValuesView<K, V> {

        LockedMAMapMAValuesView(MAMap.MAValuesView<K, V> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMAMapMAValuesView<K, V>((MAMap.MAValuesView<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        public void addValuesElementListener(ValuesElementListener<? super K, ? super V> listener) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                ((MAMap.MAValuesView<K, V>)this.c).addValuesElementListener(listener);
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public void removeValuesElementListener(ValuesElementListener<? super K, ? super V> listener) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                ((MAMap.MAValuesView<K, V>)this.c).removeValuesElementListener(listener);
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public MAMap.MAValuesView.MAValuesIterator<K, V> iterator() {
            Lock lock;
            if (((MAMap.MAValuesView<K, V>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MAMap.MAValuesView<K, V>)this.c).iterator(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public ViewInfo viewInfo() {
            Lock lock;
            if (((MAMap.MAValuesView<K, V>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MAMap.MAValuesView<K, V>)this.c).viewInfo();
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedMAMapMAKeySetView<K, V> extends LockedMASet<K> implements MAMap.MAKeySetView<K, V> {

        LockedMAMapMAKeySetView(MAMap.MAKeySetView<K, V> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMAMapMAKeySetView<K, V>((MAMap.MAKeySetView<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        public void removeKeySetElementListener(KeySetElementListener<? super K, ? super V> listener) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                ((MAMap.MAKeySetView<K, V>)this.c).removeKeySetElementListener(listener);
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public MAMap.MAKeySetView.MAKeySetIterator<K, V> iterator() {
            Lock lock;
            if (((MAMap.MAKeySetView<K, V>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MAMap.MAKeySetView<K, V>)this.c).iterator(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public ViewInfo viewInfo() {
            Lock lock;
            if (((MAMap.MAKeySetView<K, V>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MAMap.MAKeySetView<K, V>)this.c).viewInfo();
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public void addKeySetElementListener(KeySetElementListener<? super K, ? super V> listener) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                ((MAMap.MAKeySetView<K, V>)this.c).addKeySetElementListener(listener);
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedMASet<E> extends LockedMACollection<E> implements MASet<E> {

        LockedMASet(MASet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @Deprecated //Only for deserialization
        LockedMASet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMASet<E>((MASet<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public ReplacementRule replacementRule() {
            Lock lock;
            if (((MASet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((MASet<E>)this.c).replacementRule();
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedMASetWithSerializable<E> extends LockedMASet<E> implements Serializable {

        private static final long serialVersionUID = -7799659594946640367L;

        LockedMASetWithSerializable(MASet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMASetWithSerializable<E>((MASet<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (MASet<E>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedMACollection<E> extends LockedXCollection<E> implements MACollection<E> {

        LockedMACollection(MACollection<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @Deprecated //Only for deserialization
        LockedMACollection() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMACollection<E>((MACollection<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public MACollection.MAIterator<E> iterator() {
            Lock lock;
            if (((MACollection<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((MACollection<E>)this.c).iterator(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public void removeElementListener(ElementListener<? super E> listener) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                ((MACollection<E>)this.c).removeElementListener(listener);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public void addElementListener(ElementListener<? super E> listener) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                ((MACollection<E>)this.c).addElementListener(listener);
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedMACollectionWithSerializable<E> extends LockedMACollection<E> implements Serializable {

        private static final long serialVersionUID = 5249650926509886681L;

        LockedMACollectionWithSerializable(MACollection<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMACollectionWithSerializable<E>((MACollection<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (MACollection<E>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedXListXListView<E> extends LockedXList<E> implements XList.XListView<E> {

        LockedXListXListView(XList.XListView<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXListXListView<E>((XList.XListView<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public ViewInfo viewInfo() {
            Lock lock;
            if (((XList.XListView<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XList.XListView<E>)this.c).viewInfo();
            } finally {
                lock.unlock();
            }
        }
    }
    private static class LockedXListXListViewWithRandomAccess<E> extends LockedXListXListView<E> implements RandomAccess {

        LockedXListXListViewWithRandomAccess(XList.XListView<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXListXListViewWithRandomAccess<E>((XList.XListView<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (XList.XListView<E>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }


    private static class LockedXList<E> extends LockedXCollection<E> implements XList<E> {

        LockedXList(XList<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockedXList() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXList<E>((XList<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public BidiType bidiType() {
            Lock lock;
            if (((XList<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XList<E>)this.c).bidiType();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public int indexOf(Object o) {
            Lock lock;
            if (((XList<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XList<E>)this.c).indexOf(o);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public int lastIndexOf(Object o) {
            Lock lock;
            if (((XList<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XList<E>)this.c).lastIndexOf(o);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E set(int index, E e) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((XList<E>)this.c).set(index, e);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XList.XListIterator<E> listIterator() {
            Lock lock;
            if (((XList<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XList<E>)this.c).listIterator(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E get(int index) {
            Lock lock;
            if (((XList<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XList<E>)this.c).get(index);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XList.XListIterator<E> listIterator(int index) {
            Lock lock;
            if (((XList<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XList<E>)this.c).listIterator(index), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XList.XListIterator<E> iterator() {
            Lock lock;
            if (((XList<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XList<E>)this.c).iterator(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XList.XListView<E> subList(int from, int to) {
            Lock lock;
            if (((XList<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XList<E>)this.c).subList(from, to), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E remove(int index) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((XList<E>)this.c).remove(index);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public void add(int index, E e) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                ((XList<E>)this.c).add(index, e);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public boolean addAll(int index, Collection<? extends E> c) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((XList<E>)this.c).addAll(index, c);
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedXListWithSerializable<E> extends LockedXList<E> implements Serializable {

        private static final long serialVersionUID = -2895749671544789463L;

        LockedXListWithSerializable(XList<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXListWithSerializable<E>((XList<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (XList<E>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedXListWithRandomAccess<E> extends LockedXList<E> implements RandomAccess {

        LockedXListWithRandomAccess(XList<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXListWithRandomAccess<E>((XList<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (XList<E>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }


    private static class LockedXListWithSerializableRandomAccess<E> extends LockedXList<E> implements Serializable, RandomAccess {

        private static final long serialVersionUID = 4557127139549144617L;

        LockedXListWithSerializableRandomAccess(XList<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXListWithSerializableRandomAccess<E>((XList<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (XList<E>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedXOrderedMapXOrderedKeySetView<K> extends LockedXOrderedSetXOrderedSetView<K> implements XOrderedMap.XOrderedKeySetView<K> {

        LockedXOrderedMapXOrderedKeySetView(XOrderedMap.XOrderedKeySetView<K> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXOrderedMapXOrderedKeySetView<K>((XOrderedMap.XOrderedKeySetView<K>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public XOrderedMap.XOrderedKeySetView<K> descendingSet() {
            Lock lock;
            if (((XOrderedMap.XOrderedKeySetView<K>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XOrderedMap.XOrderedKeySetView<K>)this.c).descendingSet(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedXOrderedSetXOrderedSetView<E> extends LockedXOrderedSet<E> implements XOrderedSet.XOrderedSetView<E> {

        LockedXOrderedSetXOrderedSetView(XOrderedSet.XOrderedSetView<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXOrderedSetXOrderedSetView<E>((XOrderedSet.XOrderedSetView<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public ViewInfo viewInfo() {
            Lock lock;
            if (((XOrderedSet.XOrderedSetView<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XOrderedSet.XOrderedSetView<E>)this.c).viewInfo();
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedXOrderedSet<E> extends LockedXSet<E> implements XOrderedSet<E> {

        LockedXOrderedSet(XOrderedSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockedXOrderedSet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXOrderedSet<E>((XOrderedSet<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public XCollection.XIterator<E> descendingIterator() {
            Lock lock;
            if (((XOrderedSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XOrderedSet<E>)this.c).descendingIterator(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XOrderedSet.XOrderedSetView<E> descendingSet() {
            Lock lock;
            if (((XOrderedSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XOrderedSet<E>)this.c).descendingSet(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public OrderAdjustMode replaceMode() {
            Lock lock;
            if (((XOrderedSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XOrderedSet<E>)this.c).replaceMode();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public boolean headAppend() {
            Lock lock;
            if (((XOrderedSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XOrderedSet<E>)this.c).headAppend();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E last() {
            Lock lock;
            if (((XOrderedSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XOrderedSet<E>)this.c).last();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E first() {
            Lock lock;
            if (((XOrderedSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XOrderedSet<E>)this.c).first();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E pollLast() {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((XOrderedSet<E>)this.c).pollLast();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E pollFirst() {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((XOrderedSet<E>)this.c).pollFirst();
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedXOrderedSetWithSerializable<E> extends LockedXOrderedSet<E> implements Serializable {

        private static final long serialVersionUID = 4153101765527872818L;

        LockedXOrderedSetWithSerializable(XOrderedSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXOrderedSetWithSerializable<E>((XOrderedSet<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (XOrderedSet<E>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedXNavigableMapXNavigableKeySetView<K> extends LockedXNavigableSetXNavigableSetView<K> implements XNavigableMap.XNavigableKeySetView<K> {

        LockedXNavigableMapXNavigableKeySetView(XNavigableMap.XNavigableKeySetView<K> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXNavigableMapXNavigableKeySetView<K>((XNavigableMap.XNavigableKeySetView<K>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public XNavigableMap.XNavigableKeySetView<K> headSet(K toKey) {
            Lock lock;
            if (((XNavigableMap.XNavigableKeySetView<K>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableMap.XNavigableKeySetView<K>)this.c).headSet(toKey), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XNavigableMap.XNavigableKeySetView<K> headSet(K toKey, boolean inclusive) {
            Lock lock;
            if (((XNavigableMap.XNavigableKeySetView<K>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableMap.XNavigableKeySetView<K>)this.c).headSet(toKey, inclusive), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XNavigableMap.XNavigableKeySetView<K> tailSet(K fromKey) {
            Lock lock;
            if (((XNavigableMap.XNavigableKeySetView<K>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableMap.XNavigableKeySetView<K>)this.c).tailSet(fromKey), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XNavigableMap.XNavigableKeySetView<K> tailSet(K fromKey, boolean inclusive) {
            Lock lock;
            if (((XNavigableMap.XNavigableKeySetView<K>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableMap.XNavigableKeySetView<K>)this.c).tailSet(fromKey, inclusive), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XNavigableMap.XNavigableKeySetView<K> subSet(K fromKey, K toKey) {
            Lock lock;
            if (((XNavigableMap.XNavigableKeySetView<K>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableMap.XNavigableKeySetView<K>)this.c).subSet(fromKey, toKey), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XNavigableMap.XNavigableKeySetView<K> descendingSet() {
            Lock lock;
            if (((XNavigableMap.XNavigableKeySetView<K>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableMap.XNavigableKeySetView<K>)this.c).descendingSet(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XNavigableMap.XNavigableKeySetView<K> subSet(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) {
            Lock lock;
            if (((XNavigableMap.XNavigableKeySetView<K>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableMap.XNavigableKeySetView<K>)this.c).subSet(fromKey, fromInclusive, toKey, toInclusive), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedXNavigableSetXNavigableSetView<E> extends LockedXNavigableSet<E> implements XNavigableSet.XNavigableSetView<E> {

        LockedXNavigableSetXNavigableSetView(XNavigableSet.XNavigableSetView<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXNavigableSetXNavigableSetView<E>((XNavigableSet.XNavigableSetView<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public ViewInfo viewInfo() {
            Lock lock;
            if (((XNavigableSet.XNavigableSetView<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XNavigableSet.XNavigableSetView<E>)this.c).viewInfo();
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedXNavigableSet<E> extends LockedXSortedSet<E> implements XNavigableSet<E> {

        LockedXNavigableSet(XNavigableSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockedXNavigableSet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXNavigableSet<E>((XNavigableSet<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public XNavigableSet.XNavigableSetView<E> subSet(E fromElement, E toElement) {
            Lock lock;
            if (((XNavigableSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableSet<E>)this.c).subSet(fromElement, toElement), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E higher(E e) {
            Lock lock;
            if (((XNavigableSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XNavigableSet<E>)this.c).higher(e);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XNavigableSet.XNavigableSetView<E> headSet(E toElement) {
            Lock lock;
            if (((XNavigableSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableSet<E>)this.c).headSet(toElement), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E lower(E e) {
            Lock lock;
            if (((XNavigableSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XNavigableSet<E>)this.c).lower(e);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XCollection.XIterator<E> descendingIterator() {
            Lock lock;
            if (((XNavigableSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableSet<E>)this.c).descendingIterator(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XNavigableSet.XNavigableSetView<E> tailSet(E fromElement) {
            Lock lock;
            if (((XNavigableSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableSet<E>)this.c).tailSet(fromElement), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E floor(E e) {
            Lock lock;
            if (((XNavigableSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XNavigableSet<E>)this.c).floor(e);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XNavigableSet.XNavigableSetView<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {
            Lock lock;
            if (((XNavigableSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableSet<E>)this.c).subSet(fromElement, fromInclusive, toElement, toInclusive), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XNavigableSet.XNavigableSetView<E> descendingSet() {
            Lock lock;
            if (((XNavigableSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableSet<E>)this.c).descendingSet(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E ceiling(E e) {
            Lock lock;
            if (((XNavigableSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XNavigableSet<E>)this.c).ceiling(e);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XNavigableSet.XNavigableSetView<E> tailSet(E fromElement, boolean inclusive) {
            Lock lock;
            if (((XNavigableSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableSet<E>)this.c).tailSet(fromElement, inclusive), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XNavigableSet.XNavigableSetView<E> headSet(E toElement, boolean inclusive) {
            Lock lock;
            if (((XNavigableSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XNavigableSet<E>)this.c).headSet(toElement, inclusive), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E pollLast() {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((XNavigableSet<E>)this.c).pollLast();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E pollFirst() {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((XNavigableSet<E>)this.c).pollFirst();
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedXNavigableSetWithSerializable<E> extends LockedXNavigableSet<E> implements Serializable {

        private static final long serialVersionUID = 3947452331306198048L;

        LockedXNavigableSetWithSerializable(XNavigableSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXNavigableSetWithSerializable<E>((XNavigableSet<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (XNavigableSet<E>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedXSortedMapXSortedKeySetView<K> extends LockedXSortedSetXSortedSetView<K> implements XSortedMap.XSortedKeySetView<K> {

        LockedXSortedMapXSortedKeySetView(XSortedMap.XSortedKeySetView<K> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXSortedMapXSortedKeySetView<K>((XSortedMap.XSortedKeySetView<K>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public XSortedMap.XSortedKeySetView<K> subSet(K fromKey, K toKey) {
            Lock lock;
            if (((XSortedMap.XSortedKeySetView<K>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XSortedMap.XSortedKeySetView<K>)this.c).subSet(fromKey, toKey), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XSortedMap.XSortedKeySetView<K> headSet(K toKey) {
            Lock lock;
            if (((XSortedMap.XSortedKeySetView<K>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XSortedMap.XSortedKeySetView<K>)this.c).headSet(toKey), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XSortedMap.XSortedKeySetView<K> tailSet(K fromKey) {
            Lock lock;
            if (((XSortedMap.XSortedKeySetView<K>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XSortedMap.XSortedKeySetView<K>)this.c).tailSet(fromKey), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedXSortedSetXSortedSetView<E> extends LockedXSortedSet<E> implements XSortedSet.XSortedSetView<E> {

        LockedXSortedSetXSortedSetView(XSortedSet.XSortedSetView<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXSortedSetXSortedSetView<E>((XSortedSet.XSortedSetView<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public ViewInfo viewInfo() {
            Lock lock;
            if (((XSortedSet.XSortedSetView<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XSortedSet.XSortedSetView<E>)this.c).viewInfo();
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedXSortedSet<E> extends LockedXSet<E> implements XSortedSet<E> {

        LockedXSortedSet(XSortedSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @Deprecated //Only for deserialization
        LockedXSortedSet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXSortedSet<E>((XSortedSet<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public XSortedSet.XSortedSetView<E> tailSet(E fromElement) {
            Lock lock;
            if (((XSortedSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XSortedSet<E>)this.c).tailSet(fromElement), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XSortedSet.XSortedSetView<E> subSet(E fromElement, E toElement) {
            Lock lock;
            if (((XSortedSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XSortedSet<E>)this.c).subSet(fromElement, toElement), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E last() {
            Lock lock;
            if (((XSortedSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XSortedSet<E>)this.c).last();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E first() {
            Lock lock;
            if (((XSortedSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XSortedSet<E>)this.c).first();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public Comparator<? super E> comparator() {
            Lock lock;
            if (((XSortedSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XSortedSet<E>)this.c).comparator();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public XSortedSet.XSortedSetView<E> headSet(E toElement) {
            Lock lock;
            if (((XSortedSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XSortedSet<E>)this.c).headSet(toElement), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedXSortedSetWithSerializable<E> extends LockedXSortedSet<E> implements Serializable {

        private static final long serialVersionUID = -1386062626L;

        LockedXSortedSetWithSerializable(XSortedSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXSortedSetWithSerializable<E>((XSortedSet<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (XSortedSet<E>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedXMapXKeySetView<K> extends LockedXSet<K> implements XMap.XKeySetView<K> {

        LockedXMapXKeySetView(XMap.XKeySetView<K> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXMapXKeySetView<K>((XMap.XKeySetView<K>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public ViewInfo viewInfo() {
            Lock lock;
            if (((XMap.XKeySetView<K>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XMap.XKeySetView<K>)this.c).viewInfo();
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedXMapXEntrySetView<K, V> extends LockedXSet<Map.Entry<K, V>> implements XMap.XEntrySetView<K, V> {

        LockedXMapXEntrySetView(XMap.XEntrySetView<K, V> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXMapXEntrySetView<K, V>((XMap.XEntrySetView<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        public <T> T[] toArray(T[] a) {
            Lock lock;
            if (((XMap.XEntrySetView<K, V>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                Object[] arr = this.c.toArray(a.length==0 ? a : (Object[])Array.newInstance(a.getClass().getComponentType(), 0));
                for (int i = arr.length - 1; i >= 0; i--) {
                    arr[i] = MACollections.locked((XMap.XEntry<K, V>)arr[i], readWriteLock, usingInternalLock);
                }
                if (arr.length > a.length) {
                    return (T[])arr;
                }
                System.arraycopy(arr, 0, a, 0, arr.length);
                if (a.length > arr.length) {
                    a[arr.length] = null;
                }
                return a;
            } finally {
                lock.unlock();
            }
        }

        @Deprecated
        @Override
        public boolean add(Map.Entry<K, V> entry) {
            throw new UnsupportedOperationException(
                notSupported("boolean org.babyfish.collection.XMap.XEntrySetView<K, V>.add(java.util.Map.Entry<K, V>)")
            );
        }

        @SuppressWarnings("unchecked")
        @Override
        public ViewInfo viewInfo() {
            Lock lock;
            if (((XMap.XEntrySetView<K, V>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XMap.XEntrySetView<K, V>)this.c).viewInfo();
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public Object[] toArray() {
            Lock lock;
            if (((XMap.XEntrySetView<K, V>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                Object[] arr = this.c.toArray();
                for (int i = arr.length - 1; i >= 0; i--) {
                    arr[i] = MACollections.locked((XMap.XEntry<K, V>)arr[i], readWriteLock, usingInternalLock);
                }
                return arr;
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public XMap.XEntrySetView.XEntrySetIterator<K, V> iterator() {
            Lock lock;
            if (((XMap.XEntrySetView<K, V>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XMap.XEntrySetView<K, V>)this.c).iterator(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedXSet<E> extends LockedXCollection<E> implements XSet<E> {

        LockedXSet(XSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @Deprecated //Only for deserialization
        LockedXSet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXSet<E>((XSet<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public ReplacementRule replacementRule() {
            Lock lock;
            if (((XSet<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XSet<E>)this.c).replacementRule();
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedXSetWithSerializable<E> extends LockedXSet<E> implements Serializable {

        private static final long serialVersionUID = -1450122687L;

        LockedXSetWithSerializable(XSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXSetWithSerializable<E>((XSet<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (XSet<E>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedXMapXValuesView<V> extends LockedXCollection<V> implements XMap.XValuesView<V> {

        LockedXMapXValuesView(XMap.XValuesView<V> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXMapXValuesView<V>((XMap.XValuesView<V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public ViewInfo viewInfo() {
            Lock lock;
            if (((XMap.XValuesView<V>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XMap.XValuesView<V>)this.c).viewInfo();
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedXCollection<E> extends LockedCollection<E> implements XCollection<E> {

        LockedXCollection(XCollection<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @Deprecated //Only for deserialization
        LockedXCollection() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXCollection<E>((XCollection<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public XCollection.XIterator<E> iterator() {
            Lock lock;
            if (((XCollection<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((XCollection<E>)this.c).iterator(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public UnifiedComparator<? super E> unifiedComparator() {
            Lock lock;
            if (((XCollection<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XCollection<E>)this.c).unifiedComparator();
            } finally {
                lock.unlock();
            }
        }
        
        @Override
        public boolean isReadWriteLockSupported() {
            return ((XCollection<E>)this.c).isReadWriteLockSupported();
        }

        @Override
        public void validate(E e) {
            Lock lock;
            if (((XCollection<E>)this.c).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                ((XCollection<E>)this.c).validate(e);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public void removeValidator(Validator<E> validator) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                ((XCollection<E>)this.c).removeValidator(validator);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public void addValidator(Validator<E> validator) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                ((XCollection<E>)this.c).addValidator(validator);
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedXCollectionWithSerializable<E> extends LockedXCollection<E> implements Serializable {

        private static final long serialVersionUID = -2073362801476166999L;

        LockedXCollectionWithSerializable(XCollection<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXCollectionWithSerializable<E>((XCollection<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (XCollection<E>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedStandardMapEntrySet<K, V> extends LockedSet<Map.Entry<K, V>> implements StandardMap.EntrySet<K, V> {

        LockedStandardMapEntrySet(StandardMap.EntrySet<K, V> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockedStandardMapEntrySet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedStandardMapEntrySet<K, V>((StandardMap.EntrySet<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        public Object[] toArray() {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                Object[] arr = this.c.toArray();
                for (int i = arr.length - 1; i >= 0; i--) {
                    arr[i] = MACollections.locked((Map.Entry<K, V>)arr[i], readWriteLock, usingInternalLock);
                }
                return arr;
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public <T> T[] toArray(T[] a) {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                Object[] arr = this.c.toArray(a.length==0 ? a : (Object[])Array.newInstance(a.getClass().getComponentType(), 0));
                for (int i = arr.length - 1; i >= 0; i--) {
                    arr[i] = MACollections.locked((Map.Entry<K, V>)arr[i], readWriteLock, usingInternalLock);
                }
                if (arr.length > a.length) {
                    return (T[])arr;
                }
                System.arraycopy(arr, 0, a, 0, arr.length);
                if (a.length > arr.length) {
                    a[arr.length] = null;
                }
                return a;
            } finally {
                lock.unlock();
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public StandardMap.EntrySet.EntryIterator<K, V> iterator() {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((StandardMap.EntrySet<K, V>)this.c).iterator(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedStandardMapEntrySetWithSerializable<K, V> extends LockedStandardMapEntrySet<K, V> implements Serializable {

        private static final long serialVersionUID = -1760000784L;

        LockedStandardMapEntrySetWithSerializable(StandardMap.EntrySet<K, V> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedStandardMapEntrySetWithSerializable<K, V>((StandardMap.EntrySet<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (StandardMap.EntrySet<K, V>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedList<E> extends LockedCollection<E> implements List<E> {

        LockedList(List<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockedList() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedList<E>((List<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public int indexOf(Object o) {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((List<E>)this.c).indexOf(o);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public int lastIndexOf(Object o) {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((List<E>)this.c).lastIndexOf(o);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public List<E> subList(int from, int to) {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((List<E>)this.c).subList(from, to), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E set(int index, E e) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((List<E>)this.c).set(index, e);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public ListIterator<E> listIterator() {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((List<E>)this.c).listIterator(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E get(int index) {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((List<E>)this.c).get(index);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public ListIterator<E> listIterator(int index) {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((List<E>)this.c).listIterator(index), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E remove(int index) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((List<E>)this.c).remove(index);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public void add(int index, E e) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                ((List<E>)this.c).add(index, e);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public boolean addAll(int index, Collection<? extends E> c) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((List<E>)this.c).addAll(index, c);
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedListWithSerializable<E> extends LockedList<E> implements Serializable {

        private static final long serialVersionUID = -2504055507978419731L;

        LockedListWithSerializable(List<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedListWithSerializable<E>((List<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (List<E>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedListWithRandomAccess<E> extends LockedList<E> implements RandomAccess {

        LockedListWithRandomAccess(List<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedListWithRandomAccess<E>((List<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (List<E>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }


    private static class LockedListWithSerializableRandomAccess<E> extends LockedList<E> implements Serializable, RandomAccess {

        private static final long serialVersionUID = 8014780889866568173L;

        LockedListWithSerializableRandomAccess(List<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedListWithSerializableRandomAccess<E>((List<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (List<E>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedNavigableSet<E> extends LockedSortedSet<E> implements NavigableSet<E> {

        LockedNavigableSet(NavigableSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockedNavigableSet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedNavigableSet<E>((NavigableSet<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public NavigableSet<E> tailSet(E fromElement, boolean inclusive) {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((NavigableSet<E>)this.c).tailSet(fromElement, inclusive), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E floor(E e) {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((NavigableSet<E>)this.c).floor(e);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E ceiling(E e) {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((NavigableSet<E>)this.c).ceiling(e);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E higher(E e) {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((NavigableSet<E>)this.c).higher(e);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public NavigableSet<E> headSet(E toElement, boolean inclusive) {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((NavigableSet<E>)this.c).headSet(toElement, inclusive), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public Iterator<E> descendingIterator() {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((NavigableSet<E>)this.c).descendingIterator(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public NavigableSet<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((NavigableSet<E>)this.c).subSet(fromElement, fromInclusive, toElement, toInclusive), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E lower(E e) {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((NavigableSet<E>)this.c).lower(e);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E pollLast() {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((NavigableSet<E>)this.c).pollLast();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public NavigableSet<E> descendingSet() {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((NavigableSet<E>)this.c).descendingSet(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E pollFirst() {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return ((NavigableSet<E>)this.c).pollFirst();
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedNavigableSetWithSerializable<E> extends LockedNavigableSet<E> implements Serializable {

        private static final long serialVersionUID = 3267848335676718052L;

        LockedNavigableSetWithSerializable(NavigableSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedNavigableSetWithSerializable<E>((NavigableSet<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (NavigableSet<E>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedSortedSet<E> extends LockedSet<E> implements SortedSet<E> {

        LockedSortedSet(SortedSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @Deprecated //Only for deserialization
        LockedSortedSet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedSortedSet<E>((SortedSet<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public SortedSet<E> tailSet(E fromElement) {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((SortedSet<E>)this.c).tailSet(fromElement), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public SortedSet<E> subSet(E fromElement, E toElement) {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((SortedSet<E>)this.c).subSet(fromElement, toElement), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E last() {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((SortedSet<E>)this.c).last();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public E first() {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((SortedSet<E>)this.c).first();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public Comparator<? super E> comparator() {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((SortedSet<E>)this.c).comparator();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public SortedSet<E> headSet(E toElement) {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(((SortedSet<E>)this.c).headSet(toElement), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedSortedSetWithSerializable<E> extends LockedSortedSet<E> implements Serializable {

        private static final long serialVersionUID = -1519813734L;

        LockedSortedSetWithSerializable(SortedSet<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedSortedSetWithSerializable<E>((SortedSet<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (SortedSet<E>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedSet<E> extends LockedCollection<E> implements Set<E> {

        LockedSet(Set<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @Deprecated //Only for deserialization
        LockedSet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedSet<E>((Set<E>)obj, this.readWriteLock, this.usingInternalLock);
        }
    }

    private static class LockedSetWithSerializable<E> extends LockedSet<E> implements Serializable {

        private static final long serialVersionUID = -2112569859L;

        LockedSetWithSerializable(Set<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedSetWithSerializable<E>((Set<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (Set<E>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedCollection<E> extends LockedProxy implements Collection<E> {

        Collection<E> c;

        LockedCollection(Collection<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(readWriteLock, usingInternalLock);
            this.c = c;
        }

        @Deprecated //Only for deserialization
        LockedCollection() {
        }

        @Override
        Object getInnerObject() {
            return this.c;
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedCollection<E>((Collection<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public String toString() {
            return this.c.toString();
        }

        @Override
        public boolean isEmpty() {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return this.c.isEmpty();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public boolean retainAll(Collection<? extends Object> c) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return this.c.retainAll(c);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public boolean remove(Object o) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return this.c.remove(o);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public void clear() {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                this.c.clear();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public boolean contains(Object o) {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return this.c.contains(o);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public Iterator<E> iterator() {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return MACollections.locked(this.c.iterator(), this.readWriteLock, this.usingInternalLock);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public boolean removeAll(Collection<? extends Object> c) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return this.c.removeAll(c);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public boolean addAll(Collection<? extends E> c) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return this.c.addAll(c);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public Object[] toArray() {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return this.c.toArray();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public boolean add(E e) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return this.c.add(e);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public int hashCode() {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return this.c.hashCode();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public <T> T[] toArray(T[] a) {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return this.c.toArray(a);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public boolean equals(Object obj) {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return this.c.equals(obj);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public int size() {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return this.c.size();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public boolean containsAll(Collection<? extends Object> c) {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.c)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return this.c.containsAll(c);
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedCollectionWithSerializable<E> extends LockedCollection<E> implements Serializable {

        private static final long serialVersionUID = -8235781585570507923L;

        LockedCollectionWithSerializable(Collection<E> c, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(c, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedCollectionWithSerializable<E>((Collection<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (Collection<E>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedMAMapMAValuesViewMAValuesIterator<K, V> extends LockedMACollectionMAIterator<V> implements MAMap.MAValuesView.MAValuesIterator<K, V> {

        LockedMAMapMAValuesViewMAValuesIterator(MAMap.MAValuesView.MAValuesIterator<K, V> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(itr, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMAMapMAValuesViewMAValuesIterator<K, V>((MAMap.MAValuesView.MAValuesIterator<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public void addValuesElementListener(ValuesElementListener<? super K, ? super V> listener) {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("void org.babyfish.collection.event.ValuesElementModificationAware<K, V>.addValuesElementListener(org.babyfish.collection.event.ValuesElementListener<? super K, ? super V>)")
            );
        }

        @Override
        public void removeValuesElementListener(ValuesElementListener<? super K, ? super V> listener) {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("void org.babyfish.collection.event.ValuesElementModificationAware<K, V>.removeValuesElementListener(org.babyfish.collection.event.ValuesElementListener<? super K, ? super V>)")
            );
        }
    }

    private static class LockedMAMapMAEntrySetViewMAEntrySetIterator<K, V> extends LockedMACollectionMAIterator<Map.Entry<K, V>> implements MAMap.MAEntrySetView.MAEntrySetIterator<K, V> {

        LockedMAMapMAEntrySetViewMAEntrySetIterator(MAMap.MAEntrySetView.MAEntrySetIterator<K, V> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(itr, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMAMapMAEntrySetViewMAEntrySetIterator<K, V>((MAMap.MAEntrySetView.MAEntrySetIterator<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public MAMap.MAEntry<K, V> next() {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("org.babyfish.collection.MAMap.MAEntry<K, V> org.babyfish.collection.MAMap$MAEntrySetView.MAEntrySetIterator<K, V>.next()")
            );
        }
    }

    private static class LockedMAListMAListIterator<E> extends LockedMACollectionMAIterator<E> implements MAList.MAListIterator<E> {

        LockedMAListMAListIterator(MAList.MAListIterator<E> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(itr, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMAListMAListIterator<E>((MAList.MAListIterator<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public void removeListElementListener(ListElementListener<? super E> listener) {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("void org.babyfish.collection.MAList.MAListIterator<E>.removeListElementListener(org.babyfish.collection.event.ListElementListener<? super E>)")
            );
        }

        @Override
        public void add(E e) {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("void java.util.ListIterator<E>.add(E)")
            );
        }

        @Override
        public boolean hasPrevious() {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("boolean java.util.ListIterator<E>.hasPrevious()")
            );
        }

        @Override
        public int previousIndex() {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("int java.util.ListIterator<E>.previousIndex()")
            );
        }

        @Override
        public void addListElementListener(ListElementListener<? super E> listener) {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("void org.babyfish.collection.MAList.MAListIterator<E>.addListElementListener(org.babyfish.collection.event.ListElementListener<? super E>)")
            );
        }

        @Override
        public E previous() {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("E java.util.ListIterator<E>.previous()")
            );
        }

        @Override
        public int nextIndex() {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("int java.util.ListIterator<E>.nextIndex()")
            );
        }

        @Override
        public void set(E e) {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("void java.util.ListIterator<E>.set(E)")
            );
        }
    }

    private static class LockedMAMapMAKeySetViewMAKeySetIterator<K, V> extends LockedMACollectionMAIterator<K> implements MAMap.MAKeySetView.MAKeySetIterator<K, V> {

        LockedMAMapMAKeySetViewMAKeySetIterator(MAMap.MAKeySetView.MAKeySetIterator<K, V> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(itr, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMAMapMAKeySetViewMAKeySetIterator<K, V>((MAMap.MAKeySetView.MAKeySetIterator<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public void removeKeySetElementListener(KeySetElementListener<? super K, ? super V> listener) {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.removeKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
            );
        }

        @Override
        public void addKeySetElementListener(KeySetElementListener<? super K, ? super V> listener) {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.addKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
            );
        }
    }

    private static class LockedMACollectionMAIterator<E> extends LockedXCollectionXIterator<E> implements MACollection.MAIterator<E> {

        LockedMACollectionMAIterator(MACollection.MAIterator<E> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(itr, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMACollectionMAIterator<E>((MACollection.MAIterator<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public void addElementListener(ElementListener<? super E> listener) {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("void org.babyfish.collection.MACollection.MAIterator<E>.addElementListener(org.babyfish.collection.event.ElementListener<? super E>)")
            );
        }

        @Override
        public void removeElementListener(ElementListener<? super E> listener) {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("void org.babyfish.collection.MACollection.MAIterator<E>.removeElementListener(org.babyfish.collection.event.ElementListener<? super E>)")
            );
        }
    }

    private static class LockedXListXListIterator<E> extends LockedXCollectionXIterator<E> implements XList.XListIterator<E> {

        LockedXListXListIterator(XList.XListIterator<E> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(itr, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXListXListIterator<E>((XList.XListIterator<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public void add(E e) {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("void java.util.ListIterator<E>.add(E)")
            );
        }

        @Override
        public boolean hasPrevious() {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("boolean java.util.ListIterator<E>.hasPrevious()")
            );
        }

        @Override
        public E previous() {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("E java.util.ListIterator<E>.previous()")
            );
        }

        @Override
        public int previousIndex() {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("int java.util.ListIterator<E>.previousIndex()")
            );
        }

        @Override
        public int nextIndex() {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("int java.util.ListIterator<E>.nextIndex()")
            );
        }

        @Override
        public void set(E e) {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("void java.util.ListIterator<E>.set(E)")
            );
        }
    }

    private static class LockedXMapXEntrySetViewXEntrySetIterator<K, V> extends LockedXCollectionXIterator<Map.Entry<K, V>> implements XMap.XEntrySetView.XEntrySetIterator<K, V> {

        LockedXMapXEntrySetViewXEntrySetIterator(XMap.XEntrySetView.XEntrySetIterator<K, V> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(itr, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXMapXEntrySetViewXEntrySetIterator<K, V>((XMap.XEntrySetView.XEntrySetIterator<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public XMap.XEntry<K, V> next() {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("org.babyfish.collection.XMap.XEntry<K, V> org.babyfish.collection.XMap$XEntrySetView.XEntrySetIterator<K, V>.next()")
            );
        }
    }

    private static class LockedXCollectionXIterator<E> extends LockedIterator<E> implements XCollection.XIterator<E> {

        LockedXCollectionXIterator(XCollection.XIterator<E> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(itr, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXCollectionXIterator<E>((XCollection.XIterator<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public UnifiedComparator<? super E> unifiedComparator() {
            return ((XCollection.XIterator<E>)this.itr).unifiedComparator();
        }

        @Override
        public ViewInfo viewInfo() {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("org.babyfish.view.ViewInfo org.babyfish.collection.XCollection.XIterator<E>.viewInfo()")
            );
        }

        @Override
        public boolean isReadWriteLockSupported() {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("boolean org.babyfish.lang.LockDescriptor.isReadWriteLockSupported()")
            );
        }
    }

    private static class LockedStandardMapEntrySetEntryIterator<K, V> extends LockedIterator<Map.Entry<K, V>> implements StandardMap.EntrySet.EntryIterator<K, V> {

        LockedStandardMapEntrySetEntryIterator(StandardMap.EntrySet.EntryIterator<K, V> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(itr, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockedStandardMapEntrySetEntryIterator() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedStandardMapEntrySetEntryIterator<K, V>((StandardMap.EntrySet.EntryIterator<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public Map.Entry<K, V> next() {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("java.util.Map.Entry<K, V> org.babyfish.collection.MACollections$StandardMap$EntrySet.EntryIterator<K, V>.next()")
            );
        }
    }

    private static class LockedStandardMapEntrySetEntryIteratorWithSerializable<K, V> extends LockedStandardMapEntrySetEntryIterator<K, V> implements Serializable {

        private static final long serialVersionUID = -7782713102350089114L;

        LockedStandardMapEntrySetEntryIteratorWithSerializable(StandardMap.EntrySet.EntryIterator<K, V> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(itr, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedStandardMapEntrySetEntryIteratorWithSerializable<K, V>((StandardMap.EntrySet.EntryIterator<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.itr);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.itr = (StandardMap.EntrySet.EntryIterator<K, V>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedListIterator<E> extends LockedIterator<E> implements ListIterator<E> {

        LockedListIterator(ListIterator<E> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(itr, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockedListIterator() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedListIterator<E>((ListIterator<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public void add(E e) {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("void java.util.ListIterator<E>.add(E)")
            );
        }

        @Override
        public boolean hasPrevious() {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("boolean java.util.ListIterator<E>.hasPrevious()")
            );
        }

        @Override
        public E previous() {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("E java.util.ListIterator<E>.previous()")
            );
        }

        @Override
        public int previousIndex() {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("int java.util.ListIterator<E>.previousIndex()")
            );
        }

        @Override
        public int nextIndex() {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("int java.util.ListIterator<E>.nextIndex()")
            );
        }

        @Override
        public void set(E e) {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("void java.util.ListIterator<E>.set(E)")
            );
        }
    }

    private static class LockedListIteratorWithSerializable<E> extends LockedListIterator<E> implements Serializable {

        private static final long serialVersionUID = -2144662881L;

        LockedListIteratorWithSerializable(ListIterator<E> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(itr, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedListIteratorWithSerializable<E>((ListIterator<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.itr);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.itr = (ListIterator<E>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedIterator<E> extends LockedProxy implements Iterator<E> {

        Iterator<E> itr;

        LockedIterator(Iterator<E> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(readWriteLock, usingInternalLock);
            this.itr = itr;
        }

        @Deprecated //Only for deserialization
        LockedIterator() {
        }

        @Override
        Object getInnerObject() {
            return this.itr;
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedIterator<E>((Iterator<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public void remove() {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("void java.util.Iterator<E>.remove()")
            );
        }

        @Override
        public boolean hasNext() {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("boolean java.util.Iterator<E>.hasNext()")
            );
        }

        @Override
        public E next() {
            throw new RequiredLockingOperationException(
                mandatoryLockingObject("E java.util.Iterator<E>.next()")
            );
        }
    }

    private static class LockedIteratorWithSerializable<E> extends LockedIterator<E> implements Serializable {

        private static final long serialVersionUID = -1030476515L;

        LockedIteratorWithSerializable(Iterator<E> itr, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(itr, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedIteratorWithSerializable<E>((Iterator<E>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.itr);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.itr = (Iterator<E>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockedMAMapMAEntry<K, V> extends LockedXMapXEntry<K, V> implements MAMap.MAEntry<K, V> {

        LockedMAMapMAEntry(MAMap.MAEntry<K, V> e, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(e, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMAMapMAEntry<K, V>((MAMap.MAEntry<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public void removeElementListener(ElementListener<? super V> listener) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                ((MAMap.MAEntry<K, V>)this.e).removeElementListener(listener);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public void addEntryElementListener(EntryElementListener<? super K, ? super V> listener) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                ((MAMap.MAEntry<K, V>)this.e).addEntryElementListener(listener);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public void addElementListener(ElementListener<? super V> listener) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                ((MAMap.MAEntry<K, V>)this.e).addElementListener(listener);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public void removeEntryElementListener(EntryElementListener<? super K, ? super V> listener) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                ((MAMap.MAEntry<K, V>)this.e).removeEntryElementListener(listener);
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedXMapXEntry<K, V> extends LockedMapEntry<K, V> implements XMap.XEntry<K, V> {

        LockedXMapXEntry(XMap.XEntry<K, V> e, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(e, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedXMapXEntry<K, V>((XMap.XEntry<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public UnifiedComparator<? super K> keyUnifiedComparator() {
            Lock lock;
            if (((XMap.XEntry<K, V>)this.e).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XMap.XEntry<K, V>)this.e).keyUnifiedComparator();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public UnifiedComparator<? super Map.Entry<K, V>> unifiedComparator() {
            Lock lock;
            if (((XMap.XEntry<K, V>)this.e).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XMap.XEntry<K, V>)this.e).unifiedComparator();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public ViewInfo viewInfo() {
            Lock lock;
            if (((XMap.XEntry<K, V>)this.e).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XMap.XEntry<K, V>)this.e).viewInfo();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public boolean isAlive() {
            Lock lock;
            if (((XMap.XEntry<K, V>)this.e).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XMap.XEntry<K, V>)this.e).isAlive();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public UnifiedComparator<? super V> valueUnifiedComparator() {
            Lock lock;
            if (((XMap.XEntry<K, V>)this.e).isReadWriteLockSupported()) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return ((XMap.XEntry<K, V>)this.e).valueUnifiedComparator();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public boolean isReadWriteLockSupported() {
            return ((XMap.XEntry<K, V>)this.e).isReadWriteLockSupported();
        }
    }

    private static class LockedMapEntry<K, V> extends LockedProxy implements Map.Entry<K, V> {

        Map.Entry<K, V> e;

        LockedMapEntry(Map.Entry<K, V> e, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(readWriteLock, usingInternalLock);
            this.e = e;
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockedMapEntry() {
        }

        @Override
        Object getInnerObject() {
            return this.e;
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMapEntry<K, V>((Map.Entry<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        @Override
        public String toString() {
            return this.e.toString();
        }

        @Override
        public int hashCode() {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.e)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return this.e.hashCode();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public K getKey() {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.e)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return this.e.getKey();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public V getValue() {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.e)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return this.e.getValue();
            } finally {
                lock.unlock();
            }
        }

        @Override
        public boolean equals(Object obj) {
            Lock lock;
            if (MACollections.isReadWriteLockSupported(this.e)) {
                lock = this.readWriteLock.readLock();
            } else {
                lock = this.readWriteLock.writeLock();
            }
            lock.lock();
            try {
                return this.e.equals(obj);
            } finally {
                lock.unlock();
            }
        }

        @Override
        public V setValue(V value) {
            Lock lock = this.readWriteLock.writeLock();
            lock.lock();
            try {
                return this.e.setValue(value);
            } finally {
                lock.unlock();
            }
        }
    }

    private static class LockedMapEntryWithSerializable<K, V> extends LockedMapEntry<K, V> implements Serializable {

        private static final long serialVersionUID = -2111464538689699605L;

        LockedMapEntryWithSerializable(Map.Entry<K, V> e, ReadWriteLock readWriteLock, boolean usingInternalLock) {
            super(e, readWriteLock, usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockedMapEntryWithSerializable<K, V>((Map.Entry<K, V>)obj, this.readWriteLock, this.usingInternalLock);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.e);
            out.writeObject(this.readWriteLock);
            out.writeBoolean(this.usingInternalLock);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.e = (Map.Entry<K, V>)in.readObject();
            this.readWriteLock = (ReadWriteLock)in.readObject();
            this.usingInternalLock = (boolean)in.readBoolean();
        }
    }

    private static class LockingMAOrderedMapMAOrderedMapView<K, V> extends LockingMAOrderedMap<K, V> implements MAOrderedMap.MAOrderedMapView<K, V> {

        LockingMAOrderedMapMAOrderedMapView(MAOrderedMap.MAOrderedMapView<K, V> m, LockingManager lockingManager) {
            super(m, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMAOrderedMapMAOrderedMapView<K, V>((MAOrderedMap.MAOrderedMapView<K, V>)obj, this.lockingManager);
        }

        @Override
        public ViewInfo viewInfo() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            return ((MAOrderedMap.MAOrderedMapView<K, V>)this.m).viewInfo();
        }
    }

    private static class LockingMAOrderedMap<K, V> extends LockingMAMap<K, V> implements MAOrderedMap<K, V> {

        LockingMAOrderedMap(MAOrderedMap<K, V> m, LockingManager lockingManager) {
            super(m, lockingManager);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockingMAOrderedMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMAOrderedMap<K, V>((MAOrderedMap<K, V>)obj, this.lockingManager);
        }

        @Override
        public Map.Entry<K, V> pollLastEntry() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.Map.Entry<K, V> org.babyfish.collection.XOrderedMap<K, V>.pollLastEntry()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("java.util.Map.Entry<K, V> org.babyfish.collection.XOrderedMap<K, V>.pollLastEntry()")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("java.util.Map.Entry<K, V> org.babyfish.collection.XOrderedMap<K, V>.pollLastEntry()")
                );
            }
            return ((MAOrderedMap<K, V>)this.m).pollLastEntry();
        }

        @Override
        public Map.Entry<K, V> pollFirstEntry() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.Map.Entry<K, V> org.babyfish.collection.XOrderedMap<K, V>.pollFirstEntry()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("java.util.Map.Entry<K, V> org.babyfish.collection.XOrderedMap<K, V>.pollFirstEntry()")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("java.util.Map.Entry<K, V> org.babyfish.collection.XOrderedMap<K, V>.pollFirstEntry()")
                );
            }
            return ((MAOrderedMap<K, V>)this.m).pollFirstEntry();
        }

        @Override
        public K firstKey() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("K org.babyfish.collection.XOrderedMap<K, V>.firstKey()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("K org.babyfish.collection.XOrderedMap<K, V>.firstKey()")
                );
            }
            return ((MAOrderedMap<K, V>)this.m).firstKey();
        }

        @Override
        public MAOrderedMap.MAOrderedKeySetView<K, V> descendingKeySet() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAOrderedMap.MAOrderedKeySetView<K, V> org.babyfish.collection.MAOrderedMap<K, V>.descendingKeySet()")
                );
            }
            return MACollections.locking(((MAOrderedMap<K, V>)this.m).descendingKeySet(), this.lockingManager);
        }

        @Override
        public MAOrderedMap.MAOrderedMapView<K, V> descendingMap() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAOrderedMap.MAOrderedMapView<K, V> org.babyfish.collection.MAOrderedMap<K, V>.descendingMap()")
                );
            }
            return MACollections.locking(((MAOrderedMap<K, V>)this.m).descendingMap(), this.lockingManager);
        }

        @Override
        public MAOrderedMap.MAOrderedKeySetView<K, V> keySet() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAOrderedMap.MAOrderedKeySetView<K, V> org.babyfish.collection.MAOrderedMap<K, V>.keySet()")
                );
            }
            return MACollections.locking(((MAOrderedMap<K, V>)this.m).keySet(), this.lockingManager);
        }

        @Override
        public OrderAdjustMode replaceMode() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.OrderAdjustMode org.babyfish.collection.XOrderedMap<K, V>.replaceMode()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.collection.OrderAdjustMode org.babyfish.collection.XOrderedMap<K, V>.replaceMode()")
                );
            }
            return ((MAOrderedMap<K, V>)this.m).replaceMode();
        }

        @Override
        public MAMap.MAEntry<K, V> firstEntry() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAMap.MAEntry<K, V> org.babyfish.collection.MAOrderedMap<K, V>.firstEntry()")
                );
            }
            return MACollections.locking(((MAOrderedMap<K, V>)this.m).firstEntry(), this.lockingManager);
        }

        @Override
        public K lastKey() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("K org.babyfish.collection.XOrderedMap<K, V>.lastKey()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("K org.babyfish.collection.XOrderedMap<K, V>.lastKey()")
                );
            }
            return ((MAOrderedMap<K, V>)this.m).lastKey();
        }

        @Override
        public MAMap.MAEntry<K, V> lastEntry() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAMap.MAEntry<K, V> org.babyfish.collection.MAOrderedMap<K, V>.lastEntry()")
                );
            }
            return MACollections.locking(((MAOrderedMap<K, V>)this.m).lastEntry(), this.lockingManager);
        }

        @Override
        public V access(K key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("V org.babyfish.collection.XOrderedMap<K, V>.access(K)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("V org.babyfish.collection.XOrderedMap<K, V>.access(K)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("V org.babyfish.collection.XOrderedMap<K, V>.access(K)")
                );
            }
            return ((MAOrderedMap<K, V>)this.m).access(key);
        }

        @Override
        public OrderAdjustMode accessMode() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.OrderAdjustMode org.babyfish.collection.XOrderedMap<K, V>.accessMode()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.collection.OrderAdjustMode org.babyfish.collection.XOrderedMap<K, V>.accessMode()")
                );
            }
            return ((MAOrderedMap<K, V>)this.m).accessMode();
        }

        @Override
        public boolean headAppend() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean org.babyfish.collection.XOrderedMap<K, V>.headAppend()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("boolean org.babyfish.collection.XOrderedMap<K, V>.headAppend()")
                );
            }
            return ((MAOrderedMap<K, V>)this.m).headAppend();
        }
    }

    private static class LockingMAOrderedMapWithSerializable<K, V> extends LockingMAOrderedMap<K, V> implements Serializable {

        private static final long serialVersionUID = -1959097787L;

        LockingMAOrderedMapWithSerializable(MAOrderedMap<K, V> m, LockingManager lockingManager) {
            super(m, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMAOrderedMapWithSerializable<K, V>((MAOrderedMap<K, V>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (MAOrderedMap<K, V>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingMANavigableMapMANavigableMapView<K, V> extends LockingMANavigableMap<K, V> implements MANavigableMap.MANavigableMapView<K, V> {

        LockingMANavigableMapMANavigableMapView(MANavigableMap.MANavigableMapView<K, V> m, LockingManager lockingManager) {
            super(m, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMANavigableMapMANavigableMapView<K, V>((MANavigableMap.MANavigableMapView<K, V>)obj, this.lockingManager);
        }

        @Override
        public ViewInfo viewInfo() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            return ((MANavigableMap.MANavigableMapView<K, V>)this.m).viewInfo();
        }
    }

    private static class LockingMANavigableMap<K, V> extends LockingMASortedMap<K, V> implements MANavigableMap<K, V> {

        LockingMANavigableMap(MANavigableMap<K, V> m, LockingManager lockingManager) {
            super(m, lockingManager);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockingMANavigableMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMANavigableMap<K, V>((MANavigableMap<K, V>)obj, this.lockingManager);
        }

        @Override
        public MANavigableMap.MANavigableKeySetView<K, V> descendingKeySet() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MANavigableMap.MANavigableKeySetView<K, V> org.babyfish.collection.MANavigableMap<K, V>.descendingKeySet()")
                );
            }
            return MACollections.locking(((MANavigableMap<K, V>)this.m).descendingKeySet(), this.lockingManager);
        }

        @Override
        public MAMap.MAEntry<K, V> lowerEntry(K key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAMap.MAEntry<K, V> org.babyfish.collection.MANavigableMap<K, V>.lowerEntry(K)")
                );
            }
            return MACollections.locking(((MANavigableMap<K, V>)this.m).lowerEntry(key), this.lockingManager);
        }

        @Override
        public MANavigableMap.MANavigableKeySetView<K, V> navigableKeySet() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MANavigableMap.MANavigableKeySetView<K, V> org.babyfish.collection.MANavigableMap<K, V>.navigableKeySet()")
                );
            }
            return MACollections.locking(((MANavigableMap<K, V>)this.m).navigableKeySet(), this.lockingManager);
        }

        @Override
        public K ceilingKey(K key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("K java.util.NavigableMap<K, V>.ceilingKey(K)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("K java.util.NavigableMap<K, V>.ceilingKey(K)")
                );
            }
            return ((MANavigableMap<K, V>)this.m).ceilingKey(key);
        }

        @Override
        public MANavigableMap.MANavigableMapView<K, V> headMap(K toKey, boolean inclusive) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MANavigableMap.MANavigableMapView<K, V> org.babyfish.collection.MANavigableMap<K, V>.headMap(K, boolean)")
                );
            }
            return MACollections.locking(((MANavigableMap<K, V>)this.m).headMap(toKey, inclusive), this.lockingManager);
        }

        @Override
        public MANavigableMap.MANavigableMapView<K, V> descendingMap() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MANavigableMap.MANavigableMapView<K, V> org.babyfish.collection.MANavigableMap<K, V>.descendingMap()")
                );
            }
            return MACollections.locking(((MANavigableMap<K, V>)this.m).descendingMap(), this.lockingManager);
        }

        @Override
        public K higherKey(K key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("K java.util.NavigableMap<K, V>.higherKey(K)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("K java.util.NavigableMap<K, V>.higherKey(K)")
                );
            }
            return ((MANavigableMap<K, V>)this.m).higherKey(key);
        }

        @Override
        public MANavigableMap.MANavigableKeySetView<K, V> keySet() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MANavigableMap.MANavigableKeySetView<K, V> org.babyfish.collection.MANavigableMap<K, V>.keySet()")
                );
            }
            return MACollections.locking(((MANavigableMap<K, V>)this.m).keySet(), this.lockingManager);
        }

        @Override
        public Map.Entry<K, V> pollLastEntry() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.Map.Entry<K, V> java.util.NavigableMap<K, V>.pollLastEntry()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("java.util.Map.Entry<K, V> java.util.NavigableMap<K, V>.pollLastEntry()")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("java.util.Map.Entry<K, V> java.util.NavigableMap<K, V>.pollLastEntry()")
                );
            }
            return ((MANavigableMap<K, V>)this.m).pollLastEntry();
        }

        @Override
        public Map.Entry<K, V> pollFirstEntry() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.Map.Entry<K, V> java.util.NavigableMap<K, V>.pollFirstEntry()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("java.util.Map.Entry<K, V> java.util.NavigableMap<K, V>.pollFirstEntry()")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("java.util.Map.Entry<K, V> java.util.NavigableMap<K, V>.pollFirstEntry()")
                );
            }
            return ((MANavigableMap<K, V>)this.m).pollFirstEntry();
        }

        @Override
        public MANavigableMap.MANavigableMapView<K, V> tailMap(K fromKey, boolean inclusive) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MANavigableMap.MANavigableMapView<K, V> org.babyfish.collection.MANavigableMap<K, V>.tailMap(K, boolean)")
                );
            }
            return MACollections.locking(((MANavigableMap<K, V>)this.m).tailMap(fromKey, inclusive), this.lockingManager);
        }

        @Override
        public MAMap.MAEntry<K, V> floorEntry(K key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAMap.MAEntry<K, V> org.babyfish.collection.MANavigableMap<K, V>.floorEntry(K)")
                );
            }
            return MACollections.locking(((MANavigableMap<K, V>)this.m).floorEntry(key), this.lockingManager);
        }

        @Override
        public K lowerKey(K key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("K java.util.NavigableMap<K, V>.lowerKey(K)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("K java.util.NavigableMap<K, V>.lowerKey(K)")
                );
            }
            return ((MANavigableMap<K, V>)this.m).lowerKey(key);
        }

        @Override
        public MAMap.MAEntry<K, V> ceilingEntry(K key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAMap.MAEntry<K, V> org.babyfish.collection.MANavigableMap<K, V>.ceilingEntry(K)")
                );
            }
            return MACollections.locking(((MANavigableMap<K, V>)this.m).ceilingEntry(key), this.lockingManager);
        }

        @Override
        public MAMap.MAEntry<K, V> firstEntry() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAMap.MAEntry<K, V> org.babyfish.collection.MANavigableMap<K, V>.firstEntry()")
                );
            }
            return MACollections.locking(((MANavigableMap<K, V>)this.m).firstEntry(), this.lockingManager);
        }

        @Override
        public MANavigableMap.MANavigableMapView<K, V> subMap(K fromKey, K toKey) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MANavigableMap.MANavigableMapView<K, V> org.babyfish.collection.MANavigableMap<K, V>.subMap(K, K)")
                );
            }
            return MACollections.locking(((MANavigableMap<K, V>)this.m).subMap(fromKey, toKey), this.lockingManager);
        }

        @Override
        public MAMap.MAEntry<K, V> higherEntry(K key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAMap.MAEntry<K, V> org.babyfish.collection.MANavigableMap<K, V>.higherEntry(K)")
                );
            }
            return MACollections.locking(((MANavigableMap<K, V>)this.m).higherEntry(key), this.lockingManager);
        }

        @Override
        public MAMap.MAEntry<K, V> lastEntry() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAMap.MAEntry<K, V> org.babyfish.collection.MANavigableMap<K, V>.lastEntry()")
                );
            }
            return MACollections.locking(((MANavigableMap<K, V>)this.m).lastEntry(), this.lockingManager);
        }

        @Override
        public MANavigableMap.MANavigableMapView<K, V> headMap(K toKey) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MANavigableMap.MANavigableMapView<K, V> org.babyfish.collection.MANavigableMap<K, V>.headMap(K)")
                );
            }
            return MACollections.locking(((MANavigableMap<K, V>)this.m).headMap(toKey), this.lockingManager);
        }

        @Override
        public MANavigableMap.MANavigableMapView<K, V> subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MANavigableMap.MANavigableMapView<K, V> org.babyfish.collection.MANavigableMap<K, V>.subMap(K, boolean, K, boolean)")
                );
            }
            return MACollections.locking(((MANavigableMap<K, V>)this.m).subMap(fromKey, fromInclusive, toKey, toInclusive), this.lockingManager);
        }

        @Override
        public MANavigableMap.MANavigableMapView<K, V> tailMap(K fromKey) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MANavigableMap.MANavigableMapView<K, V> org.babyfish.collection.MANavigableMap<K, V>.tailMap(K)")
                );
            }
            return MACollections.locking(((MANavigableMap<K, V>)this.m).tailMap(fromKey), this.lockingManager);
        }

        @Override
        public K floorKey(K key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("K java.util.NavigableMap<K, V>.floorKey(K)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("K java.util.NavigableMap<K, V>.floorKey(K)")
                );
            }
            return ((MANavigableMap<K, V>)this.m).floorKey(key);
        }
    }

    private static class LockingMANavigableMapWithSerializable<K, V> extends LockingMANavigableMap<K, V> implements Serializable {

        private static final long serialVersionUID = -1501173417L;

        LockingMANavigableMapWithSerializable(MANavigableMap<K, V> m, LockingManager lockingManager) {
            super(m, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMANavigableMapWithSerializable<K, V>((MANavigableMap<K, V>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (MANavigableMap<K, V>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingMASortedMapMASortedMapView<K, V> extends LockingMASortedMap<K, V> implements MASortedMap.MASortedMapView<K, V> {

        LockingMASortedMapMASortedMapView(MASortedMap.MASortedMapView<K, V> m, LockingManager lockingManager) {
            super(m, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMASortedMapMASortedMapView<K, V>((MASortedMap.MASortedMapView<K, V>)obj, this.lockingManager);
        }

        @Override
        public ViewInfo viewInfo() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            return ((MASortedMap.MASortedMapView<K, V>)this.m).viewInfo();
        }
    }

    private static class LockingMASortedMap<K, V> extends LockingMAMap<K, V> implements MASortedMap<K, V> {

        LockingMASortedMap(MASortedMap<K, V> m, LockingManager lockingManager) {
            super(m, lockingManager);
        }

        @Deprecated //Only for deserialization
        LockingMASortedMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMASortedMap<K, V>((MASortedMap<K, V>)obj, this.lockingManager);
        }

        @Override
        public MASortedMap.MASortedMapView<K, V> subMap(K fromKey, K toKey) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MASortedMap.MASortedMapView<K, V> org.babyfish.collection.MASortedMap<K, V>.subMap(K, K)")
                );
            }
            return MACollections.locking(((MASortedMap<K, V>)this.m).subMap(fromKey, toKey), this.lockingManager);
        }

        @Override
        public K firstKey() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("K java.util.SortedMap<K, V>.firstKey()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("K java.util.SortedMap<K, V>.firstKey()")
                );
            }
            return ((MASortedMap<K, V>)this.m).firstKey();
        }

        @Override
        public MASortedMap.MASortedMapView<K, V> headMap(K toKey) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MASortedMap.MASortedMapView<K, V> org.babyfish.collection.MASortedMap<K, V>.headMap(K)")
                );
            }
            return MACollections.locking(((MASortedMap<K, V>)this.m).headMap(toKey), this.lockingManager);
        }

        @Override
        public K lastKey() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("K java.util.SortedMap<K, V>.lastKey()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("K java.util.SortedMap<K, V>.lastKey()")
                );
            }
            return ((MASortedMap<K, V>)this.m).lastKey();
        }

        @Override
        public MASortedMap.MASortedKeySetView<K, V> keySet() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MASortedMap.MASortedKeySetView<K, V> org.babyfish.collection.MASortedMap<K, V>.keySet()")
                );
            }
            return MACollections.locking(((MASortedMap<K, V>)this.m).keySet(), this.lockingManager);
        }

        @Override
        public MASortedMap.MASortedMapView<K, V> tailMap(K fromKey) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MASortedMap.MASortedMapView<K, V> org.babyfish.collection.MASortedMap<K, V>.tailMap(K)")
                );
            }
            return MACollections.locking(((MASortedMap<K, V>)this.m).tailMap(fromKey), this.lockingManager);
        }

        @Override
        public Comparator<? super K> comparator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.Comparator<? super K> java.util.SortedMap<K, V>.comparator()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("java.util.Comparator<? super K> java.util.SortedMap<K, V>.comparator()")
                );
            }
            return ((MASortedMap<K, V>)this.m).comparator();
        }
    }

    private static class LockingMASortedMapWithSerializable<K, V> extends LockingMASortedMap<K, V> implements Serializable {

        private static final long serialVersionUID = -1185837249L;

        LockingMASortedMapWithSerializable(MASortedMap<K, V> m, LockingManager lockingManager) {
            super(m, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMASortedMapWithSerializable<K, V>((MASortedMap<K, V>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (MASortedMap<K, V>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingMAMap<K, V> extends LockingXMap<K, V> implements MAMap<K, V> {

        LockingMAMap(MAMap<K, V> m, LockingManager lockingManager) {
            super(m, lockingManager);
        }

        @Deprecated //Only for deserialization
        LockingMAMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMAMap<K, V>((MAMap<K, V>)obj, this.lockingManager);
        }

        @Override
        public void addMapElementListener(MapElementListener<? super K, ? super V> listener) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.MAMap<K, V>.addMapElementListener(org.babyfish.collection.event.MapElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.MAMap<K, V>.addMapElementListener(org.babyfish.collection.event.MapElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.MAMap<K, V>.addMapElementListener(org.babyfish.collection.event.MapElementListener<? super K, ? super V>)")
                );
            }
            ((MAMap<K, V>)this.m).addMapElementListener(listener);
        }

        @Override
        public MAMap.MAEntry<K, V> entryOfKey(K key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAMap.MAEntry<K, V> org.babyfish.collection.MAMap<K, V>.real(K)")
                );
            }
            return MACollections.locking(((MAMap<K, V>)this.m).entryOfKey(key), this.lockingManager);
        }
        
        @Override
        public MAMap.MAEntry<K, V> entryOfValue(V value) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAMap.MAEntry<K, V> org.babyfish.collection.MAMap<K, V>.real(K)")
                );
            }
            return MACollections.locking(((MAMap<K, V>)this.m).entryOfValue(value), this.lockingManager);
        }

        @Override
        public void removeMapElementListener(MapElementListener<? super K, ? super V> listener) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.MAMap<K, V>.removeMapElementListener(org.babyfish.collection.event.MapElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.MAMap<K, V>.removeMapElementListener(org.babyfish.collection.event.MapElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.MAMap<K, V>.removeMapElementListener(org.babyfish.collection.event.MapElementListener<? super K, ? super V>)")
                );
            }
            ((MAMap<K, V>)this.m).removeMapElementListener(listener);
        }

        @Override
        public MAMap.MAValuesView<K, V> values() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAMap.MAValuesView<K, V> org.babyfish.collection.MAMap<K, V>.values()")
                );
            }
            return MACollections.locking(((MAMap<K, V>)this.m).values(), this.lockingManager);
        }

        @Override
        public MAMap.MAKeySetView<K, V> keySet() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAMap.MAKeySetView<K, V> org.babyfish.collection.MAMap<K, V>.keySet()")
                );
            }
            return MACollections.locking(((MAMap<K, V>)this.m).keySet(), this.lockingManager);
        }

        @Override
        public MAMap.MAEntrySetView<K, V> entrySet() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAMap.MAEntrySetView<K, V> org.babyfish.collection.MAMap<K, V>.entrySet()")
                );
            }
            return MACollections.locking(((MAMap<K, V>)this.m).entrySet(), this.lockingManager);
        }
    }

    private static class LockingMAMapWithSerializable<K, V> extends LockingMAMap<K, V> implements Serializable {

        private static final long serialVersionUID = -1417963204L;

        LockingMAMapWithSerializable(MAMap<K, V> m, LockingManager lockingManager) {
            super(m, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMAMapWithSerializable<K, V>((MAMap<K, V>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (MAMap<K, V>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingXOrderedMapXOrderedMapView<K, V> extends LockingXOrderedMap<K, V> implements XOrderedMap.XOrderedMapView<K, V> {

        LockingXOrderedMapXOrderedMapView(XOrderedMap.XOrderedMapView<K, V> m, LockingManager lockingManager) {
            super(m, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXOrderedMapXOrderedMapView<K, V>((XOrderedMap.XOrderedMapView<K, V>)obj, this.lockingManager);
        }

        @Override
        public ViewInfo viewInfo() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            return ((XOrderedMap.XOrderedMapView<K, V>)this.m).viewInfo();
        }
    }

    private static class LockingXOrderedMap<K, V> extends LockingXMap<K, V> implements XOrderedMap<K, V> {

        LockingXOrderedMap(XOrderedMap<K, V> m, LockingManager lockingManager) {
            super(m, lockingManager);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockingXOrderedMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXOrderedMap<K, V>((XOrderedMap<K, V>)obj, this.lockingManager);
        }

        @Override
        public XOrderedMap.XOrderedMapView<K, V> descendingMap() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XOrderedMap.XOrderedMapView<K, V> org.babyfish.collection.XOrderedMap<K, V>.descendingMap()")
                );
            }
            return MACollections.locking(((XOrderedMap<K, V>)this.m).descendingMap(), this.lockingManager);
        }

        @Override
        public V access(K key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("V org.babyfish.collection.XOrderedMap<K, V>.access(K)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("V org.babyfish.collection.XOrderedMap<K, V>.access(K)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("V org.babyfish.collection.XOrderedMap<K, V>.access(K)")
                );
            }
            return ((XOrderedMap<K, V>)this.m).access(key);
        }

        @Override
        public Map.Entry<K, V> pollLastEntry() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.Map.Entry<K, V> org.babyfish.collection.XOrderedMap<K, V>.pollLastEntry()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("java.util.Map.Entry<K, V> org.babyfish.collection.XOrderedMap<K, V>.pollLastEntry()")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("java.util.Map.Entry<K, V> org.babyfish.collection.XOrderedMap<K, V>.pollLastEntry()")
                );
            }
            return ((XOrderedMap<K, V>)this.m).pollLastEntry();
        }

        @Override
        public Map.Entry<K, V> pollFirstEntry() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.Map.Entry<K, V> org.babyfish.collection.XOrderedMap<K, V>.pollFirstEntry()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("java.util.Map.Entry<K, V> org.babyfish.collection.XOrderedMap<K, V>.pollFirstEntry()")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("java.util.Map.Entry<K, V> org.babyfish.collection.XOrderedMap<K, V>.pollFirstEntry()")
                );
            }
            return ((XOrderedMap<K, V>)this.m).pollFirstEntry();
        }

        @Override
        public XMap.XEntry<K, V> firstEntry() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XMap.XEntry<K, V> org.babyfish.collection.XOrderedMap<K, V>.firstEntry()")
                );
            }
            return MACollections.locking(((XOrderedMap<K, V>)this.m).firstEntry(), this.lockingManager);
        }

        @Override
        public K firstKey() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("K org.babyfish.collection.XOrderedMap<K, V>.firstKey()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("K org.babyfish.collection.XOrderedMap<K, V>.firstKey()")
                );
            }
            return ((XOrderedMap<K, V>)this.m).firstKey();
        }

        @Override
        public XOrderedMap.XOrderedKeySetView<K> keySet() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XOrderedMap.XOrderedKeySetView<K> org.babyfish.collection.XOrderedMap<K, V>.keySet()")
                );
            }
            return MACollections.locking(((XOrderedMap<K, V>)this.m).keySet(), this.lockingManager);
        }

        @Override
        public OrderAdjustMode accessMode() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.OrderAdjustMode org.babyfish.collection.XOrderedMap<K, V>.accessMode()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.collection.OrderAdjustMode org.babyfish.collection.XOrderedMap<K, V>.accessMode()")
                );
            }
            return ((XOrderedMap<K, V>)this.m).accessMode();
        }

        @Override
        public OrderAdjustMode replaceMode() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.OrderAdjustMode org.babyfish.collection.XOrderedMap<K, V>.replaceMode()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.collection.OrderAdjustMode org.babyfish.collection.XOrderedMap<K, V>.replaceMode()")
                );
            }
            return ((XOrderedMap<K, V>)this.m).replaceMode();
        }

        @Override
        public XOrderedMap.XOrderedKeySetView<K> descendingKeySet() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XOrderedMap.XOrderedKeySetView<K> org.babyfish.collection.XOrderedMap<K, V>.descendingKeySet()")
                );
            }
            return MACollections.locking(((XOrderedMap<K, V>)this.m).descendingKeySet(), this.lockingManager);
        }

        @Override
        public boolean headAppend() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean org.babyfish.collection.XOrderedMap<K, V>.headAppend()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("boolean org.babyfish.collection.XOrderedMap<K, V>.headAppend()")
                );
            }
            return ((XOrderedMap<K, V>)this.m).headAppend();
        }

        @Override
        public XMap.XEntry<K, V> lastEntry() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XMap.XEntry<K, V> org.babyfish.collection.XOrderedMap<K, V>.lastEntry()")
                );
            }
            return MACollections.locking(((XOrderedMap<K, V>)this.m).lastEntry(), this.lockingManager);
        }

        @Override
        public K lastKey() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("K org.babyfish.collection.XOrderedMap<K, V>.lastKey()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("K org.babyfish.collection.XOrderedMap<K, V>.lastKey()")
                );
            }
            return ((XOrderedMap<K, V>)this.m).lastKey();
        }
    }

    private static class LockingXOrderedMapWithSerializable<K, V> extends LockingXOrderedMap<K, V> implements Serializable {

        private static final long serialVersionUID = -2020093893L;

        LockingXOrderedMapWithSerializable(XOrderedMap<K, V> m, LockingManager lockingManager) {
            super(m, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXOrderedMapWithSerializable<K, V>((XOrderedMap<K, V>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (XOrderedMap<K, V>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingXNavigableMapXNavigableMapView<K, V> extends LockingXNavigableMap<K, V> implements XNavigableMap.XNavigableMapView<K, V> {

        LockingXNavigableMapXNavigableMapView(XNavigableMap.XNavigableMapView<K, V> m, LockingManager lockingManager) {
            super(m, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXNavigableMapXNavigableMapView<K, V>((XNavigableMap.XNavigableMapView<K, V>)obj, this.lockingManager);
        }

        @Override
        public ViewInfo viewInfo() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            return ((XNavigableMap.XNavigableMapView<K, V>)this.m).viewInfo();
        }
    }

    private static class LockingXNavigableMap<K, V> extends LockingXSortedMap<K, V> implements XNavigableMap<K, V> {

        LockingXNavigableMap(XNavigableMap<K, V> m, LockingManager lockingManager) {
            super(m, lockingManager);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockingXNavigableMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXNavigableMap<K, V>((XNavigableMap<K, V>)obj, this.lockingManager);
        }

        @Override
        public XNavigableMap.XNavigableKeySetView<K> descendingKeySet() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XNavigableMap.XNavigableKeySetView<K> org.babyfish.collection.XNavigableMap<K, V>.descendingKeySet()")
                );
            }
            return MACollections.locking(((XNavigableMap<K, V>)this.m).descendingKeySet(), this.lockingManager);
        }

        @Override
        public Map.Entry<K, V> pollLastEntry() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.Map.Entry<K, V> java.util.NavigableMap<K, V>.pollLastEntry()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("java.util.Map.Entry<K, V> java.util.NavigableMap<K, V>.pollLastEntry()")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("java.util.Map.Entry<K, V> java.util.NavigableMap<K, V>.pollLastEntry()")
                );
            }
            return ((XNavigableMap<K, V>)this.m).pollLastEntry();
        }

        @Override
        public Map.Entry<K, V> pollFirstEntry() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.Map.Entry<K, V> java.util.NavigableMap<K, V>.pollFirstEntry()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("java.util.Map.Entry<K, V> java.util.NavigableMap<K, V>.pollFirstEntry()")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("java.util.Map.Entry<K, V> java.util.NavigableMap<K, V>.pollFirstEntry()")
                );
            }
            return ((XNavigableMap<K, V>)this.m).pollFirstEntry();
        }

        @Override
        public XMap.XEntry<K, V> firstEntry() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XMap.XEntry<K, V> org.babyfish.collection.XNavigableMap<K, V>.firstEntry()")
                );
            }
            return MACollections.locking(((XNavigableMap<K, V>)this.m).firstEntry(), this.lockingManager);
        }

        @Override
        public XMap.XEntry<K, V> ceilingEntry(K key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XMap.XEntry<K, V> org.babyfish.collection.XNavigableMap<K, V>.ceilingEntry(K)")
                );
            }
            return MACollections.locking(((XNavigableMap<K, V>)this.m).ceilingEntry(key), this.lockingManager);
        }

        @Override
        public K lowerKey(K key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("K java.util.NavigableMap<K, V>.lowerKey(K)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("K java.util.NavigableMap<K, V>.lowerKey(K)")
                );
            }
            return ((XNavigableMap<K, V>)this.m).lowerKey(key);
        }

        @Override
        public XNavigableMap.XNavigableMapView<K, V> headMap(K toKey) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XNavigableMap.XNavigableMapView<K, V> org.babyfish.collection.XNavigableMap<K, V>.headMap(K)")
                );
            }
            return MACollections.locking(((XNavigableMap<K, V>)this.m).headMap(toKey), this.lockingManager);
        }

        @Override
        public XNavigableMap.XNavigableMapView<K, V> descendingMap() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XNavigableMap.XNavigableMapView<K, V> org.babyfish.collection.XNavigableMap<K, V>.descendingMap()")
                );
            }
            return MACollections.locking(((XNavigableMap<K, V>)this.m).descendingMap(), this.lockingManager);
        }

        @Override
        public XNavigableMap.XNavigableMapView<K, V> tailMap(K fromKey, boolean inclusive) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XNavigableMap.XNavigableMapView<K, V> org.babyfish.collection.XNavigableMap<K, V>.tailMap(K, boolean)")
                );
            }
            return MACollections.locking(((XNavigableMap<K, V>)this.m).tailMap(fromKey, inclusive), this.lockingManager);
        }

        @Override
        public XNavigableMap.XNavigableMapView<K, V> subMap(K fromKey, K toKey) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XNavigableMap.XNavigableMapView<K, V> org.babyfish.collection.XNavigableMap<K, V>.subMap(K, K)")
                );
            }
            return MACollections.locking(((XNavigableMap<K, V>)this.m).subMap(fromKey, toKey), this.lockingManager);
        }

        @Override
        public K ceilingKey(K key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("K java.util.NavigableMap<K, V>.ceilingKey(K)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("K java.util.NavigableMap<K, V>.ceilingKey(K)")
                );
            }
            return ((XNavigableMap<K, V>)this.m).ceilingKey(key);
        }

        @Override
        public XMap.XEntry<K, V> lowerEntry(K key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XMap.XEntry<K, V> org.babyfish.collection.XNavigableMap<K, V>.lowerEntry(K)")
                );
            }
            return MACollections.locking(((XNavigableMap<K, V>)this.m).lowerEntry(key), this.lockingManager);
        }

        @Override
        public XMap.XEntry<K, V> floorEntry(K key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XMap.XEntry<K, V> org.babyfish.collection.XNavigableMap<K, V>.floorEntry(K)")
                );
            }
            return MACollections.locking(((XNavigableMap<K, V>)this.m).floorEntry(key), this.lockingManager);
        }

        @Override
        public XNavigableMap.XNavigableKeySetView<K> navigableKeySet() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XNavigableMap.XNavigableKeySetView<K> org.babyfish.collection.XNavigableMap<K, V>.navigableKeySet()")
                );
            }
            return MACollections.locking(((XNavigableMap<K, V>)this.m).navigableKeySet(), this.lockingManager);
        }

        @Override
        public XMap.XEntry<K, V> higherEntry(K key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XMap.XEntry<K, V> org.babyfish.collection.XNavigableMap<K, V>.higherEntry(K)")
                );
            }
            return MACollections.locking(((XNavigableMap<K, V>)this.m).higherEntry(key), this.lockingManager);
        }

        @Override
        public XNavigableMap.XNavigableMapView<K, V> subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XNavigableMap.XNavigableMapView<K, V> org.babyfish.collection.XNavigableMap<K, V>.subMap(K, boolean, K, boolean)")
                );
            }
            return MACollections.locking(((XNavigableMap<K, V>)this.m).subMap(fromKey, fromInclusive, toKey, toInclusive), this.lockingManager);
        }

        @Override
        public K floorKey(K key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("K java.util.NavigableMap<K, V>.floorKey(K)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("K java.util.NavigableMap<K, V>.floorKey(K)")
                );
            }
            return ((XNavigableMap<K, V>)this.m).floorKey(key);
        }

        @Override
        public XNavigableMap.XNavigableKeySetView<K> keySet() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XNavigableMap.XNavigableKeySetView<K> org.babyfish.collection.XNavigableMap<K, V>.keySet()")
                );
            }
            return MACollections.locking(((XNavigableMap<K, V>)this.m).keySet(), this.lockingManager);
        }

        @Override
        public K higherKey(K key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("K java.util.NavigableMap<K, V>.higherKey(K)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("K java.util.NavigableMap<K, V>.higherKey(K)")
                );
            }
            return ((XNavigableMap<K, V>)this.m).higherKey(key);
        }

        @Override
        public XNavigableMap.XNavigableMapView<K, V> tailMap(K fromKey) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XNavigableMap.XNavigableMapView<K, V> org.babyfish.collection.XNavigableMap<K, V>.tailMap(K)")
                );
            }
            return MACollections.locking(((XNavigableMap<K, V>)this.m).tailMap(fromKey), this.lockingManager);
        }

        @Override
        public XNavigableMap.XNavigableMapView<K, V> headMap(K toKey, boolean inclusive) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XNavigableMap.XNavigableMapView<K, V> org.babyfish.collection.XNavigableMap<K, V>.headMap(K, boolean)")
                );
            }
            return MACollections.locking(((XNavigableMap<K, V>)this.m).headMap(toKey, inclusive), this.lockingManager);
        }

        @Override
        public XMap.XEntry<K, V> lastEntry() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XMap.XEntry<K, V> org.babyfish.collection.XNavigableMap<K, V>.lastEntry()")
                );
            }
            return MACollections.locking(((XNavigableMap<K, V>)this.m).lastEntry(), this.lockingManager);
        }
    }

    private static class LockingXNavigableMapWithSerializable<K, V> extends LockingXNavigableMap<K, V> implements Serializable {

        private static final long serialVersionUID = -4633897175499568691L;

        LockingXNavigableMapWithSerializable(XNavigableMap<K, V> m, LockingManager lockingManager) {
            super(m, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXNavigableMapWithSerializable<K, V>((XNavigableMap<K, V>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (XNavigableMap<K, V>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingXSortedMapXSortedMapView<K, V> extends LockingXSortedMap<K, V> implements XSortedMap.XSortedMapView<K, V> {

        LockingXSortedMapXSortedMapView(XSortedMap.XSortedMapView<K, V> m, LockingManager lockingManager) {
            super(m, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXSortedMapXSortedMapView<K, V>((XSortedMap.XSortedMapView<K, V>)obj, this.lockingManager);
        }

        @Override
        public ViewInfo viewInfo() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            return ((XSortedMap.XSortedMapView<K, V>)this.m).viewInfo();
        }
    }

    private static class LockingXSortedMap<K, V> extends LockingXMap<K, V> implements XSortedMap<K, V> {

        LockingXSortedMap(XSortedMap<K, V> m, LockingManager lockingManager) {
            super(m, lockingManager);
        }

        @Deprecated //Only for deserialization
        LockingXSortedMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXSortedMap<K, V>((XSortedMap<K, V>)obj, this.lockingManager);
        }

        @Override
        public K firstKey() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("K java.util.SortedMap<K, V>.firstKey()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("K java.util.SortedMap<K, V>.firstKey()")
                );
            }
            return ((XSortedMap<K, V>)this.m).firstKey();
        }

        @Override
        public XSortedMap.XSortedKeySetView<K> keySet() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XSortedMap.XSortedKeySetView<K> org.babyfish.collection.XSortedMap<K, V>.keySet()")
                );
            }
            return MACollections.locking(((XSortedMap<K, V>)this.m).keySet(), this.lockingManager);
        }

        @Override
        public XSortedMap.XSortedMapView<K, V> headMap(K toKey) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XSortedMap.XSortedMapView<K, V> org.babyfish.collection.XSortedMap<K, V>.headMap(K)")
                );
            }
            return MACollections.locking(((XSortedMap<K, V>)this.m).headMap(toKey), this.lockingManager);
        }

        @Override
        public XSortedMap.XSortedMapView<K, V> subMap(K fromKey, K toKey) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XSortedMap.XSortedMapView<K, V> org.babyfish.collection.XSortedMap<K, V>.subMap(K, K)")
                );
            }
            return MACollections.locking(((XSortedMap<K, V>)this.m).subMap(fromKey, toKey), this.lockingManager);
        }

        @Override
        public XSortedMap.XSortedMapView<K, V> tailMap(K fromKey) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XSortedMap.XSortedMapView<K, V> org.babyfish.collection.XSortedMap<K, V>.tailMap(K)")
                );
            }
            return MACollections.locking(((XSortedMap<K, V>)this.m).tailMap(fromKey), this.lockingManager);
        }

        @Override
        public Comparator<? super K> comparator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.Comparator<? super K> java.util.SortedMap<K, V>.comparator()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("java.util.Comparator<? super K> java.util.SortedMap<K, V>.comparator()")
                );
            }
            return ((XSortedMap<K, V>)this.m).comparator();
        }

        @Override
        public K lastKey() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("K java.util.SortedMap<K, V>.lastKey()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("K java.util.SortedMap<K, V>.lastKey()")
                );
            }
            return ((XSortedMap<K, V>)this.m).lastKey();
        }
    }

    private static class LockingXSortedMapWithSerializable<K, V> extends LockingXSortedMap<K, V> implements Serializable {

        private static final long serialVersionUID = -7615789493465337207L;

        LockingXSortedMapWithSerializable(XSortedMap<K, V> m, LockingManager lockingManager) {
            super(m, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXSortedMapWithSerializable<K, V>((XSortedMap<K, V>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (XSortedMap<K, V>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingXMap<K, V> extends LockingMap<K, V> implements XMap<K, V> {

        LockingXMap(XMap<K, V> m, LockingManager lockingManager) {
            super(m, lockingManager);
        }

        @Deprecated //Only for deserialization
        LockingXMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXMap<K, V>((XMap<K, V>)obj, this.lockingManager);
        }

        @Override
        public void addValueValidator(Validator<V> validator) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.XMap<K, V>.addValueValidator(org.babyfish.validator.Validator<V>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.XMap<K, V>.addValueValidator(org.babyfish.validator.Validator<V>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.XMap<K, V>.addValueValidator(org.babyfish.validator.Validator<V>)")
                );
            }
            ((XMap<K, V>)this.m).addValueValidator(validator);
        }

        @Override
        public ReplacementRule keyReplacementRule() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.ReplacementRule org.babyfish.collection.XMap<K, V>.keyReplacementRule()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.collection.ReplacementRule org.babyfish.collection.XMap<K, V>.keyReplacementRule()")
                );
            }
            return ((XMap<K, V>)this.m).keyReplacementRule();
        }

        @Override
        public UnifiedComparator<? super V> valueUnifiedComparator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.UnifiedComparator<? super V> org.babyfish.collection.XMap<K, V>.valueUnifiedComparator()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.collection.UnifiedComparator<? super V> org.babyfish.collection.XMap<K, V>.valueUnifiedComparator()")
                );
            }
            return ((XMap<K, V>)this.m).valueUnifiedComparator();
        }

        @Override
        public void removeValueValidator(Validator<V> validator) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.XMap<K, V>.removeValueValidator(org.babyfish.validator.Validator<V>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.XMap<K, V>.removeValueValidator(org.babyfish.validator.Validator<V>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.XMap<K, V>.removeValueValidator(org.babyfish.validator.Validator<V>)")
                );
            }
            ((XMap<K, V>)this.m).removeValueValidator(validator);
        }

        @Override
        public boolean isReadWriteLockSupported() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean org.babyfish.lang.LockDescriptor.isReadWriteLockSupported()")
                );
            }
            return ((XMap<K, V>)this.m).isReadWriteLockSupported();
        }

        @Override
        public void addKeyValidator(Validator<K> validator) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.XMap<K, V>.addKeyValidator(org.babyfish.validator.Validator<K>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.XMap<K, V>.addKeyValidator(org.babyfish.validator.Validator<K>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.XMap<K, V>.addKeyValidator(org.babyfish.validator.Validator<K>)")
                );
            }
            ((XMap<K, V>)this.m).addKeyValidator(validator);
        }

        @Override
        public UnifiedComparator<? super Map.Entry<K, V>> entryUnifiedComparator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.UnifiedComparator<? super java.util.Map.Entry<K, V>> org.babyfish.collection.XMap<K, V>.entryUnifiedComparator()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.collection.UnifiedComparator<? super java.util.Map.Entry<K, V>> org.babyfish.collection.XMap<K, V>.entryUnifiedComparator()")
                );
            }
            return ((XMap<K, V>)this.m).entryUnifiedComparator();
        }

        @Override
        public void removeKeyValidator(Validator<K> validator) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.XMap<K, V>.removeKeyValidator(org.babyfish.validator.Validator<K>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.XMap<K, V>.removeKeyValidator(org.babyfish.validator.Validator<K>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.XMap<K, V>.removeKeyValidator(org.babyfish.validator.Validator<K>)")
                );
            }
            ((XMap<K, V>)this.m).removeKeyValidator(validator);
        }

        @Override
        public XMap.XKeySetView<K> keySet() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XMap.XKeySetView<K> org.babyfish.collection.XMap<K, V>.keySet()")
                );
            }
            return MACollections.locking(((XMap<K, V>)this.m).keySet(), this.lockingManager);
        }

        @Override
        public BidiType bidiType() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.XMap<K, V>.bidiType()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.XMap<K, V>.bidiType()")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.XMap<K, V>.bidiType()")
                );
            }
            return ((XMap<K, V>)this.m).bidiType();
        }

        @Override
        public XEntry<K, V> entryOfValue(V value) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.lang.Ref<K> org.babyfish.collection.XMap<K, V>.keyOf(V)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.lang.Ref<K> org.babyfish.collection.XMap<K, V>.keyOf(V)")
                );
            }
            return ((XMap<K, V>)this.m).entryOfValue(value);
        }

        @Override
        public XMap.XValuesView<V> values() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XMap.XValuesView<V> org.babyfish.collection.XMap<K, V>.values()")
                );
            }
            return MACollections.locking(((XMap<K, V>)this.m).values(), this.lockingManager);
        }

        @Override
        public XMap.XEntrySetView<K, V> entrySet() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XMap.XEntrySetView<K, V> org.babyfish.collection.XMap<K, V>.entrySet()")
                );
            }
            return MACollections.locking(((XMap<K, V>)this.m).entrySet(), this.lockingManager);
        }

        @Override
        public UnifiedComparator<? super K> keyUnifiedComparator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.UnifiedComparator<? super K> org.babyfish.collection.XMap<K, V>.keyUnifiedComparator()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.collection.UnifiedComparator<? super K> org.babyfish.collection.XMap<K, V>.keyUnifiedComparator()")
                );
            }
            return ((XMap<K, V>)this.m).keyUnifiedComparator();
        }

        @Override
        public XMap.XEntry<K, V> entryOfKey(K key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XMap.XEntry<K, V> org.babyfish.collection.XMap<K, V>.real(K)")
                );
            }
            return MACollections.locking(((XMap<K, V>)this.m).entryOfKey(key), this.lockingManager);
        }

        @Override
        public void validateKey(K key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.XMap<K, V>.validateKey(K)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.XMap<K, V>.validateKey(K)")
                );
            }
            ((XMap<K, V>)this.m).validateKey(key);
        }

        @Override
        public void validateValue(V value) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.XMap<K, V>.validateValue(V)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.XMap<K, V>.validateValue(V)")
                );
            }
            ((XMap<K, V>)this.m).validateValue(value);
        }
    }

    private static class LockingXMapWithSerializable<K, V> extends LockingXMap<K, V> implements Serializable {

        private static final long serialVersionUID = -7313996103944668154L;

        LockingXMapWithSerializable(XMap<K, V> m, LockingManager lockingManager) {
            super(m, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXMapWithSerializable<K, V>((XMap<K, V>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (XMap<K, V>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingStandardNavigableMap<K, V> extends LockingStandardSortedMap<K, V> implements StandardNavigableMap<K, V> {

        LockingStandardNavigableMap(StandardNavigableMap<K, V> m, LockingManager lockingManager) {
            super(m, lockingManager);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockingStandardNavigableMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingStandardNavigableMap<K, V>((StandardNavigableMap<K, V>)obj, this.lockingManager);
        }

        @Override
        public StandardNavigableMap<K, V> tailMap(K fromKey) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MACollections.StandardNavigableMap<K, V> org.babyfish.collection.MACollections.StandardNavigableMap<K, V>.tailMap(K)")
                );
            }
            return MACollections.locking(((StandardNavigableMap<K, V>)this.m).tailMap(fromKey), this.lockingManager);
        }

        @Override
        public Map.Entry<K, V> pollLastEntry() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.Map.Entry<K, V> java.util.NavigableMap<K, V>.pollLastEntry()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("java.util.Map.Entry<K, V> java.util.NavigableMap<K, V>.pollLastEntry()")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("java.util.Map.Entry<K, V> java.util.NavigableMap<K, V>.pollLastEntry()")
                );
            }
            return ((StandardNavigableMap<K, V>)this.m).pollLastEntry();
        }

        @Override
        public Map.Entry<K, V> firstEntry() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.Map.Entry<K, V> java.util.NavigableMap<K, V>.firstEntry()")
                );
            }
            return MACollections.locking(((StandardNavigableMap<K, V>)this.m).firstEntry(), this.lockingManager);
        }

        @Override
        public Map.Entry<K, V> pollFirstEntry() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.Map.Entry<K, V> java.util.NavigableMap<K, V>.pollFirstEntry()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("java.util.Map.Entry<K, V> java.util.NavigableMap<K, V>.pollFirstEntry()")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("java.util.Map.Entry<K, V> java.util.NavigableMap<K, V>.pollFirstEntry()")
                );
            }
            return ((StandardNavigableMap<K, V>)this.m).pollFirstEntry();
        }

        @Override
        public K lowerKey(K key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("K java.util.NavigableMap<K, V>.lowerKey(K)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("K java.util.NavigableMap<K, V>.lowerKey(K)")
                );
            }
            return ((StandardNavigableMap<K, V>)this.m).lowerKey(key);
        }

        @Override
        public StandardNavigableMap<K, V> tailMap(K fromKey, boolean inclusive) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MACollections.StandardNavigableMap<K, V> org.babyfish.collection.MACollections.StandardNavigableMap<K, V>.tailMap(K, boolean)")
                );
            }
            return MACollections.locking(((StandardNavigableMap<K, V>)this.m).tailMap(fromKey, inclusive), this.lockingManager);
        }

        @Override
        public Map.Entry<K, V> lowerEntry(K key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.Map.Entry<K, V> java.util.NavigableMap<K, V>.lowerEntry(K)")
                );
            }
            return MACollections.locking(((StandardNavigableMap<K, V>)this.m).lowerEntry(key), this.lockingManager);
        }

        @Override
        public K ceilingKey(K key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("K java.util.NavigableMap<K, V>.ceilingKey(K)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("K java.util.NavigableMap<K, V>.ceilingKey(K)")
                );
            }
            return ((StandardNavigableMap<K, V>)this.m).ceilingKey(key);
        }

        @Override
        public StandardNavigableMap<K, V> descendingMap() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MACollections.StandardNavigableMap<K, V> org.babyfish.collection.MACollections.StandardNavigableMap<K, V>.descendingMap()")
                );
            }
            return MACollections.locking(((StandardNavigableMap<K, V>)this.m).descendingMap(), this.lockingManager);
        }

        @Override
        public StandardNavigableMap<K, V> headMap(K toKey, boolean inclusive) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MACollections.StandardNavigableMap<K, V> org.babyfish.collection.MACollections.StandardNavigableMap<K, V>.headMap(K, boolean)")
                );
            }
            return MACollections.locking(((StandardNavigableMap<K, V>)this.m).headMap(toKey, inclusive), this.lockingManager);
        }

        @Override
        public StandardNavigableMap<K, V> subMap(K fromKey, K toKey) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MACollections.StandardNavigableMap<K, V> org.babyfish.collection.MACollections.StandardNavigableMap<K, V>.subMap(K, K)")
                );
            }
            return MACollections.locking(((StandardNavigableMap<K, V>)this.m).subMap(fromKey, toKey), this.lockingManager);
        }

        @Override
        public Map.Entry<K, V> ceilingEntry(K key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.Map.Entry<K, V> java.util.NavigableMap<K, V>.ceilingEntry(K)")
                );
            }
            return MACollections.locking(((StandardNavigableMap<K, V>)this.m).ceilingEntry(key), this.lockingManager);
        }

        @Override
        public Map.Entry<K, V> lastEntry() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.Map.Entry<K, V> java.util.NavigableMap<K, V>.lastEntry()")
                );
            }
            return MACollections.locking(((StandardNavigableMap<K, V>)this.m).lastEntry(), this.lockingManager);
        }

        @Override
        public Map.Entry<K, V> floorEntry(K key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.Map.Entry<K, V> java.util.NavigableMap<K, V>.floorEntry(K)")
                );
            }
            return MACollections.locking(((StandardNavigableMap<K, V>)this.m).floorEntry(key), this.lockingManager);
        }

        @Override
        public NavigableSet<K> descendingKeySet() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.NavigableSet<K> java.util.NavigableMap<K, V>.descendingKeySet()")
                );
            }
            return MACollections.locking(((StandardNavigableMap<K, V>)this.m).descendingKeySet(), this.lockingManager);
        }

        @Override
        public StandardNavigableMap<K, V> subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MACollections.StandardNavigableMap<K, V> org.babyfish.collection.MACollections.StandardNavigableMap<K, V>.subMap(K, boolean, K, boolean)")
                );
            }
            return MACollections.locking(((StandardNavigableMap<K, V>)this.m).subMap(fromKey, fromInclusive, toKey, toInclusive), this.lockingManager);
        }

        @Override
        public StandardNavigableMap<K, V> headMap(K toKey) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MACollections.StandardNavigableMap<K, V> org.babyfish.collection.MACollections.StandardNavigableMap<K, V>.headMap(K)")
                );
            }
            return MACollections.locking(((StandardNavigableMap<K, V>)this.m).headMap(toKey), this.lockingManager);
        }

        @Override
        public Map.Entry<K, V> higherEntry(K key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.Map.Entry<K, V> java.util.NavigableMap<K, V>.higherEntry(K)")
                );
            }
            return MACollections.locking(((StandardNavigableMap<K, V>)this.m).higherEntry(key), this.lockingManager);
        }

        @Override
        public K floorKey(K key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("K java.util.NavigableMap<K, V>.floorKey(K)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("K java.util.NavigableMap<K, V>.floorKey(K)")
                );
            }
            return ((StandardNavigableMap<K, V>)this.m).floorKey(key);
        }

        @Override
        public NavigableSet<K> navigableKeySet() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.NavigableSet<K> java.util.NavigableMap<K, V>.navigableKeySet()")
                );
            }
            return MACollections.locking(((StandardNavigableMap<K, V>)this.m).navigableKeySet(), this.lockingManager);
        }

        @Override
        public K higherKey(K key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("K java.util.NavigableMap<K, V>.higherKey(K)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("K java.util.NavigableMap<K, V>.higherKey(K)")
                );
            }
            return ((StandardNavigableMap<K, V>)this.m).higherKey(key);
        }
    }

    private static class LockingStandardNavigableMapWithSerializable<K, V> extends LockingStandardNavigableMap<K, V> implements Serializable {

        private static final long serialVersionUID = -7791644735457067744L;

        LockingStandardNavigableMapWithSerializable(StandardNavigableMap<K, V> m, LockingManager lockingManager) {
            super(m, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingStandardNavigableMapWithSerializable<K, V>((StandardNavigableMap<K, V>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (StandardNavigableMap<K, V>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingStandardSortedMap<K, V> extends LockingStandardMap<K, V> implements StandardSortedMap<K, V> {

        LockingStandardSortedMap(StandardSortedMap<K, V> m, LockingManager lockingManager) {
            super(m, lockingManager);
        }

        @Deprecated //Only for deserialization
        LockingStandardSortedMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingStandardSortedMap<K, V>((StandardSortedMap<K, V>)obj, this.lockingManager);
        }

        @Override
        public StandardSortedMap<K, V> headMap(K toKey) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MACollections.StandardSortedMap<K, V> org.babyfish.collection.MACollections.StandardSortedMap<K, V>.headMap(K)")
                );
            }
            return MACollections.locking(((StandardSortedMap<K, V>)this.m).headMap(toKey), this.lockingManager);
        }

        @Override
        public K firstKey() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("K java.util.SortedMap<K, V>.firstKey()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("K java.util.SortedMap<K, V>.firstKey()")
                );
            }
            return ((StandardSortedMap<K, V>)this.m).firstKey();
        }

        @Override
        public StandardSortedMap<K, V> subMap(K fromKey, K toKey) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MACollections.StandardSortedMap<K, V> org.babyfish.collection.MACollections.StandardSortedMap<K, V>.subMap(K, K)")
                );
            }
            return MACollections.locking(((StandardSortedMap<K, V>)this.m).subMap(fromKey, toKey), this.lockingManager);
        }

        @Override
        public StandardSortedMap<K, V> tailMap(K fromKey) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MACollections.StandardSortedMap<K, V> org.babyfish.collection.MACollections.StandardSortedMap<K, V>.tailMap(K)")
                );
            }
            return MACollections.locking(((StandardSortedMap<K, V>)this.m).tailMap(fromKey), this.lockingManager);
        }

        @Override
        public Comparator<? super K> comparator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.Comparator<? super K> java.util.SortedMap<K, V>.comparator()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("java.util.Comparator<? super K> java.util.SortedMap<K, V>.comparator()")
                );
            }
            return ((StandardSortedMap<K, V>)this.m).comparator();
        }

        @Override
        public K lastKey() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("K java.util.SortedMap<K, V>.lastKey()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("K java.util.SortedMap<K, V>.lastKey()")
                );
            }
            return ((StandardSortedMap<K, V>)this.m).lastKey();
        }
    }

    private static class LockingStandardSortedMapWithSerializable<K, V> extends LockingStandardSortedMap<K, V> implements Serializable {

        private static final long serialVersionUID = -1005701098L;

        LockingStandardSortedMapWithSerializable(StandardSortedMap<K, V> m, LockingManager lockingManager) {
            super(m, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingStandardSortedMapWithSerializable<K, V>((StandardSortedMap<K, V>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (StandardSortedMap<K, V>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingStandardMap<K, V> extends LockingMap<K, V> implements StandardMap<K, V> {

        LockingStandardMap(StandardMap<K, V> m, LockingManager lockingManager) {
            super(m, lockingManager);
        }

        @Deprecated //Only for deserialization
        LockingStandardMap() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingStandardMap<K, V>((StandardMap<K, V>)obj, this.lockingManager);
        }

        @Override
        public boolean isReadWriteLockSupported() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean org.babyfish.lang.LockDescriptor.isReadWriteLockSupported()")
                );
            }
            return ((StandardMap<K, V>)this.m).isReadWriteLockSupported();
        }

        @Override
        public StandardMap.EntrySet<K, V> entrySet() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MACollections$StandardMap.EntrySet<K, V> org.babyfish.collection.MACollections.StandardMap<K, V>.entrySet()")
                );
            }
            return MACollections.locking(((StandardMap<K, V>)this.m).entrySet(), this.lockingManager);
        }
    }

    private static class LockingStandardMapWithSerializable<K, V> extends LockingStandardMap<K, V> implements Serializable {

        private static final long serialVersionUID = -2017366189L;

        LockingStandardMapWithSerializable(StandardMap<K, V> m, LockingManager lockingManager) {
            super(m, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingStandardMapWithSerializable<K, V>((StandardMap<K, V>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.m);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.m = (StandardMap<K, V>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static abstract class LockingMap<K, V> extends LockingProxy implements Map<K, V> {

        Map<K, V> m;

        LockingMap(Map<K, V> m, LockingManager lockingManager) {
            super(lockingManager);
            this.m = m;
        }

        @Deprecated //Only for deserialization
        LockingMap() {
        }

        @Override
        Object getInnerObject() {
            return this.m;
        }

        @Override
        public String toString() {
            return this.m.toString();
        }

        @Override
        public boolean isEmpty() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean java.util.Map<K, V>.isEmpty()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("boolean java.util.Map<K, V>.isEmpty()")
                );
            }
            return this.m.isEmpty();
        }

        @Override
        public V get(Object key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("V java.util.Map<K, V>.get(java.lang.Object)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("V java.util.Map<K, V>.get(java.lang.Object)")
                );
            }
            return this.m.get(key);
        }

        /*
         * Don't implement 
         * java.util.Set entrySet()
         * here because the current class 
         * is neither "StandardMap" nor "XMap"
         */

        @Override
        public Set<K> keySet() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.Set<K> java.util.Map<K, V>.keySet()")
                );
            }
            return MACollections.locking(this.m.keySet(), this.lockingManager);
        }

        @Override
        public boolean containsKey(Object o) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean java.util.Map<K, V>.containsKey(java.lang.Object)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("boolean java.util.Map<K, V>.containsKey(java.lang.Object)")
                );
            }
            return this.m.containsKey(o);
        }

        @Override
        public void clear() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void java.util.Map<K, V>.clear()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void java.util.Map<K, V>.clear()")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void java.util.Map<K, V>.clear()")
                );
            }
            this.m.clear();
        }

        @Override
        public V put(K key, V value) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("V java.util.Map<K, V>.put(K, V)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("V java.util.Map<K, V>.put(K, V)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("V java.util.Map<K, V>.put(K, V)")
                );
            }
            return this.m.put(key, value);
        }

        @Override
        public void putAll(Map<? extends K, ? extends V> m) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void java.util.Map<K, V>.putAll(java.util.Map<? extends K, ? extends V>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void java.util.Map<K, V>.putAll(java.util.Map<? extends K, ? extends V>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void java.util.Map<K, V>.putAll(java.util.Map<? extends K, ? extends V>)")
                );
            }
            this.m.putAll(m);
        }

        @Override
        public int hashCode() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("int java.util.Map<K, V>.hashCode()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("int java.util.Map<K, V>.hashCode()")
                );
            }
            return this.m.hashCode();
        }

        @Override
        public Collection<V> values() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.Collection<V> java.util.Map<K, V>.values()")
                );
            }
            return MACollections.locking(this.m.values(), this.lockingManager);
        }

        @Override
        public V remove(Object key) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("V java.util.Map<K, V>.remove(java.lang.Object)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("V java.util.Map<K, V>.remove(java.lang.Object)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("V java.util.Map<K, V>.remove(java.lang.Object)")
                );
            }
            return this.m.remove(key);
        }

        @Override
        public boolean equals(Object obj) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean java.util.Map<K, V>.equals(java.lang.Object)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("boolean java.util.Map<K, V>.equals(java.lang.Object)")
                );
            }
            return this.m.equals(obj);
        }

        @Override
        public boolean containsValue(Object o) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean java.util.Map<K, V>.containsValue(java.lang.Object)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("boolean java.util.Map<K, V>.containsValue(java.lang.Object)")
                );
            }
            return this.m.containsValue(o);
        }

        @Override
        public int size() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("int java.util.Map<K, V>.size()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("int java.util.Map<K, V>.size()")
                );
            }
            return this.m.size();
        }
    }

    /*
     * No derived class "LockingMapWithSerializable<K, V>"
     * for class "LockingMap<K, V>" because it is abstract.
     */

    private static class LockingMAListMAListView<E> extends LockingMAList<E> implements MAList.MAListView<E> {

        LockingMAListMAListView(MAList.MAListView<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMAListMAListView<E>((MAList.MAListView<E>)obj, this.lockingManager);
        }

        @Override
        public ViewInfo viewInfo() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            return ((MAList.MAListView<E>)this.c).viewInfo();
        }
    }
    private static class LockingMAListMAListViewWithRandomAccess<E> extends LockingMAListMAListView<E> implements RandomAccess {

        LockingMAListMAListViewWithRandomAccess(MAList.MAListView<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMAListMAListViewWithRandomAccess<E>((MAList.MAListView<E>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (MAList.MAListView<E>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }


    private static class LockingMAList<E> extends LockingMACollection<E> implements MAList<E> {

        LockingMAList(MAList<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockingMAList() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMAList<E>((MAList<E>)obj, this.lockingManager);
        }

        @Override
        public void removeListElementListener(ListElementListener<? super E> listener) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.MAList<E>.removeListElementListener(org.babyfish.collection.event.ListElementListener<? super E>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.MAList<E>.removeListElementListener(org.babyfish.collection.event.ListElementListener<? super E>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.MAList<E>.removeListElementListener(org.babyfish.collection.event.ListElementListener<? super E>)")
                );
            }
            ((MAList<E>)this.c).removeListElementListener(listener);
        }

        @Override
        public MAList.MAListIterator<E> iterator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAList.MAListIterator<E> org.babyfish.collection.MAList<E>.iterator()")
                );
            }
            return MACollections.locking(((MAList<E>)this.c).iterator(), this.lockingManager);
        }

        @Override
        public MAList.MAListIterator<E> listIterator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAList.MAListIterator<E> org.babyfish.collection.MAList<E>.listIterator()")
                );
            }
            return MACollections.locking(((MAList<E>)this.c).listIterator(), this.lockingManager);
        }

        @Override
        public void addListElementListener(ListElementListener<? super E> listener) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.MAList<E>.addListElementListener(org.babyfish.collection.event.ListElementListener<? super E>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.MAList<E>.addListElementListener(org.babyfish.collection.event.ListElementListener<? super E>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.MAList<E>.addListElementListener(org.babyfish.collection.event.ListElementListener<? super E>)")
                );
            }
            ((MAList<E>)this.c).addListElementListener(listener);
        }

        @Override
        public MAList.MAListView<E> subList(int from, int to) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAList.MAListView<E> org.babyfish.collection.MAList<E>.subList(int, int)")
                );
            }
            return MACollections.locking(((MAList<E>)this.c).subList(from, to), this.lockingManager);
        }

        @Override
        public E get(int index) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.List<E>.get(int)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.List<E>.get(int)")
                );
            }
            return ((MAList<E>)this.c).get(index);
        }

        @Override
        public MAList.MAListIterator<E> listIterator(int index) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAList.MAListIterator<E> org.babyfish.collection.MAList<E>.listIterator(int)")
                );
            }
            return MACollections.locking(((MAList<E>)this.c).listIterator(index), this.lockingManager);
        }

        @Override
        public boolean addAll(int index, Collection<? extends E> c) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean java.util.List<E>.addAll(int, java.util.Collection<? extends E>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("boolean java.util.List<E>.addAll(int, java.util.Collection<? extends E>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("boolean java.util.List<E>.addAll(int, java.util.Collection<? extends E>)")
                );
            }
            return ((MAList<E>)this.c).addAll(index, c);
        }

        @Override
        public BidiType bidiType() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("BidiType org.babyfish.collection.XList<E>.bidiType()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("BidiType org.babyfish.collection.XList<E>.bidiType()")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("BidiType org.babyfish.collection.XList<E>.bidiType()")
                );
            }
            return ((MAList<E>)this.c).bidiType();
        }

        @Override
        public int indexOf(Object o) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("int java.util.List<E>.indexOf(java.lang.Object)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("int java.util.List<E>.indexOf(java.lang.Object)")
                );
            }
            return ((MAList<E>)this.c).indexOf(o);
        }

        @Override
        public int lastIndexOf(Object o) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("int java.util.List<E>.lastIndexOf(java.lang.Object)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("int java.util.List<E>.lastIndexOf(java.lang.Object)")
                );
            }
            return ((MAList<E>)this.c).lastIndexOf(o);
        }

        @Override
        public E set(int index, E e) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.List<E>.set(int, E)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.List<E>.set(int, E)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("E java.util.List<E>.set(int, E)")
                );
            }
            return ((MAList<E>)this.c).set(index, e);
        }

        @Override
        public E remove(int index) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.List<E>.remove(int)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.List<E>.remove(int)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("E java.util.List<E>.remove(int)")
                );
            }
            return ((MAList<E>)this.c).remove(index);
        }

        @Override
        public void add(int index, E e) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void java.util.List<E>.add(int, E)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void java.util.List<E>.add(int, E)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void java.util.List<E>.add(int, E)")
                );
            }
            ((MAList<E>)this.c).add(index, e);
        }
    }

    private static class LockingMAListWithSerializable<E> extends LockingMAList<E> implements Serializable {

        private static final long serialVersionUID = -914738324L;

        LockingMAListWithSerializable(MAList<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMAListWithSerializable<E>((MAList<E>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (MAList<E>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingMAListWithRandomAccess<E> extends LockingMAList<E> implements RandomAccess {

        LockingMAListWithRandomAccess(MAList<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMAListWithRandomAccess<E>((MAList<E>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (MAList<E>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }


    private static class LockingMAListWithSerializableRandomAccess<E> extends LockingMAList<E> implements Serializable, RandomAccess {

        private static final long serialVersionUID = -914738324L;

        LockingMAListWithSerializableRandomAccess(MAList<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMAListWithSerializableRandomAccess<E>((MAList<E>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (MAList<E>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingMAOrderedMapMAOrderedKeySetView<K, V> extends LockingMAOrderedSetMAOrderedSetView<K> implements MAOrderedMap.MAOrderedKeySetView<K, V> {

        LockingMAOrderedMapMAOrderedKeySetView(MAOrderedMap.MAOrderedKeySetView<K, V> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMAOrderedMapMAOrderedKeySetView<K, V>((MAOrderedMap.MAOrderedKeySetView<K, V>)obj, this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public MAMap.MAKeySetView.MAKeySetIterator<K, V> descendingIterator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAMap$MAKeySetView.MAKeySetIterator<K, V> org.babyfish.collection.MAOrderedMap.MAOrderedKeySetView<K, V>.descendingIterator()")
                );
            }
            return MACollections.locking(((MAOrderedMap.MAOrderedKeySetView<K, V>)this.c).descendingIterator(), this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public void removeKeySetElementListener(KeySetElementListener<? super K, ? super V> listener) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.removeKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.removeKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.removeKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
                );
            }
            ((MAOrderedMap.MAOrderedKeySetView<K, V>)this.c).removeKeySetElementListener(listener);
        }

        @SuppressWarnings("unchecked")
        @Override
        public MAOrderedMap.MAOrderedKeySetView<K, V> descendingSet() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAOrderedMap.MAOrderedKeySetView<K, V> org.babyfish.collection.MAOrderedMap.MAOrderedKeySetView<K, V>.descendingSet()")
                );
            }
            return MACollections.locking(((MAOrderedMap.MAOrderedKeySetView<K, V>)this.c).descendingSet(), this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public MAMap.MAKeySetView.MAKeySetIterator<K, V> iterator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAMap$MAKeySetView.MAKeySetIterator<K, V> org.babyfish.collection.MAMap.MAKeySetView<K, V>.iterator()")
                );
            }
            return MACollections.locking(((MAOrderedMap.MAOrderedKeySetView<K, V>)this.c).iterator(), this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public void addKeySetElementListener(KeySetElementListener<? super K, ? super V> listener) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.addKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.addKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.addKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
                );
            }
            ((MAOrderedMap.MAOrderedKeySetView<K, V>)this.c).addKeySetElementListener(listener);
        }
    }

    private static class LockingMAOrderedSetMAOrderedSetView<E> extends LockingMAOrderedSet<E> implements MAOrderedSet.MAOrderedSetView<E> {

        LockingMAOrderedSetMAOrderedSetView(MAOrderedSet.MAOrderedSetView<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMAOrderedSetMAOrderedSetView<E>((MAOrderedSet.MAOrderedSetView<E>)obj, this.lockingManager);
        }

        @Override
        public ViewInfo viewInfo() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            return ((MAOrderedSet.MAOrderedSetView<E>)this.c).viewInfo();
        }
    }

    private static class LockingMAOrderedSet<E> extends LockingMASet<E> implements MAOrderedSet<E> {

        LockingMAOrderedSet(MAOrderedSet<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockingMAOrderedSet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMAOrderedSet<E>((MAOrderedSet<E>)obj, this.lockingManager);
        }

        @Override
        public OrderAdjustMode replaceMode() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.OrderAdjustMode org.babyfish.collection.XOrderedSet<E>.replaceMode()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.collection.OrderAdjustMode org.babyfish.collection.XOrderedSet<E>.replaceMode()")
                );
            }
            return ((MAOrderedSet<E>)this.c).replaceMode();
        }

        @Override
        public boolean headAppend() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean org.babyfish.collection.XOrderedSet<E>.headAppend()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("boolean org.babyfish.collection.XOrderedSet<E>.headAppend()")
                );
            }
            return ((MAOrderedSet<E>)this.c).headAppend();
        }

        @Override
        public E last() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E org.babyfish.collection.XOrderedSet<E>.last()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E org.babyfish.collection.XOrderedSet<E>.last()")
                );
            }
            return ((MAOrderedSet<E>)this.c).last();
        }

        @Override
        public MAOrderedSet.MAOrderedSetView<E> descendingSet() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAOrderedSet.MAOrderedSetView<E> org.babyfish.collection.MAOrderedSet<E>.descendingSet()")
                );
            }
            return MACollections.locking(((MAOrderedSet<E>)this.c).descendingSet(), this.lockingManager);
        }

        @Override
        public MACollection.MAIterator<E> descendingIterator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MACollection.MAIterator<E> org.babyfish.collection.MAOrderedSet<E>.descendingIterator()")
                );
            }
            return MACollections.locking(((MAOrderedSet<E>)this.c).descendingIterator(), this.lockingManager);
        }

        @Override
        public E first() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E org.babyfish.collection.XOrderedSet<E>.first()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E org.babyfish.collection.XOrderedSet<E>.first()")
                );
            }
            return ((MAOrderedSet<E>)this.c).first();
        }

        @Override
        public E pollLast() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E org.babyfish.collection.XOrderedSet<E>.pollLast()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E org.babyfish.collection.XOrderedSet<E>.pollLast()")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("E org.babyfish.collection.XOrderedSet<E>.pollLast()")
                );
            }
            return ((MAOrderedSet<E>)this.c).pollLast();
        }

        @Override
        public E pollFirst() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E org.babyfish.collection.XOrderedSet<E>.pollFirst()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E org.babyfish.collection.XOrderedSet<E>.pollFirst()")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("E org.babyfish.collection.XOrderedSet<E>.pollFirst()")
                );
            }
            return ((MAOrderedSet<E>)this.c).pollFirst();
        }
    }

    private static class LockingMAOrderedSetWithSerializable<E> extends LockingMAOrderedSet<E> implements Serializable {

        private static final long serialVersionUID = -9047185124648176587L;

        LockingMAOrderedSetWithSerializable(MAOrderedSet<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMAOrderedSetWithSerializable<E>((MAOrderedSet<E>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (MAOrderedSet<E>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingMANavigableMapMANavigableKeySetView<K, V> extends LockingMANavigableSetMANavigableSetView<K> implements MANavigableMap.MANavigableKeySetView<K, V> {

        LockingMANavigableMapMANavigableKeySetView(MANavigableMap.MANavigableKeySetView<K, V> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMANavigableMapMANavigableKeySetView<K, V>((MANavigableMap.MANavigableKeySetView<K, V>)obj, this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public MANavigableMap.MANavigableKeySetView<K, V> subSet(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MANavigableMap.MANavigableKeySetView<K, V> org.babyfish.collection.MANavigableMap.MANavigableKeySetView<K, V>.subSet(K, boolean, K, boolean)")
                );
            }
            return MACollections.locking(((MANavigableMap.MANavigableKeySetView<K, V>)this.c).subSet(fromKey, fromInclusive, toKey, toInclusive), this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public MANavigableMap.MANavigableKeySetView<K, V> tailSet(K fromKey, boolean inclusive) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MANavigableMap.MANavigableKeySetView<K, V> org.babyfish.collection.MANavigableMap.MANavigableKeySetView<K, V>.tailSet(K, boolean)")
                );
            }
            return MACollections.locking(((MANavigableMap.MANavigableKeySetView<K, V>)this.c).tailSet(fromKey, inclusive), this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public MANavigableMap.MANavigableKeySetView<K, V> headSet(K toKey, boolean inclusive) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MANavigableMap.MANavigableKeySetView<K, V> org.babyfish.collection.MANavigableMap.MANavigableKeySetView<K, V>.headSet(K, boolean)")
                );
            }
            return MACollections.locking(((MANavigableMap.MANavigableKeySetView<K, V>)this.c).headSet(toKey, inclusive), this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public MAMap.MAKeySetView.MAKeySetIterator<K, V> descendingIterator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAMap$MAKeySetView.MAKeySetIterator<K, V> org.babyfish.collection.MANavigableMap.MANavigableKeySetView<K, V>.descendingIterator()")
                );
            }
            return MACollections.locking(((MANavigableMap.MANavigableKeySetView<K, V>)this.c).descendingIterator(), this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public void removeKeySetElementListener(KeySetElementListener<? super K, ? super V> listener) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.removeKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.removeKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.removeKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
                );
            }
            ((MANavigableMap.MANavigableKeySetView<K, V>)this.c).removeKeySetElementListener(listener);
        }

        @SuppressWarnings("unchecked")
        @Override
        public MAMap.MAKeySetView.MAKeySetIterator<K, V> iterator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAMap$MAKeySetView.MAKeySetIterator<K, V> org.babyfish.collection.MAMap.MAKeySetView<K, V>.iterator()")
                );
            }
            return MACollections.locking(((MANavigableMap.MANavigableKeySetView<K, V>)this.c).iterator(), this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public MANavigableMap.MANavigableKeySetView<K, V> headSet(K toKey) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MANavigableMap.MANavigableKeySetView<K, V> org.babyfish.collection.MANavigableMap.MANavigableKeySetView<K, V>.headSet(K)")
                );
            }
            return MACollections.locking(((MANavigableMap.MANavigableKeySetView<K, V>)this.c).headSet(toKey), this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public MANavigableMap.MANavigableKeySetView<K, V> tailSet(K fromKey) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MANavigableMap.MANavigableKeySetView<K, V> org.babyfish.collection.MANavigableMap.MANavigableKeySetView<K, V>.tailSet(K)")
                );
            }
            return MACollections.locking(((MANavigableMap.MANavigableKeySetView<K, V>)this.c).tailSet(fromKey), this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public MANavigableMap.MANavigableKeySetView<K, V> descendingSet() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MANavigableMap.MANavigableKeySetView<K, V> org.babyfish.collection.MANavigableMap.MANavigableKeySetView<K, V>.descendingSet()")
                );
            }
            return MACollections.locking(((MANavigableMap.MANavigableKeySetView<K, V>)this.c).descendingSet(), this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public MANavigableMap.MANavigableKeySetView<K, V> subSet(K fromKey, K toKey) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MANavigableMap.MANavigableKeySetView<K, V> org.babyfish.collection.MANavigableMap.MANavigableKeySetView<K, V>.subSet(K, K)")
                );
            }
            return MACollections.locking(((MANavigableMap.MANavigableKeySetView<K, V>)this.c).subSet(fromKey, toKey), this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public void addKeySetElementListener(KeySetElementListener<? super K, ? super V> listener) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.addKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.addKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.addKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
                );
            }
            ((MANavigableMap.MANavigableKeySetView<K, V>)this.c).addKeySetElementListener(listener);
        }
    }

    private static class LockingMANavigableSetMANavigableSetView<E> extends LockingMANavigableSet<E> implements MANavigableSet.MANavigableSetView<E> {

        LockingMANavigableSetMANavigableSetView(MANavigableSet.MANavigableSetView<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMANavigableSetMANavigableSetView<E>((MANavigableSet.MANavigableSetView<E>)obj, this.lockingManager);
        }

        @Override
        public ViewInfo viewInfo() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            return ((MANavigableSet.MANavigableSetView<E>)this.c).viewInfo();
        }
    }

    private static class LockingMANavigableSet<E> extends LockingMASortedSet<E> implements MANavigableSet<E> {

        LockingMANavigableSet(MANavigableSet<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockingMANavigableSet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMANavigableSet<E>((MANavigableSet<E>)obj, this.lockingManager);
        }

        @Override
        public E higher(E e) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.NavigableSet<E>.higher(E)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.NavigableSet<E>.higher(E)")
                );
            }
            return ((MANavigableSet<E>)this.c).higher(e);
        }

        @Override
        public MACollection.MAIterator<E> descendingIterator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MACollection.MAIterator<E> org.babyfish.collection.MANavigableSet<E>.descendingIterator()")
                );
            }
            return MACollections.locking(((MANavigableSet<E>)this.c).descendingIterator(), this.lockingManager);
        }

        @Override
        public MANavigableSet.MANavigableSetView<E> tailSet(E fromElement) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MANavigableSet.MANavigableSetView<E> org.babyfish.collection.MANavigableSet<E>.tailSet(E)")
                );
            }
            return MACollections.locking(((MANavigableSet<E>)this.c).tailSet(fromElement), this.lockingManager);
        }

        @Override
        public E lower(E e) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.NavigableSet<E>.lower(E)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.NavigableSet<E>.lower(E)")
                );
            }
            return ((MANavigableSet<E>)this.c).lower(e);
        }

        @Override
        public MANavigableSet.MANavigableSetView<E> tailSet(E fromElement, boolean inclusive) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MANavigableSet.MANavigableSetView<E> org.babyfish.collection.MANavigableSet<E>.tailSet(E, boolean)")
                );
            }
            return MACollections.locking(((MANavigableSet<E>)this.c).tailSet(fromElement, inclusive), this.lockingManager);
        }

        @Override
        public MANavigableSet.MANavigableSetView<E> subSet(E fromElement, E toElement) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MANavigableSet.MANavigableSetView<E> org.babyfish.collection.MANavigableSet<E>.subSet(E, E)")
                );
            }
            return MACollections.locking(((MANavigableSet<E>)this.c).subSet(fromElement, toElement), this.lockingManager);
        }

        @Override
        public MANavigableSet.MANavigableSetView<E> headSet(E toElement, boolean inclusive) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MANavigableSet.MANavigableSetView<E> org.babyfish.collection.MANavigableSet<E>.headSet(E, boolean)")
                );
            }
            return MACollections.locking(((MANavigableSet<E>)this.c).headSet(toElement, inclusive), this.lockingManager);
        }

        @Override
        public E floor(E e) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.NavigableSet<E>.floor(E)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.NavigableSet<E>.floor(E)")
                );
            }
            return ((MANavigableSet<E>)this.c).floor(e);
        }

        @Override
        public E ceiling(E e) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.NavigableSet<E>.ceiling(E)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.NavigableSet<E>.ceiling(E)")
                );
            }
            return ((MANavigableSet<E>)this.c).ceiling(e);
        }

        @Override
        public MANavigableSet.MANavigableSetView<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MANavigableSet.MANavigableSetView<E> org.babyfish.collection.MANavigableSet<E>.subSet(E, boolean, E, boolean)")
                );
            }
            return MACollections.locking(((MANavigableSet<E>)this.c).subSet(fromElement, fromInclusive, toElement, toInclusive), this.lockingManager);
        }

        @Override
        public MANavigableSet.MANavigableSetView<E> descendingSet() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MANavigableSet.MANavigableSetView<E> org.babyfish.collection.MANavigableSet<E>.descendingSet()")
                );
            }
            return MACollections.locking(((MANavigableSet<E>)this.c).descendingSet(), this.lockingManager);
        }

        @Override
        public MANavigableSet.MANavigableSetView<E> headSet(E toElement) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MANavigableSet.MANavigableSetView<E> org.babyfish.collection.MANavigableSet<E>.headSet(E)")
                );
            }
            return MACollections.locking(((MANavigableSet<E>)this.c).headSet(toElement), this.lockingManager);
        }

        @Override
        public E pollLast() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.NavigableSet<E>.pollLast()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.NavigableSet<E>.pollLast()")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("E java.util.NavigableSet<E>.pollLast()")
                );
            }
            return ((MANavigableSet<E>)this.c).pollLast();
        }

        @Override
        public E pollFirst() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.NavigableSet<E>.pollFirst()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.NavigableSet<E>.pollFirst()")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("E java.util.NavigableSet<E>.pollFirst()")
                );
            }
            return ((MANavigableSet<E>)this.c).pollFirst();
        }
    }

    private static class LockingMANavigableSetWithSerializable<E> extends LockingMANavigableSet<E> implements Serializable {

        private static final long serialVersionUID = -747438493L;

        LockingMANavigableSetWithSerializable(MANavigableSet<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMANavigableSetWithSerializable<E>((MANavigableSet<E>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (MANavigableSet<E>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingMASortedMapMASortedKeySetView<K, V> extends LockingMASortedSetMASortedSetView<K> implements MASortedMap.MASortedKeySetView<K, V> {

        LockingMASortedMapMASortedKeySetView(MASortedMap.MASortedKeySetView<K, V> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMASortedMapMASortedKeySetView<K, V>((MASortedMap.MASortedKeySetView<K, V>)obj, this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public MASortedMap.MASortedKeySetView<K, V> tailSet(K fromKey) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MASortedMap.MASortedKeySetView<K, V> org.babyfish.collection.MASortedMap.MASortedKeySetView<K, V>.tailSet(K)")
                );
            }
            return MACollections.locking(((MASortedMap.MASortedKeySetView<K, V>)this.c).tailSet(fromKey), this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public void removeKeySetElementListener(KeySetElementListener<? super K, ? super V> listener) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.removeKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.removeKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.removeKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
                );
            }
            ((MASortedMap.MASortedKeySetView<K, V>)this.c).removeKeySetElementListener(listener);
        }

        @SuppressWarnings("unchecked")
        @Override
        public MAMap.MAKeySetView.MAKeySetIterator<K, V> iterator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAMap$MAKeySetView.MAKeySetIterator<K, V> org.babyfish.collection.MAMap.MAKeySetView<K, V>.iterator()")
                );
            }
            return MACollections.locking(((MASortedMap.MASortedKeySetView<K, V>)this.c).iterator(), this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public MASortedMap.MASortedKeySetView<K, V> subSet(K fromKey, K toKey) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MASortedMap.MASortedKeySetView<K, V> org.babyfish.collection.MASortedMap.MASortedKeySetView<K, V>.subSet(K, K)")
                );
            }
            return MACollections.locking(((MASortedMap.MASortedKeySetView<K, V>)this.c).subSet(fromKey, toKey), this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public MASortedMap.MASortedKeySetView<K, V> headSet(K toKey) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MASortedMap.MASortedKeySetView<K, V> org.babyfish.collection.MASortedMap.MASortedKeySetView<K, V>.headSet(K)")
                );
            }
            return MACollections.locking(((MASortedMap.MASortedKeySetView<K, V>)this.c).headSet(toKey), this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public void addKeySetElementListener(KeySetElementListener<? super K, ? super V> listener) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.addKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.addKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.addKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
                );
            }
            ((MASortedMap.MASortedKeySetView<K, V>)this.c).addKeySetElementListener(listener);
        }
    }

    private static class LockingMASortedSetMASortedSetView<E> extends LockingMASortedSet<E> implements MASortedSet.MASortedSetView<E> {

        LockingMASortedSetMASortedSetView(MASortedSet.MASortedSetView<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMASortedSetMASortedSetView<E>((MASortedSet.MASortedSetView<E>)obj, this.lockingManager);
        }

        @Override
        public ViewInfo viewInfo() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            return ((MASortedSet.MASortedSetView<E>)this.c).viewInfo();
        }
    }

    private static class LockingMASortedSet<E> extends LockingMASet<E> implements MASortedSet<E> {

        LockingMASortedSet(MASortedSet<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @Deprecated //Only for deserialization
        LockingMASortedSet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMASortedSet<E>((MASortedSet<E>)obj, this.lockingManager);
        }

        @Override
        public MASortedSet.MASortedSetView<E> subSet(E fromElement, E toElement) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MASortedSet.MASortedSetView<E> org.babyfish.collection.MASortedSet<E>.subSet(E, E)")
                );
            }
            return MACollections.locking(((MASortedSet<E>)this.c).subSet(fromElement, toElement), this.lockingManager);
        }

        @Override
        public MASortedSet.MASortedSetView<E> tailSet(E fromElement) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MASortedSet.MASortedSetView<E> org.babyfish.collection.MASortedSet<E>.tailSet(E)")
                );
            }
            return MACollections.locking(((MASortedSet<E>)this.c).tailSet(fromElement), this.lockingManager);
        }

        @Override
        public E last() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.SortedSet<E>.last()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.SortedSet<E>.last()")
                );
            }
            return ((MASortedSet<E>)this.c).last();
        }

        @Override
        public E first() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.SortedSet<E>.first()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.SortedSet<E>.first()")
                );
            }
            return ((MASortedSet<E>)this.c).first();
        }

        @Override
        public Comparator<? super E> comparator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.Comparator<? super E> java.util.SortedSet<E>.comparator()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("java.util.Comparator<? super E> java.util.SortedSet<E>.comparator()")
                );
            }
            return ((MASortedSet<E>)this.c).comparator();
        }

        @Override
        public MASortedSet.MASortedSetView<E> headSet(E toElement) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MASortedSet.MASortedSetView<E> org.babyfish.collection.MASortedSet<E>.headSet(E)")
                );
            }
            return MACollections.locking(((MASortedSet<E>)this.c).headSet(toElement), this.lockingManager);
        }
    }

    private static class LockingMASortedSetWithSerializable<E> extends LockingMASortedSet<E> implements Serializable {

        private static final long serialVersionUID = -978099845L;

        LockingMASortedSetWithSerializable(MASortedSet<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMASortedSetWithSerializable<E>((MASortedSet<E>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (MASortedSet<E>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingMAMapMAEntrySetView<K, V> extends LockingMASet<Map.Entry<K, V>> implements MAMap.MAEntrySetView<K, V> {

        LockingMAMapMAEntrySetView(MAMap.MAEntrySetView<K, V> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMAMapMAEntrySetView<K, V>((MAMap.MAEntrySetView<K, V>)obj, this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public <T> T[] toArray(T[] a) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("T[] java.util.Set<java.util.Map.Entry<K, V>>.toArray(T[])")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("T[] java.util.Set<java.util.Map.Entry<K, V>>.toArray(T[])")
                );
            }
            Object[] arr = this.c.toArray(a.length==0 ? a : (Object[])Array.newInstance(a.getClass().getComponentType(), 0));
            for (int i = arr.length - 1; i >= 0; i--) {
                arr[i] = MACollections.locking((MAMap.MAEntry<K, V>)arr[i], lockingManager);
            }
            if (arr.length > a.length) {
                return (T[])arr;
            }
            System.arraycopy(arr, 0, a, 0, arr.length);
            if (a.length > arr.length) {
                a[arr.length] = null;
            }
            return a;
        }

        @Deprecated
        @Override
        public boolean add(Map.Entry<K, V> entry) {
            throw new UnsupportedOperationException(
                notSupported("boolean org.babyfish.collection.MAMap.MAEntrySetView<K, V>.add(java.util.Map.Entry<K, V>)")
            );
        }

        @SuppressWarnings("unchecked")
        @Override
        public ViewInfo viewInfo() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            return ((MAMap.MAEntrySetView<K, V>)this.c).viewInfo();
        }

        @SuppressWarnings("unchecked")
        @Override
        public Object[] toArray() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.lang.Object[] java.util.Set<java.util.Map.Entry<K, V>>.toArray()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("java.lang.Object[] java.util.Set<java.util.Map.Entry<K, V>>.toArray()")
                );
            }
            Object[] arr = this.c.toArray();
            for (int i = arr.length - 1; i >= 0; i--) {
                arr[i] = MACollections.locking((MAMap.MAEntry<K, V>)arr[i], lockingManager);
            }
            return arr;
        }

        @SuppressWarnings("unchecked")
        @Override
        public MAMap.MAEntrySetView.MAEntrySetIterator<K, V> iterator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAMap$MAEntrySetView.MAEntrySetIterator<K, V> org.babyfish.collection.MAMap.MAEntrySetView<K, V>.iterator()")
                );
            }
            return MACollections.locking(((MAMap.MAEntrySetView<K, V>)this.c).iterator(), this.lockingManager);
        }
    }

    private static class LockingMAMapMAValuesView<K, V> extends LockingMACollection<V> implements MAMap.MAValuesView<K, V> {

        LockingMAMapMAValuesView(MAMap.MAValuesView<K, V> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMAMapMAValuesView<K, V>((MAMap.MAValuesView<K, V>)obj, this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public void addValuesElementListener(ValuesElementListener<? super K, ? super V> listener) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.event.ValuesElementModificationAware<K, V>.addValuesElementListener(org.babyfish.collection.event.ValuesElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.event.ValuesElementModificationAware<K, V>.addValuesElementListener(org.babyfish.collection.event.ValuesElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.event.ValuesElementModificationAware<K, V>.addValuesElementListener(org.babyfish.collection.event.ValuesElementListener<? super K, ? super V>)")
                );
            }
            ((MAMap.MAValuesView<K, V>)this.c).addValuesElementListener(listener);
        }

        @SuppressWarnings("unchecked")
        @Override
        public void removeValuesElementListener(ValuesElementListener<? super K, ? super V> listener) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.event.ValuesElementModificationAware<K, V>.removeValuesElementListener(org.babyfish.collection.event.ValuesElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.event.ValuesElementModificationAware<K, V>.removeValuesElementListener(org.babyfish.collection.event.ValuesElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.event.ValuesElementModificationAware<K, V>.removeValuesElementListener(org.babyfish.collection.event.ValuesElementListener<? super K, ? super V>)")
                );
            }
            ((MAMap.MAValuesView<K, V>)this.c).removeValuesElementListener(listener);
        }

        @SuppressWarnings("unchecked")
        @Override
        public MAMap.MAValuesView.MAValuesIterator<K, V> iterator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAMap$MAValuesView.MAValuesIterator<K, V> org.babyfish.collection.MAMap.MAValuesView<K, V>.iterator()")
                );
            }
            return MACollections.locking(((MAMap.MAValuesView<K, V>)this.c).iterator(), this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public ViewInfo viewInfo() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            return ((MAMap.MAValuesView<K, V>)this.c).viewInfo();
        }
    }

    private static class LockingMAMapMAKeySetView<K, V> extends LockingMASet<K> implements MAMap.MAKeySetView<K, V> {

        LockingMAMapMAKeySetView(MAMap.MAKeySetView<K, V> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMAMapMAKeySetView<K, V>((MAMap.MAKeySetView<K, V>)obj, this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public void removeKeySetElementListener(KeySetElementListener<? super K, ? super V> listener) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.removeKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.removeKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.removeKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
                );
            }
            ((MAMap.MAKeySetView<K, V>)this.c).removeKeySetElementListener(listener);
        }

        @SuppressWarnings("unchecked")
        @Override
        public MAMap.MAKeySetView.MAKeySetIterator<K, V> iterator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAMap$MAKeySetView.MAKeySetIterator<K, V> org.babyfish.collection.MAMap.MAKeySetView<K, V>.iterator()")
                );
            }
            return MACollections.locking(((MAMap.MAKeySetView<K, V>)this.c).iterator(), this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public ViewInfo viewInfo() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            return ((MAMap.MAKeySetView<K, V>)this.c).viewInfo();
        }

        @SuppressWarnings("unchecked")
        @Override
        public void addKeySetElementListener(KeySetElementListener<? super K, ? super V> listener) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.addKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.addKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.addKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
                );
            }
            ((MAMap.MAKeySetView<K, V>)this.c).addKeySetElementListener(listener);
        }
    }

    private static class LockingMASet<E> extends LockingMACollection<E> implements MASet<E> {

        LockingMASet(MASet<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @Deprecated //Only for deserialization
        LockingMASet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMASet<E>((MASet<E>)obj, this.lockingManager);
        }

        @Override
        public ReplacementRule replacementRule() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.ReplacementRule org.babyfish.collection.XSet<E>.replacementRule()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.collection.ReplacementRule org.babyfish.collection.XSet<E>.replacementRule()")
                );
            }
            return ((MASet<E>)this.c).replacementRule();
        }
    }

    private static class LockingMASetWithSerializable<E> extends LockingMASet<E> implements Serializable {

        private static final long serialVersionUID = -6785469464844115810L;

        LockingMASetWithSerializable(MASet<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMASetWithSerializable<E>((MASet<E>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (MASet<E>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingMACollection<E> extends LockingXCollection<E> implements MACollection<E> {

        LockingMACollection(MACollection<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @Deprecated //Only for deserialization
        LockingMACollection() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMACollection<E>((MACollection<E>)obj, this.lockingManager);
        }

        @Override
        public MACollection.MAIterator<E> iterator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MACollection.MAIterator<E> org.babyfish.collection.MACollection<E>.iterator()")
                );
            }
            return MACollections.locking(((MACollection<E>)this.c).iterator(), this.lockingManager);
        }

        @Override
        public void removeElementListener(ElementListener<? super E> listener) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.event.ElementModificationAware<E>.removeElementListener(org.babyfish.collection.event.ElementListener<? super E>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.event.ElementModificationAware<E>.removeElementListener(org.babyfish.collection.event.ElementListener<? super E>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.event.ElementModificationAware<E>.removeElementListener(org.babyfish.collection.event.ElementListener<? super E>)")
                );
            }
            ((MACollection<E>)this.c).removeElementListener(listener);
        }

        @Override
        public void addElementListener(ElementListener<? super E> listener) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.event.ElementModificationAware<E>.addElementListener(org.babyfish.collection.event.ElementListener<? super E>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.event.ElementModificationAware<E>.addElementListener(org.babyfish.collection.event.ElementListener<? super E>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.event.ElementModificationAware<E>.addElementListener(org.babyfish.collection.event.ElementListener<? super E>)")
                );
            }
            ((MACollection<E>)this.c).addElementListener(listener);
        }
    }

    private static class LockingMACollectionWithSerializable<E> extends LockingMACollection<E> implements Serializable {

        private static final long serialVersionUID = 3173094382057335212L;

        LockingMACollectionWithSerializable(MACollection<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMACollectionWithSerializable<E>((MACollection<E>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (MACollection<E>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingXListXListView<E> extends LockingXList<E> implements XList.XListView<E> {

        LockingXListXListView(XList.XListView<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXListXListView<E>((XList.XListView<E>)obj, this.lockingManager);
        }

        @Override
        public ViewInfo viewInfo() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            return ((XList.XListView<E>)this.c).viewInfo();
        }
    }
    private static class LockingXListXListViewWithRandomAccess<E> extends LockingXListXListView<E> implements RandomAccess {

        LockingXListXListViewWithRandomAccess(XList.XListView<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXListXListViewWithRandomAccess<E>((XList.XListView<E>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (XList.XListView<E>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }


    private static class LockingXList<E> extends LockingXCollection<E> implements XList<E> {

        LockingXList(XList<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockingXList() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXList<E>((XList<E>)obj, this.lockingManager);
        }

        @Override
        public BidiType bidiType() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("BidiType org.babyfish.collection.XList<E>.bidiType()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("BidiType org.babyfish.collection.XList<E>.bidiType()")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("BidiType org.babyfish.collection.XList<E>.bidiType()")
                );
            }
            return ((XList<E>)this.c).bidiType();
        }

        @Override
        public int indexOf(Object o) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("int java.util.List<E>.indexOf(java.lang.Object)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("int java.util.List<E>.indexOf(java.lang.Object)")
                );
            }
            return ((XList<E>)this.c).indexOf(o);
        }

        @Override
        public int lastIndexOf(Object o) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("int java.util.List<E>.lastIndexOf(java.lang.Object)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("int java.util.List<E>.lastIndexOf(java.lang.Object)")
                );
            }
            return ((XList<E>)this.c).lastIndexOf(o);
        }

        @Override
        public E set(int index, E e) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.List<E>.set(int, E)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.List<E>.set(int, E)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("E java.util.List<E>.set(int, E)")
                );
            }
            return ((XList<E>)this.c).set(index, e);
        }

        @Override
        public XList.XListIterator<E> listIterator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XList.XListIterator<E> org.babyfish.collection.XList<E>.listIterator()")
                );
            }
            return MACollections.locking(((XList<E>)this.c).listIterator(), this.lockingManager);
        }

        @Override
        public E get(int index) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.List<E>.get(int)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.List<E>.get(int)")
                );
            }
            return ((XList<E>)this.c).get(index);
        }

        @Override
        public XList.XListIterator<E> listIterator(int index) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XList.XListIterator<E> org.babyfish.collection.XList<E>.listIterator(int)")
                );
            }
            return MACollections.locking(((XList<E>)this.c).listIterator(index), this.lockingManager);
        }

        @Override
        public XList.XListIterator<E> iterator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XList.XListIterator<E> org.babyfish.collection.XList<E>.iterator()")
                );
            }
            return MACollections.locking(((XList<E>)this.c).iterator(), this.lockingManager);
        }

        @Override
        public XList.XListView<E> subList(int from, int to) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XList.XListView<E> org.babyfish.collection.XList<E>.subList(int, int)")
                );
            }
            return MACollections.locking(((XList<E>)this.c).subList(from, to), this.lockingManager);
        }

        @Override
        public E remove(int index) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.List<E>.remove(int)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.List<E>.remove(int)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("E java.util.List<E>.remove(int)")
                );
            }
            return ((XList<E>)this.c).remove(index);
        }

        @Override
        public void add(int index, E e) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void java.util.List<E>.add(int, E)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void java.util.List<E>.add(int, E)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void java.util.List<E>.add(int, E)")
                );
            }
            ((XList<E>)this.c).add(index, e);
        }

        @Override
        public boolean addAll(int index, Collection<? extends E> c) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean java.util.List<E>.addAll(int, java.util.Collection<? extends E>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("boolean java.util.List<E>.addAll(int, java.util.Collection<? extends E>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("boolean java.util.List<E>.addAll(int, java.util.Collection<? extends E>)")
                );
            }
            return ((XList<E>)this.c).addAll(index, c);
        }
    }

    private static class LockingXListWithSerializable<E> extends LockingXList<E> implements Serializable {

        private static final long serialVersionUID = -459915082L;

        LockingXListWithSerializable(XList<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXListWithSerializable<E>((XList<E>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (XList<E>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingXListWithRandomAccess<E> extends LockingXList<E> implements RandomAccess {

        LockingXListWithRandomAccess(XList<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXListWithRandomAccess<E>((XList<E>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (XList<E>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }


    private static class LockingXListWithSerializableRandomAccess<E> extends LockingXList<E> implements Serializable, RandomAccess {

        private static final long serialVersionUID = -459915082L;

        LockingXListWithSerializableRandomAccess(XList<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXListWithSerializableRandomAccess<E>((XList<E>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (XList<E>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingXOrderedMapXOrderedKeySetView<K> extends LockingXOrderedSetXOrderedSetView<K> implements XOrderedMap.XOrderedKeySetView<K> {

        LockingXOrderedMapXOrderedKeySetView(XOrderedMap.XOrderedKeySetView<K> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXOrderedMapXOrderedKeySetView<K>((XOrderedMap.XOrderedKeySetView<K>)obj, this.lockingManager);
        }

        @Override
        public XOrderedMap.XOrderedKeySetView<K> descendingSet() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XOrderedMap.XOrderedKeySetView<K> org.babyfish.collection.XOrderedMap.XOrderedKeySetView<K>.descendingSet()")
                );
            }
            return MACollections.locking(((XOrderedMap.XOrderedKeySetView<K>)this.c).descendingSet(), this.lockingManager);
        }
    }

    private static class LockingXOrderedSetXOrderedSetView<E> extends LockingXOrderedSet<E> implements XOrderedSet.XOrderedSetView<E> {

        LockingXOrderedSetXOrderedSetView(XOrderedSet.XOrderedSetView<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXOrderedSetXOrderedSetView<E>((XOrderedSet.XOrderedSetView<E>)obj, this.lockingManager);
        }

        @Override
        public ViewInfo viewInfo() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            return ((XOrderedSet.XOrderedSetView<E>)this.c).viewInfo();
        }
    }

    private static class LockingXOrderedSet<E> extends LockingXSet<E> implements XOrderedSet<E> {

        LockingXOrderedSet(XOrderedSet<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockingXOrderedSet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXOrderedSet<E>((XOrderedSet<E>)obj, this.lockingManager);
        }

        @Override
        public XCollection.XIterator<E> descendingIterator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XCollection.XIterator<E> org.babyfish.collection.XOrderedSet<E>.descendingIterator()")
                );
            }
            return MACollections.locking(((XOrderedSet<E>)this.c).descendingIterator(), this.lockingManager);
        }

        @Override
        public XOrderedSet.XOrderedSetView<E> descendingSet() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XOrderedSet.XOrderedSetView<E> org.babyfish.collection.XOrderedSet<E>.descendingSet()")
                );
            }
            return MACollections.locking(((XOrderedSet<E>)this.c).descendingSet(), this.lockingManager);
        }

        @Override
        public OrderAdjustMode replaceMode() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.OrderAdjustMode org.babyfish.collection.XOrderedSet<E>.replaceMode()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.collection.OrderAdjustMode org.babyfish.collection.XOrderedSet<E>.replaceMode()")
                );
            }
            return ((XOrderedSet<E>)this.c).replaceMode();
        }

        @Override
        public boolean headAppend() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean org.babyfish.collection.XOrderedSet<E>.headAppend()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("boolean org.babyfish.collection.XOrderedSet<E>.headAppend()")
                );
            }
            return ((XOrderedSet<E>)this.c).headAppend();
        }

        @Override
        public E last() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E org.babyfish.collection.XOrderedSet<E>.last()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E org.babyfish.collection.XOrderedSet<E>.last()")
                );
            }
            return ((XOrderedSet<E>)this.c).last();
        }

        @Override
        public E first() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E org.babyfish.collection.XOrderedSet<E>.first()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E org.babyfish.collection.XOrderedSet<E>.first()")
                );
            }
            return ((XOrderedSet<E>)this.c).first();
        }

        @Override
        public E pollLast() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E org.babyfish.collection.XOrderedSet<E>.pollLast()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E org.babyfish.collection.XOrderedSet<E>.pollLast()")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("E org.babyfish.collection.XOrderedSet<E>.pollLast()")
                );
            }
            return ((XOrderedSet<E>)this.c).pollLast();
        }

        @Override
        public E pollFirst() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E org.babyfish.collection.XOrderedSet<E>.pollFirst()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E org.babyfish.collection.XOrderedSet<E>.pollFirst()")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("E org.babyfish.collection.XOrderedSet<E>.pollFirst()")
                );
            }
            return ((XOrderedSet<E>)this.c).pollFirst();
        }
    }

    private static class LockingXOrderedSetWithSerializable<E> extends LockingXOrderedSet<E> implements Serializable {

        private static final long serialVersionUID = 1705891029884936703L;

        LockingXOrderedSetWithSerializable(XOrderedSet<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXOrderedSetWithSerializable<E>((XOrderedSet<E>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (XOrderedSet<E>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingXNavigableMapXNavigableKeySetView<K> extends LockingXNavigableSetXNavigableSetView<K> implements XNavigableMap.XNavigableKeySetView<K> {

        LockingXNavigableMapXNavigableKeySetView(XNavigableMap.XNavigableKeySetView<K> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXNavigableMapXNavigableKeySetView<K>((XNavigableMap.XNavigableKeySetView<K>)obj, this.lockingManager);
        }

        @Override
        public XNavigableMap.XNavigableKeySetView<K> headSet(K toKey) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XNavigableMap.XNavigableKeySetView<K> org.babyfish.collection.XNavigableMap.XNavigableKeySetView<K>.headSet(K)")
                );
            }
            return MACollections.locking(((XNavigableMap.XNavigableKeySetView<K>)this.c).headSet(toKey), this.lockingManager);
        }

        @Override
        public XNavigableMap.XNavigableKeySetView<K> headSet(K toKey, boolean inclusive) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XNavigableMap.XNavigableKeySetView<K> org.babyfish.collection.XNavigableMap.XNavigableKeySetView<K>.headSet(K, boolean)")
                );
            }
            return MACollections.locking(((XNavigableMap.XNavigableKeySetView<K>)this.c).headSet(toKey, inclusive), this.lockingManager);
        }

        @Override
        public XNavigableMap.XNavigableKeySetView<K> tailSet(K fromKey) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XNavigableMap.XNavigableKeySetView<K> org.babyfish.collection.XNavigableMap.XNavigableKeySetView<K>.tailSet(K)")
                );
            }
            return MACollections.locking(((XNavigableMap.XNavigableKeySetView<K>)this.c).tailSet(fromKey), this.lockingManager);
        }

        @Override
        public XNavigableMap.XNavigableKeySetView<K> tailSet(K fromKey, boolean inclusive) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XNavigableMap.XNavigableKeySetView<K> org.babyfish.collection.XNavigableMap.XNavigableKeySetView<K>.tailSet(K, boolean)")
                );
            }
            return MACollections.locking(((XNavigableMap.XNavigableKeySetView<K>)this.c).tailSet(fromKey, inclusive), this.lockingManager);
        }

        @Override
        public XNavigableMap.XNavigableKeySetView<K> subSet(K fromKey, K toKey) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XNavigableMap.XNavigableKeySetView<K> org.babyfish.collection.XNavigableMap.XNavigableKeySetView<K>.subSet(K, K)")
                );
            }
            return MACollections.locking(((XNavigableMap.XNavigableKeySetView<K>)this.c).subSet(fromKey, toKey), this.lockingManager);
        }

        @Override
        public XNavigableMap.XNavigableKeySetView<K> descendingSet() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XNavigableMap.XNavigableKeySetView<K> org.babyfish.collection.XNavigableMap.XNavigableKeySetView<K>.descendingSet()")
                );
            }
            return MACollections.locking(((XNavigableMap.XNavigableKeySetView<K>)this.c).descendingSet(), this.lockingManager);
        }

        @Override
        public XNavigableMap.XNavigableKeySetView<K> subSet(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XNavigableMap.XNavigableKeySetView<K> org.babyfish.collection.XNavigableMap.XNavigableKeySetView<K>.subSet(K, boolean, K, boolean)")
                );
            }
            return MACollections.locking(((XNavigableMap.XNavigableKeySetView<K>)this.c).subSet(fromKey, fromInclusive, toKey, toInclusive), this.lockingManager);
        }
    }

    private static class LockingXNavigableSetXNavigableSetView<E> extends LockingXNavigableSet<E> implements XNavigableSet.XNavigableSetView<E> {

        LockingXNavigableSetXNavigableSetView(XNavigableSet.XNavigableSetView<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXNavigableSetXNavigableSetView<E>((XNavigableSet.XNavigableSetView<E>)obj, this.lockingManager);
        }

        @Override
        public ViewInfo viewInfo() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            return ((XNavigableSet.XNavigableSetView<E>)this.c).viewInfo();
        }
    }

    private static class LockingXNavigableSet<E> extends LockingXSortedSet<E> implements XNavigableSet<E> {

        LockingXNavigableSet(XNavigableSet<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockingXNavigableSet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXNavigableSet<E>((XNavigableSet<E>)obj, this.lockingManager);
        }

        @Override
        public XNavigableSet.XNavigableSetView<E> subSet(E fromElement, E toElement) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XNavigableSet.XNavigableSetView<E> org.babyfish.collection.XNavigableSet<E>.subSet(E, E)")
                );
            }
            return MACollections.locking(((XNavigableSet<E>)this.c).subSet(fromElement, toElement), this.lockingManager);
        }

        @Override
        public E higher(E e) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.NavigableSet<E>.higher(E)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.NavigableSet<E>.higher(E)")
                );
            }
            return ((XNavigableSet<E>)this.c).higher(e);
        }

        @Override
        public XNavigableSet.XNavigableSetView<E> headSet(E toElement) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XNavigableSet.XNavigableSetView<E> org.babyfish.collection.XNavigableSet<E>.headSet(E)")
                );
            }
            return MACollections.locking(((XNavigableSet<E>)this.c).headSet(toElement), this.lockingManager);
        }

        @Override
        public E lower(E e) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.NavigableSet<E>.lower(E)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.NavigableSet<E>.lower(E)")
                );
            }
            return ((XNavigableSet<E>)this.c).lower(e);
        }

        @Override
        public XCollection.XIterator<E> descendingIterator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XCollection.XIterator<E> org.babyfish.collection.XNavigableSet<E>.descendingIterator()")
                );
            }
            return MACollections.locking(((XNavigableSet<E>)this.c).descendingIterator(), this.lockingManager);
        }

        @Override
        public XNavigableSet.XNavigableSetView<E> tailSet(E fromElement) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XNavigableSet.XNavigableSetView<E> org.babyfish.collection.XNavigableSet<E>.tailSet(E)")
                );
            }
            return MACollections.locking(((XNavigableSet<E>)this.c).tailSet(fromElement), this.lockingManager);
        }

        @Override
        public E floor(E e) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.NavigableSet<E>.floor(E)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.NavigableSet<E>.floor(E)")
                );
            }
            return ((XNavigableSet<E>)this.c).floor(e);
        }

        @Override
        public XNavigableSet.XNavigableSetView<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XNavigableSet.XNavigableSetView<E> org.babyfish.collection.XNavigableSet<E>.subSet(E, boolean, E, boolean)")
                );
            }
            return MACollections.locking(((XNavigableSet<E>)this.c).subSet(fromElement, fromInclusive, toElement, toInclusive), this.lockingManager);
        }

        @Override
        public XNavigableSet.XNavigableSetView<E> descendingSet() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XNavigableSet.XNavigableSetView<E> org.babyfish.collection.XNavigableSet<E>.descendingSet()")
                );
            }
            return MACollections.locking(((XNavigableSet<E>)this.c).descendingSet(), this.lockingManager);
        }

        @Override
        public E ceiling(E e) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.NavigableSet<E>.ceiling(E)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.NavigableSet<E>.ceiling(E)")
                );
            }
            return ((XNavigableSet<E>)this.c).ceiling(e);
        }

        @Override
        public XNavigableSet.XNavigableSetView<E> tailSet(E fromElement, boolean inclusive) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XNavigableSet.XNavigableSetView<E> org.babyfish.collection.XNavigableSet<E>.tailSet(E, boolean)")
                );
            }
            return MACollections.locking(((XNavigableSet<E>)this.c).tailSet(fromElement, inclusive), this.lockingManager);
        }

        @Override
        public XNavigableSet.XNavigableSetView<E> headSet(E toElement, boolean inclusive) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XNavigableSet.XNavigableSetView<E> org.babyfish.collection.XNavigableSet<E>.headSet(E, boolean)")
                );
            }
            return MACollections.locking(((XNavigableSet<E>)this.c).headSet(toElement, inclusive), this.lockingManager);
        }

        @Override
        public E pollLast() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.NavigableSet<E>.pollLast()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.NavigableSet<E>.pollLast()")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("E java.util.NavigableSet<E>.pollLast()")
                );
            }
            return ((XNavigableSet<E>)this.c).pollLast();
        }

        @Override
        public E pollFirst() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.NavigableSet<E>.pollFirst()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.NavigableSet<E>.pollFirst()")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("E java.util.NavigableSet<E>.pollFirst()")
                );
            }
            return ((XNavigableSet<E>)this.c).pollFirst();
        }
    }

    private static class LockingXNavigableSetWithSerializable<E> extends LockingXNavigableSet<E> implements Serializable {

        private static final long serialVersionUID = -5085568347069079123L;

        LockingXNavigableSetWithSerializable(XNavigableSet<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXNavigableSetWithSerializable<E>((XNavigableSet<E>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (XNavigableSet<E>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingXSortedMapXSortedKeySetView<K> extends LockingXSortedSetXSortedSetView<K> implements XSortedMap.XSortedKeySetView<K> {

        LockingXSortedMapXSortedKeySetView(XSortedMap.XSortedKeySetView<K> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXSortedMapXSortedKeySetView<K>((XSortedMap.XSortedKeySetView<K>)obj, this.lockingManager);
        }

        @Override
        public XSortedMap.XSortedKeySetView<K> subSet(K fromKey, K toKey) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XSortedMap.XSortedKeySetView<K> org.babyfish.collection.XSortedMap.XSortedKeySetView<K>.subSet(K, K)")
                );
            }
            return MACollections.locking(((XSortedMap.XSortedKeySetView<K>)this.c).subSet(fromKey, toKey), this.lockingManager);
        }

        @Override
        public XSortedMap.XSortedKeySetView<K> headSet(K toKey) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XSortedMap.XSortedKeySetView<K> org.babyfish.collection.XSortedMap.XSortedKeySetView<K>.headSet(K)")
                );
            }
            return MACollections.locking(((XSortedMap.XSortedKeySetView<K>)this.c).headSet(toKey), this.lockingManager);
        }

        @Override
        public XSortedMap.XSortedKeySetView<K> tailSet(K fromKey) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XSortedMap.XSortedKeySetView<K> org.babyfish.collection.XSortedMap.XSortedKeySetView<K>.tailSet(K)")
                );
            }
            return MACollections.locking(((XSortedMap.XSortedKeySetView<K>)this.c).tailSet(fromKey), this.lockingManager);
        }
    }

    private static class LockingXSortedSetXSortedSetView<E> extends LockingXSortedSet<E> implements XSortedSet.XSortedSetView<E> {

        LockingXSortedSetXSortedSetView(XSortedSet.XSortedSetView<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXSortedSetXSortedSetView<E>((XSortedSet.XSortedSetView<E>)obj, this.lockingManager);
        }

        @Override
        public ViewInfo viewInfo() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            return ((XSortedSet.XSortedSetView<E>)this.c).viewInfo();
        }
    }

    private static class LockingXSortedSet<E> extends LockingXSet<E> implements XSortedSet<E> {

        LockingXSortedSet(XSortedSet<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @Deprecated //Only for deserialization
        LockingXSortedSet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXSortedSet<E>((XSortedSet<E>)obj, this.lockingManager);
        }

        @Override
        public XSortedSet.XSortedSetView<E> tailSet(E fromElement) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XSortedSet.XSortedSetView<E> org.babyfish.collection.XSortedSet<E>.tailSet(E)")
                );
            }
            return MACollections.locking(((XSortedSet<E>)this.c).tailSet(fromElement), this.lockingManager);
        }

        @Override
        public XSortedSet.XSortedSetView<E> subSet(E fromElement, E toElement) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XSortedSet.XSortedSetView<E> org.babyfish.collection.XSortedSet<E>.subSet(E, E)")
                );
            }
            return MACollections.locking(((XSortedSet<E>)this.c).subSet(fromElement, toElement), this.lockingManager);
        }

        @Override
        public E last() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.SortedSet<E>.last()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.SortedSet<E>.last()")
                );
            }
            return ((XSortedSet<E>)this.c).last();
        }

        @Override
        public E first() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.SortedSet<E>.first()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.SortedSet<E>.first()")
                );
            }
            return ((XSortedSet<E>)this.c).first();
        }

        @Override
        public Comparator<? super E> comparator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.Comparator<? super E> java.util.SortedSet<E>.comparator()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("java.util.Comparator<? super E> java.util.SortedSet<E>.comparator()")
                );
            }
            return ((XSortedSet<E>)this.c).comparator();
        }

        @Override
        public XSortedSet.XSortedSetView<E> headSet(E toElement) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XSortedSet.XSortedSetView<E> org.babyfish.collection.XSortedSet<E>.headSet(E)")
                );
            }
            return MACollections.locking(((XSortedSet<E>)this.c).headSet(toElement), this.lockingManager);
        }
    }

    private static class LockingXSortedSetWithSerializable<E> extends LockingXSortedSet<E> implements Serializable {

        private static final long serialVersionUID = -379710863L;

        LockingXSortedSetWithSerializable(XSortedSet<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXSortedSetWithSerializable<E>((XSortedSet<E>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (XSortedSet<E>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingXMapXKeySetView<K> extends LockingXSet<K> implements XMap.XKeySetView<K> {

        LockingXMapXKeySetView(XMap.XKeySetView<K> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXMapXKeySetView<K>((XMap.XKeySetView<K>)obj, this.lockingManager);
        }

        @Override
        public ViewInfo viewInfo() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            return ((XMap.XKeySetView<K>)this.c).viewInfo();
        }
    }

    private static class LockingXMapXEntrySetView<K, V> extends LockingXSet<Map.Entry<K, V>> implements XMap.XEntrySetView<K, V> {

        LockingXMapXEntrySetView(XMap.XEntrySetView<K, V> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXMapXEntrySetView<K, V>((XMap.XEntrySetView<K, V>)obj, this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public <T> T[] toArray(T[] a) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("T[] java.util.Set<java.util.Map.Entry<K, V>>.toArray(T[])")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("T[] java.util.Set<java.util.Map.Entry<K, V>>.toArray(T[])")
                );
            }
            Object[] arr = this.c.toArray(a.length==0 ? a : (Object[])Array.newInstance(a.getClass().getComponentType(), 0));
            for (int i = arr.length - 1; i >= 0; i--) {
                arr[i] = MACollections.locking((XMap.XEntry<K, V>)arr[i], lockingManager);
            }
            if (arr.length > a.length) {
                return (T[])arr;
            }
            System.arraycopy(arr, 0, a, 0, arr.length);
            if (a.length > arr.length) {
                a[arr.length] = null;
            }
            return a;
        }

        @Deprecated
        @Override
        public boolean add(Map.Entry<K, V> entry) {
            throw new UnsupportedOperationException(
                notSupported("boolean org.babyfish.collection.XMap.XEntrySetView<K, V>.add(java.util.Map.Entry<K, V>)")
            );
        }

        @SuppressWarnings("unchecked")
        @Override
        public ViewInfo viewInfo() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            return ((XMap.XEntrySetView<K, V>)this.c).viewInfo();
        }

        @SuppressWarnings("unchecked")
        @Override
        public Object[] toArray() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.lang.Object[] java.util.Set<java.util.Map.Entry<K, V>>.toArray()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("java.lang.Object[] java.util.Set<java.util.Map.Entry<K, V>>.toArray()")
                );
            }
            Object[] arr = this.c.toArray();
            for (int i = arr.length - 1; i >= 0; i--) {
                arr[i] = MACollections.locking((XMap.XEntry<K, V>)arr[i], lockingManager);
            }
            return arr;
        }

        @SuppressWarnings("unchecked")
        @Override
        public XMap.XEntrySetView.XEntrySetIterator<K, V> iterator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XMap$XEntrySetView.XEntrySetIterator<K, V> org.babyfish.collection.XMap.XEntrySetView<K, V>.iterator()")
                );
            }
            return MACollections.locking(((XMap.XEntrySetView<K, V>)this.c).iterator(), this.lockingManager);
        }
    }

    private static class LockingXSet<E> extends LockingXCollection<E> implements XSet<E> {

        LockingXSet(XSet<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @Deprecated //Only for deserialization
        LockingXSet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXSet<E>((XSet<E>)obj, this.lockingManager);
        }

        @Override
        public ReplacementRule replacementRule() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.ReplacementRule org.babyfish.collection.XSet<E>.replacementRule()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.collection.ReplacementRule org.babyfish.collection.XSet<E>.replacementRule()")
                );
            }
            return ((XSet<E>)this.c).replacementRule();
        }
    }

    private static class LockingXSetWithSerializable<E> extends LockingXSet<E> implements Serializable {

        private static final long serialVersionUID = 551586428331295252L;

        LockingXSetWithSerializable(XSet<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXSetWithSerializable<E>((XSet<E>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (XSet<E>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingXMapXValuesView<V> extends LockingXCollection<V> implements XMap.XValuesView<V> {

        LockingXMapXValuesView(XMap.XValuesView<V> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXMapXValuesView<V>((XMap.XValuesView<V>)obj, this.lockingManager);
        }

        @Override
        public ViewInfo viewInfo() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            return ((XMap.XValuesView<V>)this.c).viewInfo();
        }
    }

    private static class LockingXCollection<E> extends LockingCollection<E> implements XCollection<E> {

        LockingXCollection(XCollection<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @Deprecated //Only for deserialization
        LockingXCollection() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXCollection<E>((XCollection<E>)obj, this.lockingManager);
        }

        @Override
        public XCollection.XIterator<E> iterator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XCollection.XIterator<E> org.babyfish.collection.XCollection<E>.iterator()")
                );
            }
            return MACollections.locking(((XCollection<E>)this.c).iterator(), this.lockingManager);
        }

        @Override
        public UnifiedComparator<? super E> unifiedComparator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.UnifiedComparator<? super E> org.babyfish.collection.XCollection<E>.unifiedComparator()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.collection.UnifiedComparator<? super E> org.babyfish.collection.XCollection<E>.unifiedComparator()")
                );
            }
            return ((XCollection<E>)this.c).unifiedComparator();
        }
        
        @Override
        public boolean isReadWriteLockSupported() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean org.babyfish.lang.LockDescriptor.isReadWriteLockSupported()")
                );
            }
            return ((XCollection<E>)this.c).isReadWriteLockSupported();
        }

        @Override
        public void validate(E e) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.XCollection<E>.validate(E)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.XCollection<E>.validate(E)")
                );
            }
            ((XCollection<E>)this.c).validate(e);
        }

        @Override
        public void removeValidator(Validator<E> validator) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.XCollection<E>.removeValidator(org.babyfish.validator.Validator<E>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.XCollection<E>.removeValidator(org.babyfish.validator.Validator<E>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.XCollection<E>.removeValidator(org.babyfish.validator.Validator<E>)")
                );
            }
            ((XCollection<E>)this.c).removeValidator(validator);
        }

        @Override
        public void addValidator(Validator<E> validator) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.XCollection<E>.addValidator(org.babyfish.validator.Validator<E>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.XCollection<E>.addValidator(org.babyfish.validator.Validator<E>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.XCollection<E>.addValidator(org.babyfish.validator.Validator<E>)")
                );
            }
            ((XCollection<E>)this.c).addValidator(validator);
        }
    }

    private static class LockingXCollectionWithSerializable<E> extends LockingXCollection<E> implements Serializable {

        private static final long serialVersionUID = -1426319498L;

        LockingXCollectionWithSerializable(XCollection<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXCollectionWithSerializable<E>((XCollection<E>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (XCollection<E>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingStandardMapEntrySet<K, V> extends LockingSet<Map.Entry<K, V>> implements StandardMap.EntrySet<K, V> {

        LockingStandardMapEntrySet(StandardMap.EntrySet<K, V> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockingStandardMapEntrySet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingStandardMapEntrySet<K, V>((StandardMap.EntrySet<K, V>)obj, this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public Object[] toArray() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.lang.Object[] java.util.Set<java.util.Map.Entry<K, V>>.toArray()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("java.lang.Object[] java.util.Set<java.util.Map.Entry<K, V>>.toArray()")
                );
            }
            Object[] arr = this.c.toArray();
            for (int i = arr.length - 1; i >= 0; i--) {
                arr[i] = MACollections.locking((Map.Entry<K, V>)arr[i], lockingManager);
            }
            return arr;
        }

        @SuppressWarnings("unchecked")
        @Override
        public <T> T[] toArray(T[] a) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("T[] java.util.Set<java.util.Map.Entry<K, V>>.toArray(T[])")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("T[] java.util.Set<java.util.Map.Entry<K, V>>.toArray(T[])")
                );
            }
            Object[] arr = this.c.toArray(a.length==0 ? a : (Object[])Array.newInstance(a.getClass().getComponentType(), 0));
            for (int i = arr.length - 1; i >= 0; i--) {
                arr[i] = MACollections.locking((Map.Entry<K, V>)arr[i], lockingManager);
            }
            if (arr.length > a.length) {
                return (T[])arr;
            }
            System.arraycopy(arr, 0, a, 0, arr.length);
            if (a.length > arr.length) {
                a[arr.length] = null;
            }
            return a;
        }

        @SuppressWarnings("unchecked")
        @Override
        public StandardMap.EntrySet.EntryIterator<K, V> iterator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MACollections$StandardMap$EntrySet.EntryIterator<K, V> org.babyfish.collection.MACollections$StandardMap.EntrySet<K, V>.iterator()")
                );
            }
            return MACollections.locking(((StandardMap.EntrySet<K, V>)this.c).iterator(), this.lockingManager);
        }
    }

    private static class LockingStandardMapEntrySetWithSerializable<K, V> extends LockingStandardMapEntrySet<K, V> implements Serializable {

        private static final long serialVersionUID = 5255093045714056707L;

        LockingStandardMapEntrySetWithSerializable(StandardMap.EntrySet<K, V> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingStandardMapEntrySetWithSerializable<K, V>((StandardMap.EntrySet<K, V>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (StandardMap.EntrySet<K, V>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingList<E> extends LockingCollection<E> implements List<E> {

        LockingList(List<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockingList() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingList<E>((List<E>)obj, this.lockingManager);
        }

        @Override
        public int indexOf(Object o) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("int java.util.List<E>.indexOf(java.lang.Object)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("int java.util.List<E>.indexOf(java.lang.Object)")
                );
            }
            return ((List<E>)this.c).indexOf(o);
        }

        @Override
        public int lastIndexOf(Object o) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("int java.util.List<E>.lastIndexOf(java.lang.Object)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("int java.util.List<E>.lastIndexOf(java.lang.Object)")
                );
            }
            return ((List<E>)this.c).lastIndexOf(o);
        }

        @Override
        public List<E> subList(int from, int to) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.List<E> java.util.List<E>.subList(int, int)")
                );
            }
            return MACollections.locking(((List<E>)this.c).subList(from, to), this.lockingManager);
        }

        @Override
        public E set(int index, E e) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.List<E>.set(int, E)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.List<E>.set(int, E)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("E java.util.List<E>.set(int, E)")
                );
            }
            return ((List<E>)this.c).set(index, e);
        }

        @Override
        public ListIterator<E> listIterator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.ListIterator<E> java.util.List<E>.listIterator()")
                );
            }
            return MACollections.locking(((List<E>)this.c).listIterator(), this.lockingManager);
        }

        @Override
        public E get(int index) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.List<E>.get(int)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.List<E>.get(int)")
                );
            }
            return ((List<E>)this.c).get(index);
        }

        @Override
        public ListIterator<E> listIterator(int index) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.ListIterator<E> java.util.List<E>.listIterator(int)")
                );
            }
            return MACollections.locking(((List<E>)this.c).listIterator(index), this.lockingManager);
        }

        @Override
        public E remove(int index) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.List<E>.remove(int)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.List<E>.remove(int)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("E java.util.List<E>.remove(int)")
                );
            }
            return ((List<E>)this.c).remove(index);
        }

        @Override
        public void add(int index, E e) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void java.util.List<E>.add(int, E)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void java.util.List<E>.add(int, E)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void java.util.List<E>.add(int, E)")
                );
            }
            ((List<E>)this.c).add(index, e);
        }

        @Override
        public boolean addAll(int index, Collection<? extends E> c) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean java.util.List<E>.addAll(int, java.util.Collection<? extends E>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("boolean java.util.List<E>.addAll(int, java.util.Collection<? extends E>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("boolean java.util.List<E>.addAll(int, java.util.Collection<? extends E>)")
                );
            }
            return ((List<E>)this.c).addAll(index, c);
        }
    }

    private static class LockingListWithSerializable<E> extends LockingList<E> implements Serializable {

        private static final long serialVersionUID = -819846720L;

        LockingListWithSerializable(List<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingListWithSerializable<E>((List<E>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (List<E>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingListWithRandomAccess<E> extends LockingList<E> implements RandomAccess {

        LockingListWithRandomAccess(List<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingListWithRandomAccess<E>((List<E>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (List<E>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }


    private static class LockingListWithSerializableRandomAccess<E> extends LockingList<E> implements Serializable, RandomAccess {

        private static final long serialVersionUID = -819846720L;

        LockingListWithSerializableRandomAccess(List<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingListWithSerializableRandomAccess<E>((List<E>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (List<E>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingNavigableSet<E> extends LockingSortedSet<E> implements NavigableSet<E> {

        LockingNavigableSet(NavigableSet<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockingNavigableSet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingNavigableSet<E>((NavigableSet<E>)obj, this.lockingManager);
        }

        @Override
        public NavigableSet<E> tailSet(E fromElement, boolean inclusive) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.NavigableSet<E> java.util.NavigableSet<E>.tailSet(E, boolean)")
                );
            }
            return MACollections.locking(((NavigableSet<E>)this.c).tailSet(fromElement, inclusive), this.lockingManager);
        }

        @Override
        public E floor(E e) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.NavigableSet<E>.floor(E)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.NavigableSet<E>.floor(E)")
                );
            }
            return ((NavigableSet<E>)this.c).floor(e);
        }

        @Override
        public E ceiling(E e) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.NavigableSet<E>.ceiling(E)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.NavigableSet<E>.ceiling(E)")
                );
            }
            return ((NavigableSet<E>)this.c).ceiling(e);
        }

        @Override
        public E higher(E e) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.NavigableSet<E>.higher(E)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.NavigableSet<E>.higher(E)")
                );
            }
            return ((NavigableSet<E>)this.c).higher(e);
        }

        @Override
        public NavigableSet<E> headSet(E toElement, boolean inclusive) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.NavigableSet<E> java.util.NavigableSet<E>.headSet(E, boolean)")
                );
            }
            return MACollections.locking(((NavigableSet<E>)this.c).headSet(toElement, inclusive), this.lockingManager);
        }

        @Override
        public Iterator<E> descendingIterator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.Iterator<E> java.util.NavigableSet<E>.descendingIterator()")
                );
            }
            return MACollections.locking(((NavigableSet<E>)this.c).descendingIterator(), this.lockingManager);
        }

        @Override
        public NavigableSet<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.NavigableSet<E> java.util.NavigableSet<E>.subSet(E, boolean, E, boolean)")
                );
            }
            return MACollections.locking(((NavigableSet<E>)this.c).subSet(fromElement, fromInclusive, toElement, toInclusive), this.lockingManager);
        }

        @Override
        public E lower(E e) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.NavigableSet<E>.lower(E)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.NavigableSet<E>.lower(E)")
                );
            }
            return ((NavigableSet<E>)this.c).lower(e);
        }

        @Override
        public E pollLast() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.NavigableSet<E>.pollLast()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.NavigableSet<E>.pollLast()")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("E java.util.NavigableSet<E>.pollLast()")
                );
            }
            return ((NavigableSet<E>)this.c).pollLast();
        }

        @Override
        public NavigableSet<E> descendingSet() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.NavigableSet<E> java.util.NavigableSet<E>.descendingSet()")
                );
            }
            return MACollections.locking(((NavigableSet<E>)this.c).descendingSet(), this.lockingManager);
        }

        @Override
        public E pollFirst() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.NavigableSet<E>.pollFirst()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.NavigableSet<E>.pollFirst()")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("E java.util.NavigableSet<E>.pollFirst()")
                );
            }
            return ((NavigableSet<E>)this.c).pollFirst();
        }
    }

    private static class LockingNavigableSetWithSerializable<E> extends LockingNavigableSet<E> implements Serializable {

        private static final long serialVersionUID = -2017371977L;

        LockingNavigableSetWithSerializable(NavigableSet<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingNavigableSetWithSerializable<E>((NavigableSet<E>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (NavigableSet<E>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingSortedSet<E> extends LockingSet<E> implements SortedSet<E> {

        LockingSortedSet(SortedSet<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @Deprecated //Only for deserialization
        LockingSortedSet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingSortedSet<E>((SortedSet<E>)obj, this.lockingManager);
        }

        @Override
        public SortedSet<E> tailSet(E fromElement) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.SortedSet<E> java.util.SortedSet<E>.tailSet(E)")
                );
            }
            return MACollections.locking(((SortedSet<E>)this.c).tailSet(fromElement), this.lockingManager);
        }

        @Override
        public SortedSet<E> subSet(E fromElement, E toElement) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.SortedSet<E> java.util.SortedSet<E>.subSet(E, E)")
                );
            }
            return MACollections.locking(((SortedSet<E>)this.c).subSet(fromElement, toElement), this.lockingManager);
        }

        @Override
        public E last() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.SortedSet<E>.last()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.SortedSet<E>.last()")
                );
            }
            return ((SortedSet<E>)this.c).last();
        }

        @Override
        public E first() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.SortedSet<E>.first()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.SortedSet<E>.first()")
                );
            }
            return ((SortedSet<E>)this.c).first();
        }

        @Override
        public Comparator<? super E> comparator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.Comparator<? super E> java.util.SortedSet<E>.comparator()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("java.util.Comparator<? super E> java.util.SortedSet<E>.comparator()")
                );
            }
            return ((SortedSet<E>)this.c).comparator();
        }

        @Override
        public SortedSet<E> headSet(E toElement) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.SortedSet<E> java.util.SortedSet<E>.headSet(E)")
                );
            }
            return MACollections.locking(((SortedSet<E>)this.c).headSet(toElement), this.lockingManager);
        }
    }

    private static class LockingSortedSetWithSerializable<E> extends LockingSortedSet<E> implements Serializable {

        private static final long serialVersionUID = -517519449L;

        LockingSortedSetWithSerializable(SortedSet<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingSortedSetWithSerializable<E>((SortedSet<E>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (SortedSet<E>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingSet<E> extends LockingCollection<E> implements Set<E> {

        LockingSet(Set<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @Deprecated //Only for deserialization
        LockingSet() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingSet<E>((Set<E>)obj, this.lockingManager);
        }
    }

    private static class LockingSetWithSerializable<E> extends LockingSet<E> implements Serializable {

        private static final long serialVersionUID = 6444733139883120586L;

        LockingSetWithSerializable(Set<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingSetWithSerializable<E>((Set<E>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (Set<E>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingCollection<E> extends LockingProxy implements Collection<E> {

        Collection<E> c;

        LockingCollection(Collection<E> c, LockingManager lockingManager) {
            super(lockingManager);
            this.c = c;
        }

        @Deprecated //Only for deserialization
        LockingCollection() {
        }

        @Override
        Object getInnerObject() {
            return this.c;
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingCollection<E>((Collection<E>)obj, this.lockingManager);
        }

        @Override
        public String toString() {
            return this.c.toString();
        }

        @Override
        public boolean isEmpty() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean java.util.Collection<E>.isEmpty()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("boolean java.util.Collection<E>.isEmpty()")
                );
            }
            return this.c.isEmpty();
        }

        @Override
        public boolean retainAll(Collection<? extends Object> c) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean java.util.Collection<E>.retainAll(java.util.Collection<?>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("boolean java.util.Collection<E>.retainAll(java.util.Collection<?>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("boolean java.util.Collection<E>.retainAll(java.util.Collection<?>)")
                );
            }
            return this.c.retainAll(c);
        }

        @Override
        public boolean remove(Object o) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean java.util.Collection<E>.remove(java.lang.Object)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("boolean java.util.Collection<E>.remove(java.lang.Object)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("boolean java.util.Collection<E>.remove(java.lang.Object)")
                );
            }
            return this.c.remove(o);
        }

        @Override
        public void clear() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void java.util.Collection<E>.clear()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void java.util.Collection<E>.clear()")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void java.util.Collection<E>.clear()")
                );
            }
            this.c.clear();
        }

        @Override
        public boolean contains(Object o) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean java.util.Collection<E>.contains(java.lang.Object)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("boolean java.util.Collection<E>.contains(java.lang.Object)")
                );
            }
            return this.c.contains(o);
        }

        @Override
        public Iterator<E> iterator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.Iterator<E> java.util.Collection<E>.iterator()")
                );
            }
            return MACollections.locking(this.c.iterator(), this.lockingManager);
        }

        @Override
        public boolean removeAll(Collection<? extends Object> c) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean java.util.Collection<E>.removeAll(java.util.Collection<?>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("boolean java.util.Collection<E>.removeAll(java.util.Collection<?>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("boolean java.util.Collection<E>.removeAll(java.util.Collection<?>)")
                );
            }
            return this.c.removeAll(c);
        }

        @Override
        public boolean addAll(Collection<? extends E> c) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean java.util.Collection<E>.addAll(java.util.Collection<? extends E>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("boolean java.util.Collection<E>.addAll(java.util.Collection<? extends E>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("boolean java.util.Collection<E>.addAll(java.util.Collection<? extends E>)")
                );
            }
            return this.c.addAll(c);
        }

        @Override
        public Object[] toArray() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.lang.Object[] java.util.Collection<E>.toArray()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("java.lang.Object[] java.util.Collection<E>.toArray()")
                );
            }
            return this.c.toArray();
        }

        @Override
        public boolean add(E e) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean java.util.Collection<E>.add(E)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("boolean java.util.Collection<E>.add(E)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("boolean java.util.Collection<E>.add(E)")
                );
            }
            return this.c.add(e);
        }

        @Override
        public int hashCode() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("int java.util.Collection<E>.hashCode()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("int java.util.Collection<E>.hashCode()")
                );
            }
            return this.c.hashCode();
        }

        @Override
        public <T> T[] toArray(T[] a) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("T[] java.util.Collection<E>.toArray(T[])")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("T[] java.util.Collection<E>.toArray(T[])")
                );
            }
            return this.c.toArray(a);
        }

        @Override
        public boolean equals(Object obj) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean java.util.Collection<E>.equals(java.lang.Object)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("boolean java.util.Collection<E>.equals(java.lang.Object)")
                );
            }
            return this.c.equals(obj);
        }

        @Override
        public int size() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("int java.util.Collection<E>.size()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("int java.util.Collection<E>.size()")
                );
            }
            return this.c.size();
        }

        @Override
        public boolean containsAll(Collection<? extends Object> c) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean java.util.Collection<E>.containsAll(java.util.Collection<?>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("boolean java.util.Collection<E>.containsAll(java.util.Collection<?>)")
                );
            }
            return this.c.containsAll(c);
        }
    }

    private static class LockingCollectionWithSerializable<E> extends LockingCollection<E> implements Serializable {

        private static final long serialVersionUID = -1403418368L;

        LockingCollectionWithSerializable(Collection<E> c, LockingManager lockingManager) {
            super(c, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingCollectionWithSerializable<E>((Collection<E>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.c);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.c = (Collection<E>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingMAMapMAValuesViewMAValuesIterator<K, V> extends LockingMACollectionMAIterator<V> implements MAMap.MAValuesView.MAValuesIterator<K, V> {

        LockingMAMapMAValuesViewMAValuesIterator(MAMap.MAValuesView.MAValuesIterator<K, V> itr, LockingManager lockingManager) {
            super(itr, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMAMapMAValuesViewMAValuesIterator<K, V>((MAMap.MAValuesView.MAValuesIterator<K, V>)obj, this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public void addValuesElementListener(ValuesElementListener<? super K, ? super V> listener) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.event.ValuesElementModificationAware<K, V>.addValuesElementListener(org.babyfish.collection.event.ValuesElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.event.ValuesElementModificationAware<K, V>.addValuesElementListener(org.babyfish.collection.event.ValuesElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.event.ValuesElementModificationAware<K, V>.addValuesElementListener(org.babyfish.collection.event.ValuesElementListener<? super K, ? super V>)")
                );
            }
            ((MAMap.MAValuesView.MAValuesIterator<K, V>)this.itr).addValuesElementListener(listener);
        }

        @SuppressWarnings("unchecked")
        @Override
        public void removeValuesElementListener(ValuesElementListener<? super K, ? super V> listener) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.event.ValuesElementModificationAware<K, V>.removeValuesElementListener(org.babyfish.collection.event.ValuesElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.event.ValuesElementModificationAware<K, V>.removeValuesElementListener(org.babyfish.collection.event.ValuesElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.event.ValuesElementModificationAware<K, V>.removeValuesElementListener(org.babyfish.collection.event.ValuesElementListener<? super K, ? super V>)")
                );
            }
            ((MAMap.MAValuesView.MAValuesIterator<K, V>)this.itr).removeValuesElementListener(listener);
        }
    }

    private static class LockingMAMapMAEntrySetViewMAEntrySetIterator<K, V> extends LockingMACollectionMAIterator<Map.Entry<K, V>> implements MAMap.MAEntrySetView.MAEntrySetIterator<K, V> {

        LockingMAMapMAEntrySetViewMAEntrySetIterator(MAMap.MAEntrySetView.MAEntrySetIterator<K, V> itr, LockingManager lockingManager) {
            super(itr, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMAMapMAEntrySetViewMAEntrySetIterator<K, V>((MAMap.MAEntrySetView.MAEntrySetIterator<K, V>)obj, this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public MAMap.MAEntry<K, V> next() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.MAMap.MAEntry<K, V> org.babyfish.collection.MAMap$MAEntrySetView.MAEntrySetIterator<K, V>.next()")
                );
            }
            return MACollections.locking(((MAMap.MAEntrySetView.MAEntrySetIterator<K, V>)this.itr).next(), this.lockingManager);
        }
    }

    private static class LockingMAListMAListIterator<E> extends LockingMACollectionMAIterator<E> implements MAList.MAListIterator<E> {

        LockingMAListMAListIterator(MAList.MAListIterator<E> itr, LockingManager lockingManager) {
            super(itr, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMAListMAListIterator<E>((MAList.MAListIterator<E>)obj, this.lockingManager);
        }

        @Override
        public void removeListElementListener(ListElementListener<? super E> listener) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.MAList.MAListIterator<E>.removeListElementListener(org.babyfish.collection.event.ListElementListener<? super E>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.MAList.MAListIterator<E>.removeListElementListener(org.babyfish.collection.event.ListElementListener<? super E>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.MAList.MAListIterator<E>.removeListElementListener(org.babyfish.collection.event.ListElementListener<? super E>)")
                );
            }
            ((MAList.MAListIterator<E>)this.itr).removeListElementListener(listener);
        }

        @Override
        public void add(E e) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void java.util.ListIterator<E>.add(E)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void java.util.ListIterator<E>.add(E)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void java.util.ListIterator<E>.add(E)")
                );
            }
            ((MAList.MAListIterator<E>)this.itr).add(e);
        }

        @Override
        public boolean hasPrevious() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean java.util.ListIterator<E>.hasPrevious()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("boolean java.util.ListIterator<E>.hasPrevious()")
                );
            }
            return ((MAList.MAListIterator<E>)this.itr).hasPrevious();
        }

        @Override
        public int previousIndex() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("int java.util.ListIterator<E>.previousIndex()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("int java.util.ListIterator<E>.previousIndex()")
                );
            }
            return ((MAList.MAListIterator<E>)this.itr).previousIndex();
        }

        @Override
        public void addListElementListener(ListElementListener<? super E> listener) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.MAList.MAListIterator<E>.addListElementListener(org.babyfish.collection.event.ListElementListener<? super E>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.MAList.MAListIterator<E>.addListElementListener(org.babyfish.collection.event.ListElementListener<? super E>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.MAList.MAListIterator<E>.addListElementListener(org.babyfish.collection.event.ListElementListener<? super E>)")
                );
            }
            ((MAList.MAListIterator<E>)this.itr).addListElementListener(listener);
        }

        @Override
        public E previous() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.ListIterator<E>.previous()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.ListIterator<E>.previous()")
                );
            }
            return ((MAList.MAListIterator<E>)this.itr).previous();
        }

        @Override
        public int nextIndex() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("int java.util.ListIterator<E>.nextIndex()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("int java.util.ListIterator<E>.nextIndex()")
                );
            }
            return ((MAList.MAListIterator<E>)this.itr).nextIndex();
        }

        @Override
        public void set(E e) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void java.util.ListIterator<E>.set(E)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void java.util.ListIterator<E>.set(E)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void java.util.ListIterator<E>.set(E)")
                );
            }
            ((MAList.MAListIterator<E>)this.itr).set(e);
        }
    }

    private static class LockingMAMapMAKeySetViewMAKeySetIterator<K, V> extends LockingMACollectionMAIterator<K> implements MAMap.MAKeySetView.MAKeySetIterator<K, V> {

        LockingMAMapMAKeySetViewMAKeySetIterator(MAMap.MAKeySetView.MAKeySetIterator<K, V> itr, LockingManager lockingManager) {
            super(itr, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMAMapMAKeySetViewMAKeySetIterator<K, V>((MAMap.MAKeySetView.MAKeySetIterator<K, V>)obj, this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public void removeKeySetElementListener(KeySetElementListener<? super K, ? super V> listener) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.removeKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.removeKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.removeKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
                );
            }
            ((MAMap.MAKeySetView.MAKeySetIterator<K, V>)this.itr).removeKeySetElementListener(listener);
        }

        @SuppressWarnings("unchecked")
        @Override
        public void addKeySetElementListener(KeySetElementListener<? super K, ? super V> listener) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.addKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.addKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.event.KeySetElementModificationAware<K, V>.addKeySetElementListener(org.babyfish.collection.event.KeySetElementListener<? super K, ? super V>)")
                );
            }
            ((MAMap.MAKeySetView.MAKeySetIterator<K, V>)this.itr).addKeySetElementListener(listener);
        }
    }

    private static class LockingMACollectionMAIterator<E> extends LockingXCollectionXIterator<E> implements MACollection.MAIterator<E> {

        LockingMACollectionMAIterator(MACollection.MAIterator<E> itr, LockingManager lockingManager) {
            super(itr, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMACollectionMAIterator<E>((MACollection.MAIterator<E>)obj, this.lockingManager);
        }

        @Override
        public void addElementListener(ElementListener<? super E> listener) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.MACollection.MAIterator<E>.addElementListener(org.babyfish.collection.event.ElementListener<? super E>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.MACollection.MAIterator<E>.addElementListener(org.babyfish.collection.event.ElementListener<? super E>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.MACollection.MAIterator<E>.addElementListener(org.babyfish.collection.event.ElementListener<? super E>)")
                );
            }
            ((MACollection.MAIterator<E>)this.itr).addElementListener(listener);
        }

        @Override
        public void removeElementListener(ElementListener<? super E> listener) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.MACollection.MAIterator<E>.removeElementListener(org.babyfish.collection.event.ElementListener<? super E>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.MACollection.MAIterator<E>.removeElementListener(org.babyfish.collection.event.ElementListener<? super E>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.MACollection.MAIterator<E>.removeElementListener(org.babyfish.collection.event.ElementListener<? super E>)")
                );
            }
            ((MACollection.MAIterator<E>)this.itr).removeElementListener(listener);
        }
    }

    private static class LockingXListXListIterator<E> extends LockingXCollectionXIterator<E> implements XList.XListIterator<E> {

        LockingXListXListIterator(XList.XListIterator<E> itr, LockingManager lockingManager) {
            super(itr, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXListXListIterator<E>((XList.XListIterator<E>)obj, this.lockingManager);
        }

        @Override
        public void add(E e) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void java.util.ListIterator<E>.add(E)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void java.util.ListIterator<E>.add(E)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void java.util.ListIterator<E>.add(E)")
                );
            }
            ((XList.XListIterator<E>)this.itr).add(e);
        }

        @Override
        public boolean hasPrevious() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean java.util.ListIterator<E>.hasPrevious()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("boolean java.util.ListIterator<E>.hasPrevious()")
                );
            }
            return ((XList.XListIterator<E>)this.itr).hasPrevious();
        }

        @Override
        public E previous() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.ListIterator<E>.previous()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.ListIterator<E>.previous()")
                );
            }
            return ((XList.XListIterator<E>)this.itr).previous();
        }

        @Override
        public int previousIndex() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("int java.util.ListIterator<E>.previousIndex()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("int java.util.ListIterator<E>.previousIndex()")
                );
            }
            return ((XList.XListIterator<E>)this.itr).previousIndex();
        }

        @Override
        public int nextIndex() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("int java.util.ListIterator<E>.nextIndex()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("int java.util.ListIterator<E>.nextIndex()")
                );
            }
            return ((XList.XListIterator<E>)this.itr).nextIndex();
        }

        @Override
        public void set(E e) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void java.util.ListIterator<E>.set(E)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void java.util.ListIterator<E>.set(E)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void java.util.ListIterator<E>.set(E)")
                );
            }
            ((XList.XListIterator<E>)this.itr).set(e);
        }
    }

    private static class LockingXMapXEntrySetViewXEntrySetIterator<K, V> extends LockingXCollectionXIterator<Map.Entry<K, V>> implements XMap.XEntrySetView.XEntrySetIterator<K, V> {

        LockingXMapXEntrySetViewXEntrySetIterator(XMap.XEntrySetView.XEntrySetIterator<K, V> itr, LockingManager lockingManager) {
            super(itr, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXMapXEntrySetViewXEntrySetIterator<K, V>((XMap.XEntrySetView.XEntrySetIterator<K, V>)obj, this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public XMap.XEntry<K, V> next() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.XMap.XEntry<K, V> org.babyfish.collection.XMap$XEntrySetView.XEntrySetIterator<K, V>.next()")
                );
            }
            return MACollections.locking(((XMap.XEntrySetView.XEntrySetIterator<K, V>)this.itr).next(), this.lockingManager);
        }
    }

    private static class LockingXCollectionXIterator<E> extends LockingIterator<E> implements XCollection.XIterator<E> {

        LockingXCollectionXIterator(XCollection.XIterator<E> itr, LockingManager lockingManager) {
            super(itr, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXCollectionXIterator<E>((XCollection.XIterator<E>)obj, this.lockingManager);
        }

        @Override
        public UnifiedComparator<? super E> unifiedComparator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.UnifiedComparator<? super E> org.babyfish.collection.XCollection.XIterator<E>.unifiedComparator()")
                );
            }
            return ((XCollection.XIterator<E>)this.itr).unifiedComparator();
        }

        @Override
        public ViewInfo viewInfo() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.view.ViewInfo org.babyfish.collection.XCollection.XIterator<E>.viewInfo()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.view.ViewInfo org.babyfish.collection.XCollection.XIterator<E>.viewInfo()")
                );
            }
            return ((XCollection.XIterator<E>)this.itr).viewInfo();
        }

        @Override
        public boolean isReadWriteLockSupported() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean org.babyfish.lang.LockDescriptor.isReadWriteLockSupported()")
                );
            }
            return ((XCollection.XIterator<E>)this.itr).isReadWriteLockSupported();
        }
    }

    private static class LockingStandardMapEntrySetEntryIterator<K, V> extends LockingIterator<Map.Entry<K, V>> implements StandardMap.EntrySet.EntryIterator<K, V> {

        LockingStandardMapEntrySetEntryIterator(StandardMap.EntrySet.EntryIterator<K, V> itr, LockingManager lockingManager) {
            super(itr, lockingManager);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockingStandardMapEntrySetEntryIterator() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingStandardMapEntrySetEntryIterator<K, V>((StandardMap.EntrySet.EntryIterator<K, V>)obj, this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        public Map.Entry<K, V> next() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("java.util.Map.Entry<K, V> org.babyfish.collection.MACollections$StandardMap$EntrySet.EntryIterator<K, V>.next()")
                );
            }
            return MACollections.locking(((StandardMap.EntrySet.EntryIterator<K, V>)this.itr).next(), this.lockingManager);
        }
    }

    private static class LockingStandardMapEntrySetEntryIteratorWithSerializable<K, V> extends LockingStandardMapEntrySetEntryIterator<K, V> implements Serializable {

        private static final long serialVersionUID = -7201348745687356877L;

        LockingStandardMapEntrySetEntryIteratorWithSerializable(StandardMap.EntrySet.EntryIterator<K, V> itr, LockingManager lockingManager) {
            super(itr, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingStandardMapEntrySetEntryIteratorWithSerializable<K, V>((StandardMap.EntrySet.EntryIterator<K, V>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.itr);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.itr = (StandardMap.EntrySet.EntryIterator<K, V>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingListIterator<E> extends LockingIterator<E> implements ListIterator<E> {

        LockingListIterator(ListIterator<E> itr, LockingManager lockingManager) {
            super(itr, lockingManager);
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockingListIterator() {
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingListIterator<E>((ListIterator<E>)obj, this.lockingManager);
        }

        @Override
        public void add(E e) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void java.util.ListIterator<E>.add(E)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void java.util.ListIterator<E>.add(E)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void java.util.ListIterator<E>.add(E)")
                );
            }
            ((ListIterator<E>)this.itr).add(e);
        }

        @Override
        public boolean hasPrevious() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean java.util.ListIterator<E>.hasPrevious()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("boolean java.util.ListIterator<E>.hasPrevious()")
                );
            }
            return ((ListIterator<E>)this.itr).hasPrevious();
        }

        @Override
        public E previous() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.ListIterator<E>.previous()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.ListIterator<E>.previous()")
                );
            }
            return ((ListIterator<E>)this.itr).previous();
        }

        @Override
        public int previousIndex() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("int java.util.ListIterator<E>.previousIndex()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("int java.util.ListIterator<E>.previousIndex()")
                );
            }
            return ((ListIterator<E>)this.itr).previousIndex();
        }

        @Override
        public int nextIndex() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("int java.util.ListIterator<E>.nextIndex()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("int java.util.ListIterator<E>.nextIndex()")
                );
            }
            return ((ListIterator<E>)this.itr).nextIndex();
        }

        @Override
        public void set(E e) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void java.util.ListIterator<E>.set(E)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void java.util.ListIterator<E>.set(E)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void java.util.ListIterator<E>.set(E)")
                );
            }
            ((ListIterator<E>)this.itr).set(e);
        }
    }

    private static class LockingListIteratorWithSerializable<E> extends LockingListIterator<E> implements Serializable {

        private static final long serialVersionUID = -1408260238L;

        LockingListIteratorWithSerializable(ListIterator<E> itr, LockingManager lockingManager) {
            super(itr, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingListIteratorWithSerializable<E>((ListIterator<E>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.itr);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.itr = (ListIterator<E>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingIterator<E> extends LockingProxy implements Iterator<E> {

        Iterator<E> itr;

        LockingIterator(Iterator<E> itr, LockingManager lockingManager) {
            super(lockingManager);
            this.itr = itr;
        }

        @Deprecated //Only for deserialization
        LockingIterator() {
        }

        @Override
        Object getInnerObject() {
            return this.itr;
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingIterator<E>((Iterator<E>)obj, this.lockingManager);
        }

        @Override
        public void remove() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void java.util.Iterator<E>.remove()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void java.util.Iterator<E>.remove()")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void java.util.Iterator<E>.remove()")
                );
            }
            this.itr.remove();
        }

        @Override
        public boolean hasNext() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean java.util.Iterator<E>.hasNext()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("boolean java.util.Iterator<E>.hasNext()")
                );
            }
            return this.itr.hasNext();
        }

        @Override
        public E next() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("E java.util.Iterator<E>.next()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("E java.util.Iterator<E>.next()")
                );
            }
            return this.itr.next();
        }
    }

    private static class LockingIteratorWithSerializable<E> extends LockingIterator<E> implements Serializable {

        private static final long serialVersionUID = 1926012641861839728L;

        LockingIteratorWithSerializable(Iterator<E> itr, LockingManager lockingManager) {
            super(itr, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingIteratorWithSerializable<E>((Iterator<E>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.itr);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.itr = (Iterator<E>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }

    private static class LockingMAMapMAEntry<K, V> extends LockingXMapXEntry<K, V> implements MAMap.MAEntry<K, V> {

        LockingMAMapMAEntry(MAMap.MAEntry<K, V> e, LockingManager lockingManager) {
            super(e, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMAMapMAEntry<K, V>((MAMap.MAEntry<K, V>)obj, this.lockingManager);
        }

        @Override
        public void removeElementListener(ElementListener<? super V> listener) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.event.ElementModificationAware<V>.removeElementListener(org.babyfish.collection.event.ElementListener<? super V>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.event.ElementModificationAware<V>.removeElementListener(org.babyfish.collection.event.ElementListener<? super V>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.event.ElementModificationAware<V>.removeElementListener(org.babyfish.collection.event.ElementListener<? super V>)")
                );
            }
            ((MAMap.MAEntry<K, V>)this.e).removeElementListener(listener);
        }

        @Override
        public void addEntryElementListener(EntryElementListener<? super K, ? super V> listener) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.event.EntryElementModificationAware<K, V>.addEntryElementListener(org.babyfish.collection.event.EntryElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.event.EntryElementModificationAware<K, V>.addEntryElementListener(org.babyfish.collection.event.EntryElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.event.EntryElementModificationAware<K, V>.addEntryElementListener(org.babyfish.collection.event.EntryElementListener<? super K, ? super V>)")
                );
            }
            ((MAMap.MAEntry<K, V>)this.e).addEntryElementListener(listener);
        }

        @Override
        public void addElementListener(ElementListener<? super V> listener) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.event.ElementModificationAware<V>.addElementListener(org.babyfish.collection.event.ElementListener<? super V>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.event.ElementModificationAware<V>.addElementListener(org.babyfish.collection.event.ElementListener<? super V>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.event.ElementModificationAware<V>.addElementListener(org.babyfish.collection.event.ElementListener<? super V>)")
                );
            }
            ((MAMap.MAEntry<K, V>)this.e).addElementListener(listener);
        }

        @Override
        public void removeEntryElementListener(EntryElementListener<? super K, ? super V> listener) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("void org.babyfish.collection.event.EntryElementModificationAware<K, V>.removeEntryElementListener(org.babyfish.collection.event.EntryElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("void org.babyfish.collection.event.EntryElementModificationAware<K, V>.removeEntryElementListener(org.babyfish.collection.event.EntryElementListener<? super K, ? super V>)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("void org.babyfish.collection.event.EntryElementModificationAware<K, V>.removeEntryElementListener(org.babyfish.collection.event.EntryElementListener<? super K, ? super V>)")
                );
            }
            ((MAMap.MAEntry<K, V>)this.e).removeEntryElementListener(listener);
        }
    }

    private static class LockingXMapXEntry<K, V> extends LockingMapEntry<K, V> implements XMap.XEntry<K, V> {

        LockingXMapXEntry(XMap.XEntry<K, V> e, LockingManager lockingManager) {
            super(e, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingXMapXEntry<K, V>((XMap.XEntry<K, V>)obj, this.lockingManager);
        }

        @Override
        public UnifiedComparator<? super K> keyUnifiedComparator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.UnifiedComparator<? super K> org.babyfish.collection.XMap.XEntry<K, V>.keyUnifiedComparator()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.collection.UnifiedComparator<? super K> org.babyfish.collection.XMap.XEntry<K, V>.keyUnifiedComparator()")
                );
            }
            return ((XMap.XEntry<K, V>)this.e).keyUnifiedComparator();
        }

        @Override
        public UnifiedComparator<? super Map.Entry<K, V>> unifiedComparator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.UnifiedComparator<? super java.util.Map.Entry<K, V>> org.babyfish.collection.XMap.XEntry<K, V>.unifiedComparator()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.collection.UnifiedComparator<? super java.util.Map.Entry<K, V>> org.babyfish.collection.XMap.XEntry<K, V>.unifiedComparator()")
                );
            }
            return ((XMap.XEntry<K, V>)this.e).unifiedComparator();
        }

        @Override
        public ViewInfo viewInfo() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.view.ViewInfo org.babyfish.view.View.viewInfo()")
                );
            }
            return ((XMap.XEntry<K, V>)this.e).viewInfo();
        }

        @Override
        public boolean isAlive() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean org.babyfish.collection.XMap.XEntry<K, V>.isAlive()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("boolean org.babyfish.collection.XMap.XEntry<K, V>.isAlive()")
                );
            }
            return ((XMap.XEntry<K, V>)this.e).isAlive();
        }

        @Override
        public UnifiedComparator<? super V> valueUnifiedComparator() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("org.babyfish.collection.UnifiedComparator<? super V> org.babyfish.collection.XMap.XEntry<K, V>.valueUnifiedComparator()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("org.babyfish.collection.UnifiedComparator<? super V> org.babyfish.collection.XMap.XEntry<K, V>.valueUnifiedComparator()")
                );
            }
            return ((XMap.XEntry<K, V>)this.e).valueUnifiedComparator();
        }

        @Override
        public boolean isReadWriteLockSupported() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean org.babyfish.lang.LockDescriptor.isReadWriteLockSupported()")
                );
            }
            return ((XMap.XEntry<K, V>)this.e).isReadWriteLockSupported();
        }
    }

    private static class LockingMapEntry<K, V> extends LockingProxy implements Map.Entry<K, V> {

        Map.Entry<K, V> e;

        LockingMapEntry(Map.Entry<K, V> e, LockingManager lockingManager) {
            super(lockingManager);
            this.e = e;
        }

        @SuppressWarnings("unused")
        @Deprecated //Only for deserialization
        LockingMapEntry() {
        }

        @Override
        Object getInnerObject() {
            return this.e;
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMapEntry<K, V>((Map.Entry<K, V>)obj, this.lockingManager);
        }

        @Override
        public String toString() {
            return this.e.toString();
        }

        @Override
        public int hashCode() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("int java.util.Map.Entry<K, V>.hashCode()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("int java.util.Map.Entry<K, V>.hashCode()")
                );
            }
            return this.e.hashCode();
        }

        @Override
        public K getKey() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("K java.util.Map.Entry<K, V>.getKey()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("K java.util.Map.Entry<K, V>.getKey()")
                );
            }
            return this.e.getKey();
        }

        @Override
        public V getValue() {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("V java.util.Map.Entry<K, V>.getValue()")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("V java.util.Map.Entry<K, V>.getValue()")
                );
            }
            return this.e.getValue();
        }

        @Override
        public boolean equals(Object obj) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("boolean java.util.Map.Entry<K, V>.equals(java.lang.Object)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("boolean java.util.Map.Entry<K, V>.equals(java.lang.Object)")
                );
            }
            return this.e.equals(obj);
        }

        @Override
        public V setValue(V value) {
            if (this.initThread != Thread.currentThread()) {
                throw new IllegalThreadException(
                    illegalLockingThread("V java.util.Map.Entry<K, V>.setValue(V)")
                );
            }
            if (this.lockingManager.state == LockingManager.DISPOSED) {
                throw new LockingObjectDisposedException(
                    lockingObjectDisposed("V java.util.Map.Entry<K, V>.setValue(V)")
                );
            }
            if (this.lockingManager.state != LockingManager.WRITE) {
                throw new RequiredWritableLockingOperationException(
                    illegalLockMode("V java.util.Map.Entry<K, V>.setValue(V)")
                );
            }
            return this.e.setValue(value);
        }
    }

    private static class LockingMapEntryWithSerializable<K, V> extends LockingMapEntry<K, V> implements Serializable {

        private static final long serialVersionUID = -1425277512L;

        LockingMapEntryWithSerializable(Map.Entry<K, V> e, LockingManager lockingManager) {
            super(e, lockingManager);
        }

        @SuppressWarnings("unchecked")
        @Override
        <T> T recreate(T obj) {
            return (T)new LockingMapEntryWithSerializable<K, V>((Map.Entry<K, V>)obj, this.lockingManager);
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.e);
            out.writeObject(this.lockingManager);
        }

        @SuppressWarnings("unchecked")
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            this.e = (Map.Entry<K, V>)in.readObject();
            this.lockingManager = (LockingManager)in.readObject();
        }
    }
}
